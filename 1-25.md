---
title: flink
date: 1-25 8.40
categories: 日志
comments: "true"
tag: flink
---
# flink

## 简介

从14年到15年1月就正式开始

flink本身是德语词，代表快速灵巧

```
Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams. Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale.

Here, we explain important aspects of Flink’s architecture.
```

## 数据类型

边界流：**Bounded streams ： 有明确的开始以及结束的流 也为人所知是批处理（batch processing）**

无边界流：**Unbounded streams :有开始无结束的边界流**

## flink特点

flink处理的数据类型也在从边界流逐渐转向无边界流 :一起是边界流 现在是无边界流

flink是个分布式系统

flink针对本地访问进行了优化-> 任务的状态始终保存在内存中如果追昂太大小超过可用内存，那么则会把他存储在能高效访问的磁盘数据结构中->任务通过访问本地（通常在内存中）状态来进行所有的计算，从而产生非常低的处理延迟。Flink 通过定期和异步地对本地状态进行持久化存储来保证故障场景下精确一次的状态一致性。

## flink应用

### 数据

* 有界
* 无界
* 实时
* 离线

### 状态

只有在每一个单独的事件上进行转换操作的应用才不需要状态，换言之，每一个具有一定复杂度的流处理应用都是有状态的。

Flink 提供了许多状态管理相关的特性支持，其中包括：

* **多种状态基础类型** ： 例如 value ，map ，list
* **插件化的State Backend** ： State Backend 负责管理应用程序状态，并在需要的时候进行 checkpoint。Flink 支持多种 state backend，可以将状态存在内存或者 [RocksDB](https://rocksdb.org/)。RocksDB 是一种高效的嵌入式、持久化键值存储引擎。Flink 也支持插件式的自定义 state backend 进行状态存储。
* **精确一次语义** ： 就是kafka里的精准一次 -> 说明flink支持事务
* **超大数据量状态** ： Flink 能够利用其异步以及增量式的 checkpoint 算法，存储数 TB 级别的应用状态。
* **可弹性伸缩的应用** ： Flink 能够通过在更多或更少的工作节点上对状态进行重新分布，支持有状态应用的分布式的横向伸缩。

### 时间

时间是流处理应用另一个重要的组成部分。因为事件总是在特定时间点发生，所以大多数的事件流都拥有事件本身所固有的时间语义。进一步而言，许多常见的流计算都基于时间语义，例如窗口聚合、会话计算、模式检测和基于时间的 join。流处理的一个重要方面是应用程序如何衡量时间，即区分事件时间（event-time）和处理时间（processing-time）。

* **事件时间模式** ： 使用事件时间语义的流处理应用根据事件本身自带的时间戳进行结果的计算。因此，无论处理的是历史记录的事件还是实时的事件，事件时间模式的处理总能保证结果的准确性和一致性。
* **Watermark 支持** ： Flink 引入了 watermark 的概念，用以衡量事件时间进展。Watermark 也是一种平衡处理延时和完整性的灵活机制。
* **迟到数据处理** ：当以带有 watermark 的事件时间模式处理数据流时，在计算完成之后仍会有相关数据到达。这样的事件被称为迟到事件。Flink 提供了多种处理迟到数据的选项，例如将这些数据重定向到旁路输出（side output）或者更新之前完成计算的结果
* **处理时间模式** ：除了事件时间模式，Flink 还支持处理时间语义。处理时间模式根据处理引擎的机器时钟触发计算，一般适用于有着严格的低延迟需求，并且能够容忍近似结果的流处理应用。

## 分层APi

Flink 根据抽象程度分层，提供了三种不同的 API。每一种 API 在简洁性和表达力上有着不同的侧重，并且针对不同的应用场景。

如下 ：

![](https://pic.imgdb.cn/item/63d7aea6face21e9ef369bfb.jpg)

### ProcessFunction

[ProcessFunction](https://nightlies.apache.org/flink/flink-docs-stable/dev/stream/operators/process_function.html) 是 Flink 所提供的最具表达力的接口。ProcessFunction 可以处理一或两条输入数据流中的单个事件或者归入一个特定窗口内的多个事件。它提供了对于时间和状态的细粒度控制。开发者可以在其中任意地修改状态，也能够注册定时器用以在未来的某一时刻触发回调函数。因此，你可以利用 ProcessFunction 实现许多[有状态的事件驱动应用](https://flink.apache.org/zh/usecases.html#eventDrivenApps)所需要的基于单个事件的复杂业务逻辑。

相当于计时器的用处，下处是官方的例子：

官方的例子是设置开始，并登记一个4小时的的计时器，当提前返回end，则是提前结束并返回时间，当到4小时则清空状态并结束

```
/**

 * 将相邻的 keyed START 和 END 事件相匹配并计算两者的时间间隔
 * 输入数据为 Tuple2<String, String> 类型，第一个字段为 key 值， 
 * 第二个字段标记 START 和 END 事件。
    */
public static class StartEndDuration
    extends KeyedProcessFunction<String, Tuple2<String, String>, Tuple2<String, Long>> {

  private ValueState<Long> startTime;

  @Override
  public void open(Configuration conf) {
    // obtain state handle
    startTime = getRuntimeContext()
      .getState(new ValueStateDescriptor<Long>("startTime", Long.class));
  }

  /** Called for each processed event. */
  @Override
  public void processElement(
      Tuple2<String, String> in,
      Context ctx,
      Collector<Tuple2<String, Long>> out) throws Exception {

    switch (in.f1) {
      case "START":
        // set the start time if we receive a start event.
        startTime.update(ctx.timestamp());
        // register a timer in four hours from the start event.
        ctx.timerService()
          .registerEventTimeTimer(ctx.timestamp() + 4 * 60 * 60 * 1000);
        break;
      case "END":
        // emit the duration between start and end event
        Long sTime = startTime.value();
        if (sTime != null) {
          out.collect(Tuple2.of(in.f0, ctx.timestamp() - sTime));
          // clear the state
          startTime.clear();
        }
      default:
        // do nothing
    }
  }

  /** Called when a timer fires. */
  @Override
  public void onTimer(
      long timestamp,
      OnTimerContext ctx,
      Collector<Tuple2<String, Long>> out) {

    // Timeout interval exceeded. Cleaning up the state.
    startTime.clear();
  }
}
```

### DataStream API

[DataStream API](https://nightlies.apache.org/flink/flink-docs-stable/dev/datastream_api.html) 为许多通用的流处理操作提供了处理原语。这些操作包括窗口、逐条记录的转换操作，在处理事件时进行外部数据库查询等。DataStream API 支持 Java 和 Scala 语言，预先定义了例如 `map()`、`reduce()`、`aggregate()` 等函数。你可以通过扩展实现预定义接口或使用 Java、Scala 的 lambda 表达式实现自定义的函数。

下面的代码示例展示了如何捕获会话时间范围内所有的点击流事件，并对每一次会话的点击量进行计数。

```
// 网站点击 Click 的数据流
DataStream<Click> clicks = ...

DataStream<Tuple2<String, Long>> result = clicks
  // 将网站点击映射为 (userId, 1) 以便计数
  .map(
    // 实现 MapFunction 接口定义函数
    new MapFunction<Click, Tuple2<String, Long>>() {
      @Override
      public Tuple2<String, Long> map(Click click) {
        return Tuple2.of(click.userId, 1L);
      }
    })
  // 以 userId (field 0) 作为 key
  .keyBy(0)
  // 定义 30 分钟超时的会话窗口
  .window(EventTimeSessionWindows.withGap(Time.minutes(30L)))
  // 对每个会话窗口的点击进行计数，使用 lambda 表达式定义 reduce 函数
  .reduce((a, b) -> Tuple2.of(a.f0, a.f1 + b.f1));
```

### SQL & Table API

Flink 支持两种关系型的 API，[Table API 和 SQL](https://nightlies.apache.org/flink/flink-docs-stable/dev/table/index.html)。这两个 API 都是批处理和流处理统一的 API，这意味着在无边界的实时数据流和有边界的历史记录数据流上，关系型 API 会以相同的语义执行查询，并产生相同的结果。Table API 和 SQL 借助了 [Apache Calcite](https://calcite.apache.org/) 来进行查询的解析，校验以及优化。它们可以与 DataStream 和 DataSet API 无缝集成，并支持用户自定义的标量函数，聚合函数以及表值函数。

Flink 的关系型 API 旨在简化[数据分析](https://flink.apache.org/zh/usecases.html#analytics)、[数据流水线和 ETL 应用](https://flink.apache.org/zh/usecases.html#pipelines)的定义。

下面的代码示例展示了如何使用 SQL 语句查询捕获会话时间范围内所有的点击流事件，并对每一次会话的点击量进行计数。此示例与上述 DataStream API 中的示例有着相同的逻辑。

```
SELECT userId, COUNT(*)
FROM clicks
GROUP BY SESSION(clicktime, INTERVAL '30' MINUTE), userId
```

## 库

Flink 具有数个适用于常见数据处理应用场景的扩展库。这些库通常嵌入在 API 中，且并不完全独立于其它 API。它们也因此可以受益于 API 的所有特性，并与其他库集成。

* **[复杂事件处理(CEP)](https://nightlies.apache.org/flink/flink-docs-stable/dev/libs/cep.html)** ：模式检测是事件流处理中的一个非常常见的用例。Flink 的 CEP 库提供了 API，使用户能够以例如正则表达式或状态机的方式指定事件模式。CEP 库与 Flink 的 DataStream API 集成，以便在 DataStream 上评估模式。CEP 库的应用包括网络入侵检测，业务流程监控和欺诈检测。
* **[DataSet API](https://nightlies.apache.org/flink/flink-docs-stable/dev/batch/index.html)** ：DataSet API 是 Flink 用于批处理应用程序的核心 API。DataSet API 所提供的基础算子包括 *map* 、 *reduce* 、 *(outer) join* 、 *co-group* 、*iterate*等。所有算子都有相应的算法和数据结构支持，对内存中的序列化数据进行操作。如果数据大小超过预留内存，则过量数据将存储到磁盘。Flink 的 DataSet API 的数据处理算法借鉴了传统数据库算法的实现，例如混合散列连接（hybrid hash-join）和外部归并排序（external merge-sort）。
* **[Gelly](https://nightlies.apache.org/flink/flink-docs-stable/dev/libs/gelly/index.html)** : Gelly 是一个可扩展的图形处理和分析库。Gelly 是在 DataSet API 之上实现的，并与 DataSet API 集成。因此，它能够受益于其可扩展且健壮的操作符。Gelly 提供了[内置算法](https://nightlies.apache.org/flink/flink-docs-stable/dev/libs/gelly/library_methods.html)，如 label propagation、triangle enumeration 和 page rank 算法，也提供了一个简化自定义图算法实现的 [Graph API](https://nightlies.apache.org/flink/flink-docs-stable/dev/libs/gelly/graph_api.html)。

## flink运维

Flink通过几下多种机制维护应用可持续运行及其一致性:

* **检查点的一致性** : Flink的故障恢复机制是通过建立分布式应用服务状态一致性检查点实现的，当有故障产生时，应用服务会重启后，再重新加载上一次成功备份的状态检查点信息。结合可重放的数据源，该特性可保证 *精确一次（exactly-once）* 的状态一致性。
* **高效的检查点** : 如果一个应用要维护一个TB级的状态信息，对此应用的状态建立检查点服务的资源开销是很高的，为了减小因检查点服务对应用的延迟性（SLAs服务等级协议）的影响，Flink采用异步及增量的方式构建检查点服务。
* **端到端的精确一次** : Flink 为某些特定的存储支持了事务型输出的功能，及时在发生故障的情况下，也能够保证精确一次的输出。
* **集成多种集群管理服务** : Flink已与多种集群管理服务紧密集成，如 [Hadoop YARN](https://hadoop.apache.org/), [Mesos](https://mesos.apache.org/), 以及 [Kubernetes](https://kubernetes.io/)。当集群中某个流程任务失败后，一个新的流程服务会自动启动并替代它继续执行。
* **内置高可用服务** : Flink内置了为解决单点故障问题的高可用性服务模块，此模块是基于[Apache ZooKeeper](https://zookeeper.apache.org/) 技术实现的，[Apache ZooKeeper](https://zookeeper.apache.org/)是一种可靠的、交互式的、分布式协调服务组件。

## Flink能够更方便地升级、迁移、暂停、恢复应用服务

而Flink的 *Savepoint* 服务就是为解决升级服务过程中记录流应用状态信息及其相关难题而产生的一种唯一的、强大的组件。一个 Savepoint，就是一个应用服务状态的一致性快照，因此其与checkpoint组件的很相似，但是与checkpoint相比，Savepoint 需要手动触发启动，而且当流应用服务停止时，它并不会自动删除。Savepoint 常被应用于启动一个已含有状态的流服务，并初始化其（备份时）状态。Savepoint 有以下特点：

* **便于升级应用服务版本** : Savepoint 常在应用版本升级时使用，当前应用的新版本更新升级时，可以根据上一个版本程序记录的 Savepoint 内的服务状态信息来重启服务。它也可能会使用更早的 Savepoint 还原点来重启服务，以便于修复由于有缺陷的程序版本导致的不正确的程序运行结果。
* **方便集群服务移植** : 通过使用 Savepoint，流服务应用可以自由的在不同集群中迁移部署。
* **方便Flink版本升级** : 通过使用 Savepoint，可以使应用服务在升级Flink时，更加安全便捷。
* **增加应用并行服务的扩展性** : Savepoint 也常在增加或减少应用服务集群的并行度时使用。
* **便于A/B测试及假设分析场景对比结果** : 通过把同一应用在使用不同版本的应用程序，基于同一个 Savepoint 还原点启动服务时，可以测试对比2个或多个版本程序的性能及服务质量。
* **暂停和恢复服务** : 一个应用服务可以在新建一个 Savepoint 后再停止服务，以便于后面任何时间点再根据这个实时刷新的 Savepoint 还原点进行恢复服务。
* **归档服务** : Savepoint 还提供还原点的归档服务，以便于用户能够指定时间点的 Savepoint 的服务数据进行重置应用服务的状态，进行恢复服务。

## 监控和控制应用服务

如其它应用服务一样，持续运行的流应用服务也需要监控及集成到一些基础设施资源管理服务中，例如一个组件的监控服务及日志服务等。监控服务有助于预测问题并提前做出反应，日志服务提供日志记录能够帮助追踪、调查、分析故障发生的根本原因。最后，便捷易用的访问控制应用服务运行的接口也是Flink的一个重要的亮点特征。

Flink与许多常见的日志记录和监视服务集成得很好，并提供了一个REST API来控制应用服务和查询应用信息。具体表现如下：

* **Web UI方式** : Flink提供了一个web UI来观察、监视和调试正在运行的应用服务。并且还可以执行或取消组件或任务的执行。
* **日志集成服务** :Flink实现了流行的slf4j日志接口，并与日志框架[log4j](https://logging.apache.org/log4j/2.x/)或[logback](https://logback.qos.ch/)集成。
* **指标服务** : Flink提供了一个复杂的度量系统来收集和报告系统和用户定义的度量指标信息。度量信息可以导出到多个报表组件服务，包括 [JMX](https://en.wikipedia.org/wiki/Java_Management_Extensions), Ganglia, [Graphite](https://graphiteapp.org/), [Prometheus](https://prometheus.io/), [StatsD](https://github.com/etsy/statsd), [Datadog](https://www.datadoghq.com/), 和 [Slf4j](https://www.slf4j.org/).
* **标准的WEB REST API接口服务** : Flink提供多种REST API接口，有提交新应用程序、获取正在运行的应用程序的Savepoint服务信息、取消应用服务等接口。REST API还提供元数据信息和已采集的运行中或完成后的应用服务的指标信息。

## flink优点

处理流式数据

事件驱动

低延迟

高吞吐

准确性，以及容错性

支持精准一次

应用：

数据源 -> etl -> 数仓 -> flink -> 报表业务等

## flink解析

state ： 存储在内存中的数据 ，内存的数据响应快 ，但是不稳定

checkpoint ： 备份checkpoint ，当机器出现故障的时候可以恢复数据 -> 会周期行进行保存

对于数据的准确性：以lambad为例

通过两个系统（lambad系统,sparkStreaming）

* 流式处理 -> 实现快速
* 批处理 -> 保证顺序

先把数据通过流式处理进行数据处理，然后设定一定时间或者一定的数据量，当达到一定时间的时候或者数据量达到一定程度，再进行往下通过批处理发送，保证结果的顺序

衍生出flink

storm第一代

lambda第二代

flink第三代 -> 集成上面所有的

### 数据模型

sparkStreaming：

 采用RDD 实际上就是一组小数据的集合RDD

flink：

基本就是数据流 ，以event序列

### 运行时架构

spark是批计算，将DAG划分为不同的stage，一个完成才开始下一个

flink是标准的流执行，一个事件再一个节点处理完后可以直接发送到下一个节点

### 配置文件

jobmanager ：针对整个job的 =》 driver =》 会在启动的机器上  =》 其会和taskmanager进行通信，默认通信端口是 6123

rpc.address : 启动的机器，在配置文件里设置的

rpc.port : 通信端口

heap.size : 堆的内存 jvm中

process.size : taskmanager 的占用的内存，包括jvm以及堆外内存 默认开启

flink.size : task占用的内存，包括一些状态什么的 process.size 包含flink.size

numberTaskSlots: 一个任务在几个Solt上执行

parallelism：并行度 这个参数和上面的不一样，这个是运行的时候来的，上一个是直接给你分，不是在运行的时候的

taskmanager ： 针对job下的一个task的 =》 worker

## 搭建flink项目

在idea里

pom

```
       <dependency>
      <groupId>org.apache.flink</groupId>
      <artifactId>flink-scala_2.12</artifactId>
      <version>1.13.6</version>
    </dependency>

    <dependency>
      <groupId>org.apache.flink</groupId>
      <artifactId>flink-streaming-scala_2.12</artifactId>
      <version>1.13.6</version>
    </dependency>

```

代码：

```
package flinklearn

import org.apache.flink.api.scala.ExecutionEnvironment


object frist {
  def apply(): frist = new frist()
  def main(args: Array[String]): Unit = {
   // frist().piwc()
    frist().Streamwc()
  }
}



class frist() {

  //创建批处理执行环境类比sparksession
  val pienvironment =org.apache.flink.api.scala.ExecutionEnvironment.getExecutionEnvironment
  val streamingenv= org.apache.flink.streaming.api.scala.StreamExecutionEnvironment.getExecutionEnvironment

  // 批处理wc
  def piwc()={

    import org.apache.flink.api.scala._
    // 从文件中取数据
    val path = "F:\\bigdatajava\\src\\main\\resources\\wc.data"
    val value = pienvironment.readTextFile(path)

    // 对数据进行转换处理
    val resultds:DataSet[(String,Int)] = value.flatMap(_.split(",")).map((_,1)).groupBy(0).sum(1)
    resultds.print()
  }

  // 流处理wc
  def Streamwc() = {

    import org.apache.flink.streaming.api.scala._

    // 设置并行度 -> 界面的数字就是并行度，10> (flume,2) 前面的数字就是哪一个任务的id -> 是根据hash值进行分的 -> 默认是电脑的最大配置
    // 下面是全局设置
    // 还可按照每个算子后面设置
    // 因为每个算子都算一个单独的任务
    // val value1 = value.flatMap(_.split(",")).filter(_.nonEmpty).setParallelism(3).map((_, 1)).keyBy(0).sum(1).setParallelism(1)
    streamingenv.setParallelism(1)


    // 接受一个socket文本流
    val value = streamingenv.socketTextStream("bigdata3",8888)

    val value1 = value.flatMap(_.split(",")).filter(_.nonEmpty).map((_, 1)).keyBy(0).sum(1)

    value1.print().setParallelism(1)

    // 启动任务执行
    streamingenv.execute("first")

  }

}

```

## 部署flink并运行

先下载flink的包，我用的scala是2.12的所以下的是flink_scala_2.12的

根据自己的版本选择

地址：[flink](https://archive.apache.org/dist/flink)

下载完成上传到服务器

然后解压 -> 设置环境变量 -> 进入到flink的conf文件夹，编辑 flink-conf.yaml 文件 把参数 `jobmanager.rpc.address:`设置成主节点，然后按照需求是不是开启高可用，以及设置检查点的文件夹（如果文件夹放在hdfs上，则flink要两个依赖包，flink自己没有的分别是 `flink-shaded-hadoop-3-uber-3.1.1.7.2.9.0-173-9.0.jar`以及 `commons-cli-1.5.0.jar`）可以区[maven官网](https://mvnrepository.com/)下载，然后放到flink/lib下，这两个jar包要按照自己hadoop的版本进行下载

->然后再编辑workers -> 添加上子节点的名字 -> 分发到各个机器上

然后再主节点启动start-cluster.sh

就成功了 访问 `主节点:8081`

就可以访问flink的web页面

编写启动脚本如下：

```
case $1 in 
"start")
ssh bigdata5 "/home/hadoop/app/flink/bin/start-cluster.sh"
;;
"stop")
ssh bigdata5 "/home/hadoop/app/flink/bin/stop-cluster.sh"
;;
"status")
echo "web ui : bigdata5:8081"
jps| grep TaskManagerRunner
ssh bigdata4 "jps| grep TaskManagerRunner"
ssh bigdata5 "jps| grep StandaloneSessionClusterEntrypoint"
;;
*)
echo "error input you should use by start|stop|status"
;;
esac
```

把上述scala代码打包成jar包

### web

上传到服务器的web界面如下

![img](https://pic.imgdb.cn/item/63ddd0414757feff338bbb5c.jpg)然后设置运行主类，以及并行度，参数，checkpoint点就好

如果上述没有放置两个jar包，则是无法执行再hdfs上设置checkpoint文件夹的

上述的代码执行之后输出在哪里呢？

他会输出在task manager里，至于具体在哪个里，应该点击输出任务

如下：

![img](https://pic.imgdb.cn/item/63ddd2334757feff338eaa2e.jpg)

然后在web界面上点击task-manager -> 点击相应机器 -> 点击Stdout 就会看见控制台信息了

这就是web部署成功了

然后停止如下：

![](https://pic.imgdb.cn/item/63ddd30c4757feff338fe87d.jpg)

### 命令行

执行：`flink run -m bigdata5:8081 -c flinklearn.frist -p 2 ./bigdatajava-1.0-SNAPSHOT.jar`

就可以了，参数以及checkpoint可以加载后面，如果不设置，就走默认的

因为对于sockt文本流他的并行度就是1，所以外面无法改变

如下：

![](https://pic.imgdb.cn/item/63ddd5304757feff339342a7.jpg)

经过ctrl + c 或者其他操作之后，这个作业并不会停掉

通过 `flink list 9723a168e896e048b777473cb871e10a`后面的是job的id，其实知识为了更精准一下，这个参数是可选的

还可以接-a 代表查看所有的

通过 `flink cancel jobid`就可以对只定的jobid进行停止

如下 ：
![](https://pic.imgdb.cn/item/63ddd64f4757feff3394d986.jpg)

## 部署模式

flink为我们的不同场景设置了不同的模式

* 会话模式
* 单作业模式
* 应用模式

### 会话

先启动集群，然后其他的进行提交作业，就是我们上述的模式

优点：相当于集群先启动，索要的资源已经固定好了，集群的生命周期高于任何的job，不和job的结束而改变

缺点：资源不够的时候会出问题

和另外的资源管理平台结合用

### 单作业

每个作业都启动一个flink集群，就不会出现上述资源不够的问题

就是按照把资源按照作业来划分

相当于container

一般的时候是首选的，但是flink本身是没有办法用单作业的

他要借助别人的容器化的管理机制-> yarn/ k8s

### 应用模式

上述两种是都先在客户端进行执行的，然后再发送给jobmanager，但是会占用网络带宽，

而且对于单作业模式的情况很可能会在客户端拆分成好几个作业，任何根据他每个作业就启动一个集群的说法，会造成大量的资源浪费

然后我们直接把作业发送到jobmanager上直接由他做处理，就是应用模式

和单作业很像

单作业是作业和集群一对一

应用是应用和集群一对一

## 独立模式

不依赖任何外部资源管理平台

最基本，也是最简单的

在实际项目中使用会比较少

因为对资源的管理有要求

再独立模式的时候，没有单作业的，因为必须要外部平台

应用模式 -> 可以 但是使用少

首先把要运行的jar包放在flink的lib文件夹下

然后执行 `standalone-job.sh start --job-classname flinklearn.frist`因为flink会默认扫描lib包下的所有的jar包所以这里指定入口就好

然后 执行 `taskmanager.sh start`

停掉集群：

```
standlone-job.sh stop

taskmanager.sh stop
```

## yarn模式

客户端先把flink的一个应用提交到yarn上

yarn他的resourcemanager会向nodemanager申请容器 ?

在这些容器上flink会部署他的作业flink会根据作业所要的sloat的数量进行动态分配taskmanager的资源

hadoop至少是2.2及其以上

flink在1.8之前hadoop的版本和正常的版本是分开的，就是人家给了你两套

但是1.8-1.11我们要下载的仅仅只是hadoop的插件

但是1.11之后就更不用下载hadoop的插件了，我们主要就进行环境变量的配置就好了

要配置

```
export HADOOP_HOME=/home/hadoop/app/hadoop
export HADOOP_CONF_DIR=${HADOOP_HOME}/etc/hadoop
export HADOOP_CLASSPATH=`hadoop classpath`
export PATH=${HADOOP_HOME}/bin:${HADOOP_HOME}/sbin:$PATH

```

就好

然后要创建一个Yarnsession

在flink的主节点下用 `yarn-session.sh -nm name`就能关联上yarn

如下

![](https://pic.imgdb.cn/item/63dde0144757feff33a46f1b.jpg)

但是仅仅这样启动的集群他的web界面查看后发现插槽是0，如下

![](https://pic.imgdb.cn/item/63dde0a24757feff33a54533.jpg)

这是因为我们启动的是yarn的模式的应用模式

当我们关掉它的时候yarnsession就会关掉了，我们可以加如下参数对它进行控制

-d ： 分离模式 ，前台关掉，后面不会把yarnsession关掉

-jm ： 配置jobmanager索要的内存 默认单位 MB

-nm : 配置名字

-qu :  指定yarn的队列名字

-tm:  配置每个taskmanager的内存

注意：flink 从1.11之后就不再使用 -s和-n 指定插槽数量以及taskmanager的数量了，yarn会动态的进行分配的

然后用户还是可以通过web和命令行两种进行提交作业和上述standlone的时候是一样的

其实上述就是很简单的会话模式

### 单作业

在yarn模式的时候由于有了外部资源管理平台，就可以进行单作业模式了

执行 `flink run -d -t yarn-per-job -c flinklearn.frist jar包的绝对路径`

-d : 就是分离模式

-t ：是指定yarn模式的模式 `yarn-per-job` 就是单作业

-c ： 是class入口

后面还可以接参数等等

早期还有一种把 -t  pre-yarn-job 用 -m yarn-cluster 代替的写法

### 应用模式

和单作业模式很像，就是运行的参数不同

`flink run-application -t yarn-application -c ....`

查看作业

`flink list -t yarn-application -Dyarn.application.id = ....`

取消作业

`flink cancel -t yarn-application -Dyarn.application.id = ....`

还可以通过yarn.provided.lib.dirs配置选项指定位置 ，把jar上传到远程

```
flink run-application -t yarn-application -Dyarn.provided.lib.dirs="hdfs://bigdata3:9000/tmp/flinktmp" hdfs://bigdata3:9000/tmp/flinktmp
```

上传到hdfs上运行

## flink运行时的架构

### flink系统架构

作业管理器（jobmanager）

是flink集群中的任务管理中心以及调度中心

最核心的组件，负责单独处理job

在作业提交的时候jobmaster会先接受到要执行的应用，一般是客户端提交的，包括：jar，数据流图，作业图

jobmaster会把jobGraph转换成一个物理层面的数据流图，这个图被叫做执行图（ExecutionGraph），它包含了所有可以并发的任务，jobMaster会向资源管理器（ResourceManager）发送请求，申请执行任务必要的资源，一旦它获取了足够的资源，就会将执行图分别发到他们真正运行的TaskManager上

在运行过程中jobmaster会负责监控指标以及调度，比如说检查点的协调

资源管理器（resourcemanager）

在一个flink集群里只有一个，负责分配资源，所谓资源其实主要是taskmanager的任务槽（slot），任务槽就是flink集群中的资源调度单位，包含机器用来计算的我cpu和内存资源，每一个任务都要分配到一个solt上，主要是内存分开

分发器（Dispatcher）

他主要是负责提供一个rest接口，用来提交应用的，并且为每一个新提交的作业启动一个新的jobMaster组件，Diapatcher也会启动一个web UI 用来方便和展示监控作业的信息，Diapatcher在架构中并不是必须的在不同的模式种可能会被忽略

任务管理器（taskmanager）

flink种的worker

每一个taskmanager包含了一定的solt

插槽的数量限制了并行度 ： 设置并行度的优先级 代码最高 其次是命令 其次是配置文件

启动之后taskmanager 会将一个或者多个插槽提供给jobmaster调用，jobmaster就可以向插槽分配任务来执行

执行过程中，一个taskManager可以和其他的与运行同一job的taskmanager来交互数据

一些执行流程图如下：
![](https://pic.imgdb.cn/item/63ddf0284757feff33bd9e11.jpg)

![](https://pic.imgdb.cn/item/63ddf0414757feff33bdc9a6.jpg)

![](https://pic.imgdb.cn/item/63ddf0564757feff33bdead7.jpg)

![](https://pic.imgdb.cn/item/63ddf06d4757feff33be0cab.jpg)

![](https://pic.imgdb.cn/item/63ddf0944757feff33be4b31.jpg)

## flink的细节

### 程序和数据流：

所有的flink程序都是要由三部分组成的 source transform sink

在运行flink项目的时候flink的程序会被映射成逻辑数据流（dataflow），它包含了三个部分 ，每一个dataflow都以一个或者多个source开始，以一个或者多个sink结束，其类似有向无环图（DAG）

大部分情况，程序中的转换操作（transform）和dataflow的算子（operation）是一一对应的关系

### 并行度

每一个算子可以包含多个或者一个子任务 ，这些子任务在不同的线程，不同的物理机，不同的容器中是完全独立的

一个特定的算子的子任务的个数就被称为并行度

任务并行：就是相当于多个线程
数据并行：同一个算子可以茶城多分町是处理多份数据

例子：suorce的时候如何设置多并行?

它是把数据源进行复制，如何让每一个线程去处理不同数据最后再合到一起

### 数据传输形式

一个程序之间不同的算子可能有不同的并行度

算子之间的传输数据的形式可以是one-to-one也可以是redistributing的模式具体是什么取决于算子的种类

one-to-one:streaming维护着分区的顺序以及元素的顺序（比如source以及map之间）这意味着元素的个数顺序相同，map,filiter,flatMap,等算子，都是one-to-one的

Redistributing:指分区数量可能会发生改变，每一个算子，的子任务依据所选择的transform发送数据到不同的目标任务

例如：keyBy基于hashcode重新分区，而broadcast和rebalance会随即重新分区，这些算子都是引起redistributing的而这个过程就相当于spar中的shuffle

于是就诞生了算子链

flink使用一种称为任务链的优化技术，减少通信的开销，为了满足任务链的需求，将两个或者多个算子设为相同的并行度，通过本地转发（local forward）的放式进行链接

相同并行度的one-to-one操作，flink放在一起，链接形成一个task，并行度相同，并且是one-to-one操作，两个条件缺一不可

### 执行图

flink中的执行图可以分为StreamingGraph -> jobGraph -> ExcutionGraph -> 物理执行图

* StreamingGraph：是根据用户的api自动生成的最初的图用来表明程序的拓扑结构
* jobGraph：上面一个经过优化，提交给jobmanager的数据结构，将多个符合条件的节点chain到一起作为一个节点
* ExcutionGraph ： jobmanager 根据jobGraph生成的并行化版本，是调度曾的核心的数据结构
* 物理执行图：在各个taskmanager上的，就是告诉他们怎么做的，是部署到taskmanager上的，不是一个数据结构

如下：

![](https://pic.imgdb.cn/item/63ddfdf24757feff33d5175f.jpg)

![](https://pic.imgdb.cn/item/63ddfe204757feff33d56469.jpg)

![](https://pic.imgdb.cn/item/63ddfe3a4757feff33d59272.jpg)

### 任务和任务槽

flink中每一个taskmanager就相当于是一个进程，他会在独立的线程上执行一个或者多个子任务

为了控制taskmanager能接收多少个task，Taskmanager通过task solt来进行控制 ，（一个taskmanager最少有一个slot）

slot最主要的作用就是隔离内存，因为cpu是没有办法真正隔离开的

flink里默认是允许子任务进行共享slot的，简单来说就是一个slot可以作为我们保存作业的整个管道

当我们将资源密集型和资源非密集型的任务放到一个slot中，他们就可以自行分配对资源占用的比例，从而保证最重的活平均分配给所有的taskmanager

slot和并行度

solt：静态概念：是指taskmanager具有的并发的执行的能力

通过参数taskmanager.numberOfTaskSlot进行配置

并行度：动态概念，就是真正所用到的并发能力

通过参数：parallelism.default进行设置

简单来说就是我可以拿起多沉的东西，但是我不用那么大的力气

### flink控制任务调度（代码）

可以禁用算子链

通过 `xxx.disableChaining()`

可以实现一个slot单独给一个算子用，同时也不能把他纳入任何一条算子链

还可以用 `xxx.startNewChain()`

可以实现从xxx开始一个新的算子链，不管前面如何都要分开

还可以设置slot共享组

就是在一个共享组里的slot才可以共享slot

不在一个共享组里的slot他们必须分开

通过 `xxx.slotSharingGroup(String)`实现 代表后面的算子默认情况下就是在String所在的共享组

# DataStreamAPI

对于以后的apiDatasetapi即将被弃用

所以我们用datasetapi

可以把DS堪称一种比较特殊的java集合类型

比如一个socket文本流底层就是DataStream

如果想调用DS的api要进行先创建环境

## 创建环境

### getExecutionEnvironment

它是相当于把下面两种放在一起了，自动判断

```
  val pienvironment =org.apache.flink.api.scala.ExecutionEnvironment.getExecutionEnvironment
  val streamingenv= org.apache.flink.streaming.api.scala.StreamExecutionEnvironment.getExecutionEnvironment
```

上述的getExecutionEnvironment方法是很智能的，它会自动识别我们是在本地调试还是在集群中调试，它会自动进行转换

### createLocalEnvironment

是创建一个本地的环境，在调用的时候可以传入一个参数指定默认的并行度，如果不传入默认就是当前电脑的cpu核心数量

```
  private val environment: StreamExecutionEnvironment = org.apache.flink.streaming.api.scala.StreamExecutionEnvironment.createLocalEnvironment()

```

### createRemoteEnvironment

调用远程的执行环境

```
  private val environment: StreamExecutionEnvironment = org.apache.flink.streaming.api.scala.StreamExecutionEnvironment.createRemoteEnvironment("bigdata5",8081,1,"jar包的路径")

```

它底层是这样定义的

```
def createRemoteEnvironment(
      host: String,
      port: Int,
      parallelism: Int,
      jarFiles: String*): StreamExecutionEnvironment = {

    val javaEnv = JavaEnv.createRemoteEnvironment(host, port, jarFiles: _*)
    javaEnv.setParallelism(parallelism)
    new StreamExecutionEnvironment(javaEnv)
  }
```

## 执行模式

经过上面获取的环境，我们就可以开始对其设置执行模式

在早期的代码中它把批处理和流处理分开了

通过代码

```
  val pienvironment =org.apache.flink.api.scala.ExecutionEnvironment.getExecutionEnvironment
  val streamingenv= org.apache.flink.streaming.api.scala.StreamExecutionEnvironment.getExecutionEnvironment
```

这样的方式

上面一个是批处理的

下面一个是流处理的

他们的api是基本相同的，但是包不同

但是现在的做法是直接用下面的那个

对于批处理而言：我们只要在提交的时候通过命令

`flink run -Dexecution.runtime-mode=BATCH 。。。。`

就可以证明他是批处理的

如果不处理上述的参数默认是STREAMING ：就是流处理的格式

或者在代码的时候直接通过

```
  val streamingenv= org.apache.flink.streaming.api.scala.StreamExecutionEnvironment.getExecutionEnvironment
   streamingenv.setRuntimeMode(RuntimeExecutionMode.AUTOMATIC)
  streamingenv.setRuntimeMode(RuntimeExecutionMode.BATCH)
  streamingenv.setRuntimeMode(RuntimeExecutionMode.STREAMING)
```

里面传入相应的参数即可

但是一般不推荐这样做，因为这相当于固定死了，直接当命令行参数传递更好一点

在flink中批处理数据被划分到有界流中了，为什么还要批处理模式？

因为性能问题，流处理是来一条数据我处理一个数据，然后发送一条，批处理是来一堆数据我处理，如何再一起发送

对于批处理数据，它来的时候就是一堆来的，然后流处理的时候要一条一条发送，发送的次数多了，而对于批处理，我只用处理，然后一次发过去，就好了

这就是批处理还在flink中的原因

我们的flink代码是懒执行的，和懒加载是一个道理的，只有通过excute才开张真正的执行

## source

源算子：就是读取数据源的算子

### 有界数据

读取有界数据的简单的测试方法

```
 val streamingenv= org.apache.flink.streaming.api.scala.StreamExecutionEnvironment.getExecutionEnvironment

 case class event(uaer:String,url:String,timestamp:Long)

streamingenv.setParallelism(1)
    // 从元素中读取数据
    streamingenv.fromElements(1,2,3,4,5,65,67,7,7).print("from elem")
    streamingenv.fromElements(
      event("zihan","1211",1111),
      event("bob","1333",22222)
    ).print("from case class")

    // 这个可以从迭代器中读取数据，具体可以ctrl + p 查看
    val events = List(event("zihan", "1211", 1111), event("bob", "1333", 22222))
    streamingenv.fromCollection(events).print("from list")

    // 读取文本文件
    streamingenv.readTextFile("F:\\bigdatajava\\src\\main\\resources\\wc.data").print("from text")

```

输出结果为

```
from elem> 1
from elem> 2
from elem> 3
from elem> 4
from elem> 5
from elem> 65
from elem> 67
from elem> 7
from elem> 7
from case class> event(zihan,1211,1111)
from list> event(zihan,1211,1111)
from case class> event(bob,1333,22222)
from list> event(bob,1333,22222)
feom text> spark,linux，spark,spark
feom text> hadoop
feom text> linux,hive
feom text> flume,flink
feom text> gg,dd
feom text> ttm,ff
feom text> "zihan","1211",1111
feom text> "bob","1333",22222
[WARN ][2023-02-04 16:15:57][org.apache.flink.streaming.api.functions.source.ContinuousFileReaderOperator$ReaderState$6.prepareToProcessRecord(ContinuousFileReaderOperator.java:178)]not processing any records while closed

Process finished with exit code 0

```

我们还可以把一些数据写进文本文件中然后进行读取

### 无界数据

我们一般是从kafka来接受数据的

我们先要引入链接kafka的依赖

如下：

```
    <dependency>
      <groupId>org.apache.flink</groupId>
      <artifactId>flink-connector-kafka_2.12</artifactId>
      <version>1.13.6</version>
    </dependency>
```

值得注意的是这个是官方的，他会自动根据kafka的版本进行更新，目前支持kafka0.10.0版本及以上的

有特殊需要就去找特殊的版本的

而且对于1.14版本之后的时候对我们要引入的方法有了更改从FlinkKafkaConsumer变成KafkaSource

代码如下

```
 
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer
streamingenv.setParallelism(1)

    // 链接kafka
    val properties = new Properties()
    properties.put("bootstrap.servers", "bigdata3:9092,bigdata4:9092,bigdata5:9092 ")

    // 注意使用下面的那个方法的时候不用在此设置下面的参数，因为这个FlinkKafkaConsumer[T]里面已经封装好了，而且默认采用的就是精准一次
//    properties.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer")
//    properties.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer")
//    properties.put("acks", "all")
    /*
    传入参数说明FlinkKafkaConsumer[T]
    topic , 反序列化器 ， kafka配置参数
    上面的T是代表把获得的数据当作什么类型
     */

    streamingenv.addSource(new FlinkKafkaConsumer[String]("dl2262",new SimpleStringSchema(),properties)).print("kafka")

```

### 读取自定义数据源

如下

```
    streamingenv.setParallelism(1)

    /*
     自己定义外部数据源
     实现SourceFunction接口
     重写两个方法run()和cancel()
     run()获取数据的方法
     cance()控制停止的方法
     */

    import flinklearn.clickSource

    val stream = streamingenv.addSource(new clickSource)

    stream.print("makebyself")
```

source方法

```
package flinklearn

import java.util.Calendar

import org.apache.flink.streaming.api.functions.source.SourceFunction

import scala.util.Random

object clickSource {

  def apply(): clickSource = new clickSource()

  def main(args: Array[String]): Unit = {

  }
}

/*
SourceFunction[T]
其中的泛型就是我们对应的返回的数据的类型
 */


class clickSource extends SourceFunction[event]{

  // 标志位
  var flag = true


  def excute(): Unit ={

  }


  override def run(sourceContext: SourceFunction.SourceContext[event]): Unit = {
    // 随机数生成器
    val random =new  Random()

    // 定义选择的范围
    val user = Array("1","2","3")
    val url = Array("/cat","/.dog","/info")

    //使用循环不停的发送数据，标志位做为判断题条件，不停的发送数据
    while (flag){
      val eventtmp = event(user(random.nextInt(2)),url(random.nextInt(2)),Calendar.getInstance().getTimeInMillis)
      // 调用上下文sourceContext的方法向下游发送数据
      sourceContext.collect(eventtmp)
      // 每隔1s发送一条数据
      Thread.sleep(1000)
    }

  }

  override def cancel(): Unit = {
    flag = false
  }

}
```

但是对于SourceFunction它本身就是个并行度只能为1的接口

和socket文本流一样

如果想设置多并行度的就要用ParallelSourceFunction这个接口，其使用和上面一样

## flink支持的类型

flink里DS的数据类型都是由他的泛型进行控制的

```
    val stream:DataStream[event] = streamingenv.addSource(new clickSource)

```

基本上scala和java里所有的他都支持，但只是基本上，因为flink是分布式的，它再每个节点之间交付数据的时候是要经网络传输的，序列化和反序列化，所以对于一些的数据类型就无法支持

他的底层类型都是封装在TypeInformation和types中的，可以点进去查看

泛型的时候不是由flink进行序列化的，他是由Kyro进行的所以就可能出现问题，要尽可能避免

## 算子

### 转换算子

* map
* filter
* FlatMap
* KeyBy:根据key进行聚合里面可以传入字符串，或者数字，或者和map里一样传入一个function
* 简单聚合方法 -> sum , min ,max 等
* reduce：就是和spark里的reducebykey一样

调用的时候都是得到DS进行调用

使用如下:

```
    val value: DataStream[String] = streamingenv.readTextFile("F:\\bigdatajava\\src\\main\\resources\\wc.data")
    value.flatMap(_.split(",")).map((_,1)).keyBy(_._1).reduce((x,y)=>{
      (x._1,x._2+y._2)
    }).print()
-------------------------------------------数据
spark,linux,spark,spark
hadoop
linux,hive
flume,flink
gg,dd
ttm,ff
"zihan","1211",1111
"bob","1333",22222
```

### 函数类（udf）

为什么他们里面可以放function

查看底层源码可以看见

```
@Public
public interface Function extends java.io.Serializable {}
```

他们继承于这个接口，并实现了各自的方法，所以就可以传入Function

进而导出udf是如何实现的

对于flink里的udf我们可以让它继承不同的function，然后再放进去

测试自定义udf的做法

```
package flinklearn
import org.apache.flink.api.common.functions.FilterFunction
import tool._
import org.apache.flink.streaming.api.scala._
object udf {

  def apply(): udf = new udf()

  def main(args: Array[String]): Unit = {
    udf().udftest
  }
}

class udf{

  private val streamingcontext = new streamingcontext

  def udftest = {
    val environment = streamingcontext.getflinkenv()

    val testdata = List(
      event("zihan", "1211", 1111),
      event("bob", "1333", 22222)
    )

    val testDS = environment.fromCollection(testdata)

    // 筛选特定数据
    testDS.filter( new myfiliterfunction() ).print()
  
    testDS.filter( new FilterFunction[event] {
      override def filter(value: event): Boolean = {
        value.uaer.contains("zihan")
      }
    }).print()

    environment.execute()
  }
}

// 实现自定义的function
class myfiliterfunction() extends FilterFunction[event]{
  def filter(value: event): Boolean = {
    value.uaer.contains("zi")
  }

}
```

注意，这里不要引用错包，如果引用错包，就会报错，因为scala和java的api名字是一样的

### 富函数（udf）

因为我们上述所说的udf是针对一条数据进行操作的

但是假如我们想对一批数据进行操作，也就是数据来之前对其进行操作怎么办？

我们要通过更加复杂的用户自定义类，是函数类的扩展版本

最大的不同就是富函数类，可以获取运行环境的上下文，以及有生命周期等

富函数类的继承接口是Rich...Fnction

它里面有两个方法：

* open ： 相当于算子初始化的时候 和spring 里的初始化一样
* close ： 结束的时候 和spring里的销毁是一样的

如下：

```
package flinklearn
import org.apache.flink.api.common.functions.{FilterFunction, RichMapFunction}
import org.apache.flink.configuration.Configuration
import tool._
import org.apache.flink.streaming.api.scala._
object udf {

  def apply(): udf = new udf()

  def main(args: Array[String]): Unit = {
    udf().udftest
  }
}

class udf{

  private val streamingcontext = new streamingcontext

  def udftest = {
    val environment = streamingcontext.getflinkenv()

    val testdata = List(
      event("zihan", "1211", 1111),
      event("bob", "1333", 22222)
    )

    val testDS = environment.fromCollection(testdata)

    // 定义富函数
    testDS.map( new myRichmap).print("2")

    val result =
      """
        |索引号0
        |编号为4a4f30b513560b972fd0e372460b71c4
        |2> 1211
        |2> 1333
        |这个是结束方法0
        |""".stripMargin
    environment.execute()
  }
}


// 实现富函数
class myRichmap extends RichMapFunction[event,String]{
  override def map(value: event): String = {
    value.url
  }

  // 在所有数据到来之前进行处理
  override def open(parameters: Configuration): Unit = {
    println("索引号" + getRuntimeContext.getIndexOfThisSubtask)
    println("编号为" + getRuntimeContext.getJobId)
  }

  // closa
  override def close(): Unit = {
    println("这个是结束方法" + getRuntimeContext.getIndexOfThisSubtask)
  }


}

```

注意，当多个并行度进行的时候，每一个并行调用map的时候都会进行初始化，以及销毁

## 分区函数

简单来说就是数据的重新分区的操作

简单介绍一下：keyby

keyby：是把每个key根据hash值然后取模运算的方法进行分区也就造成了，每一个相同的key一定可以在同一分区，不同的不一定不在同一分区

接下来我们要学习的算子，是可以真正控制分区的

如果用上面keyby有可能会造成数据倾斜，也就是我们现在的操作就是控制数据倾斜的

物理分区，一般在并行度减少的时候会自动进行

### 随机分区（shuffle）

使用方法很简单直接DS.shuffle就可以了

### 轮询分区（Round-Robin）

对比上面的shuffle是洗牌，则他就是发牌，和打扑克一样的那种，和kafka以及nginx是一样的

调用方式DS.rebalance()，其实Ds里上游到下游默认的就是轮询

### 重缩放分区（rescale）

它和上面的轮询很像

轮询是把每一个并行子任务的数据都进行轮询，就是如果上游是两个任务，下游是三个任务

轮询会让第一个子任务的第一个数据 给下游的第一个，第一个第二个给下游的第二个，第一个的第三个给下游的第三个

上游的第二个子任务同理

但是这个并不是，它是做了个分组，旨在当前的组内进行轮询

就是相当于玩游戏局大了，要分开玩一样

每一个上游任务都会对应下游的一个组，然后再组里进行轮询，不能发牌给其他组

其本质上也就是按照taskmanager进行分组，每个taskmanager之间如果项进行通信则要经过网络传输代价比较大，

然后轮询其实就是再一个taskmanager（上游）和另外一个taskmanager（下游）之间进行通信，所以轮询的数据通道要建立M（上游数量）* N (下游数量)个通信

而现在的则不是，因为他是按照taskmanager进行分开的，所以它理论上是按照它组内的来进行的1上游数量）* N (下游数量)来通信，但是这里的n的数量都比上述小得多

但是要注意如果想优化性能要让上游子任务和下游子任务的数量是倍数的关系最好

使用的时候直接DS.rescale就好

可以用自定义数据源进行测试如下：

```
package flinklearn
import org.apache.flink.api.common.functions.{FilterFunction, RichMapFunction}
import org.apache.flink.configuration.Configuration
import org.apache.flink.streaming.api.functions.source.{RichParallelSourceFunction, SourceFunction}
import tool._
import org.apache.flink.streaming.api.scala._
object udf {

  def apply(): udf = new udf()

  def main(args: Array[String]): Unit = {
    udf().udftest
  }
}

class udf{

  private val streamingcontext = new streamingcontext

  def udftest = {
    val environment = streamingcontext.getflinkenv(3)

    val testdata = List(
      event("zihan", "1211", 1111),
      event("bob", "1333", 22222)
    )
    val testDS = environment.addSource(new trysource).setParallelism(3)
    testDS.rescale.print("rescale")
    environment.execute()
    val result =
      """
        |rescale:1> 2
        |rescale:2> 1
        |rescale:2> 3
        |rescale:1> 4
        |rescale:2> 5
        |rescale:1> 6
        |rescale:2> 7
        |rescale:1> 8
        |""".stripMargin
  
  }
}



class trysource extends RichParallelSourceFunction[Int]{
  override def run(ctx: SourceFunction.SourceContext[Int]): Unit = {
    for (i <- 0 to 7){
      if (getRuntimeContext.getIndexOfThisSubtask == (i+1)%2){
        ctx.collect(i+1)
      }
    }
  }

  override def cancel(): Unit = ???
}


```

通过结果我们可以知道1，3，5，7对应的子任务的id都是2 ，则2，4，6，8是1

满足我们设置的条件

### 广播分区（broadcast）

把一份数据复制成多个然后发送到下游所有子任务

但是一般会造成数据重复，但还是有作用的在用广播创建广播流的时候用

### 自定义分区

接口叫做partitionCustom

源码如下：

```
  /**
   * Partitions a DataStream on the key returned by the selector, using a custom partitioner.
   * This method takes the key selector to get the key to partition on, and a partitioner that
   * accepts the key type.
   *
   * Note: This method works only on single field keys, i.e. the selector cannot return tuples
   * of fields.
   */
  def partitionCustom[K: TypeInformation](partitioner: Partitioner[K], fun: T => K)
      : DataStream[T] = {
  
    val keyType = implicitly[TypeInformation[K]]
    val cleanFun = clean(fun)
  
    val keyExtractor = new KeySelector[T, K] with ResultTypeQueryable[K] {
      def getKey(in: T) = cleanFun(in)
      override def getProducedType(): TypeInformation[K] = keyType
    }

    asScalaStream(stream.partitionCustom(partitioner, keyExtractor))
  }
```

Partitioner是分区器，后面的lambda表达式是提取当前分区字段的方法

点进去查看发现

```
public interface Partitioner<K> extends java.io.Serializable, Function {

    /**
     * Computes the partition for the given key.
     *
     * @param key The key.
     * @param numPartitions The number of partitions to partition into.
     * @return The partition index.
     */
    int partition(K key, int numPartitions);
}

```

它也是一个接口，他的返回值是要返回到下游子任务的编号，也就是分区的编号

如下：

```
package flinklearn
import org.apache.flink.api.common.functions.{FilterFunction, Partitioner, RichMapFunction}
import org.apache.flink.configuration.Configuration
import org.apache.flink.streaming.api.functions.source.{RichParallelSourceFunction, SourceFunction}
import tool._
import org.apache.flink.streaming.api.scala._
object udf {

  def apply(): udf = new udf()

  def main(args: Array[String]): Unit = {
    udf().udftest
  }
}

class udf{

  private val streamingcontext = new streamingcontext

  def udftest = {
    val environment = streamingcontext.getflinkenv(3)

    val testDS = environment.fromElements(1,1,2,3,4,5,6,67,7,8,8,5,6,4,3)
    testDS.partitionCustom( new Partitioner[Int]{
      override def partition(key: Int, numPartitions: Int): Int = {
        key % 2
      }
    }, x=>x ).print("rescale")
    environment.execute()
    val result =
      """
        |rescale:1> 2
        |rescale:1> 4
        |rescale:2> 1
        |rescale:1> 6
        |rescale:2> 1
        |rescale:1> 8
        |rescale:2> 3
        |rescale:1> 8
        |rescale:2> 5
        |rescale:1> 6
        |rescale:2> 67
        |rescale:1> 4
        |rescale:2> 7
        |rescale:2> 5
        |rescale:2> 3
        |
        |Process finished with exit code 0
        |
        |""".stripMargin

  }
}





```

但是对于case class 可能不好使，我用就是不好用

## 输出算子

可以调用addSink就可以自己定义一个sink

里面最关键的构造方法是一个invoke具体在源码里

当然SinkFunction一般我们不用用，因为官方给我们提供了好多

接下来我们按照官网进行学习

### JDBC

先在idea里添加依赖

```
   <dependency>
      <groupId>org.apache.flink</groupId>
      <artifactId>flink-connector-jdbc</artifactId>
      <version>1.16.0</version>
    </dependency>

```

已创建的 JDBC Sink 能够保证至少一次的语义。 更有效的精确执行一次可以通过 upsert 语句或幂等更新实现。

```
    val value1: DataStreamSink[Yarninfo] = value.addSink(
      JdbcSink.sink(
        "insert into yarninfo(id,host,applicationtype,name,startime,endtime,user,memeveryscends,vcoreeveryscends,size,cores,state,url) values(?,?,?,?,?,?,?,?,?,?,?,?,?)",
        new JdbcStatementBuilder[Yarninfo] {
          override def accept(t: PreparedStatement, u: Yarninfo): Unit = {
            t.setString(1, u.id)
            t.setString(2, u.host)
            t.setString(3, u.applicationtype)
            t.setString(4, u.name)
            t.setString(5, u.startime)
            t.setString(6, u.endtime)
            t.setString(7, u.user)
            t.setString(8, u.memeveryscends)
            t.setString(9, u.vcoreeveryscends)
            t.setString(10, u.size)
            t.setString(11, u.cores)
            t.setString(12, u.state)
            t.setString(13, u.url)
          }
        },
        new JdbcConnectionOptions.JdbcConnectionOptionsBuilder()
          .withUrl("jdbc:mysql://bigdata2:3306/bigdata")
          .withDriverName("com.mysql.jdbc.Driver")
          .withUsername("root")
          .withPassword("liuzihan010616")
          .build()
      )
    )
```

如果要实现幂等性等要自己家进行操作

### 文件

flink写入到文件中

如下：

```
    testDS.map(_.toString).addSink(StreamingFileSink.
      forRowFormat(new Path("./output"),
       new SimpleStringEncoder[String]("UTF-8"))
      .build())
```

分区数量等于生成的文件数量

![](https://pic.imgdb.cn/item/63df221a4757feff33a88620.jpg)

还可以在.bulid之前用with来设置一些写入的参数

* withBucketCheckInterval()：设置多长时间进行滚动一次
* 等，具体自己看下就ok

写入到hdfs上的时候也直接改一下path就好

### kafka

如下：

```
    testDS.map(_.toString).addSink(
      new FlinkKafkaProducer[String]
      ("bigdata3:9092,bigdata4:9092,bigdata5:9092","dl2262",new SimpleStringSchema())
    )
```

就可以往kafka里写入了

### 自定义外部连接器

就是通过继承SinkFunction，以及对应的RichSinkfunction

实现invoke方法，放入自己写入的方法

## 时间语义

对于无界流，我们要查看它一定时间内的数据

对于分布式系统，我们没有一个绝对的时间指标

窗口进行数据的收集是以什么为标准的？

### 处理时间

就是我们对数据进行处理的时候的时间

### 事件事件

就是这个数据什么时候产生的

### 水位线

用来度量事件时间的度量

当我们使用事件事件的时候，假如我们要采集8点到9点的数据

那么当我们用事件事件，就是在数据生成的时候打上标记，进行统计他的事件的话，

假如下游还有对时间进行操作的事情，则只能去提取事件时间的时间戳，进行计算，

这样下游的操作就会延迟数据的输出时间，导致输出的数据是一段一段的

于是就把时间戳提出，当作一个变量，当对这个数据进行处理的时候，在时间戳上打个标记

并包装成一个特殊形式，直接插入数据流，跟随着数据一起流动，然后如果看见这个标志就会放到下游

就是在对每一条数据进行处理之后，我们会在这个数据之后加一个类似标记的东西，而这个东西是和数据时间有关系的，作用就是告诉下游我当前处理的数据是这个时间的

**有序流中的水位线**：

就是按照时间顺序进行插入时间戳，保证了数据的顺序

但是如果事件生成的特别快时间特别密，则水位线打上的时间会有所相同，然后因为数据量特别大，则打上所需要的时间和资源会特别多，于是我们从上面的转变成，每间隔一段时间插入一条水位线，每间隔一段时间插入一段水位线，然后这个插入的标准就是它之前最近一次提取到的时间戳，插入的时间周期默认是200ms（可以设置）ps：这插入的周期，是按照系统时间200ms之后就生成一次的

但是假设：

上游是三个分区。下游是一个分区，那么则可能出现乱序，

就是假如第一个分区正常处理时间数据。而对于第二个分区则是有问题或者延迟什么的，它发送了一个在之前时间的数据，就会发生乱序

第一个分区发送的数据如下：1，2，3，4数据全到下面的分区了

第二个分区又发送了个2的数据，就会出现数据集乱序的问题

**解决方法**：

设置一个标志位，保存之前最大的时间戳，然后用这个标志位进行推进时间并对比数据的时间戳，然后如过来的数据特别多可以采用和上面一样的方法进行周期执行的判断最大时间戳

但是上述的方法会出现问题，假如按照上述规则处理窗口，则可能会出问题，假如我们定义一个0-9s的一个窗口，按照这个方法，可能会出现迟到的数据，然后就会丢数据

**解决方法**：

设置延迟函数，就是让他延迟2s，就是真实数据的时间2s的话，则让水位线的时间是0s，这样就可以减少数据丢失的时间了，因为窗口是按照水位线的时间来的，但是上述的方法也不严谨，最终解决方法就是等足够长的时间

就是我们判断一个数据流中的最大乱序从程度，进行设置时间，假如22s后面跟着一个17s的数据，则说他的最大乱序程度是22-17=5s如果还有比这个大的，则就更新这个时间，同时这个时间也是要延迟多少秒的时间

水位线特性：

* 水位线是一个插入到数据流中的一个标记，可以认为是一个特殊的数据
* 水位线的主要内容就是一个时间戳，用来表示当前事件时间的进展的
* 水位线是基于数据的时间戳进行生成的
* 水位线的时间戳必须是单调递增的，以确保时间的推进
* 水位线可以通过设置延迟来进行处理迟到的数据

然后就不会出现小于等于t的时间数据了

### 但是如何确认最大乱序时间？

一般这个最大乱序时间，是按照一个正态分布的，最易最终我们就是在正确性和延时时间做一个权衡

在idea代码如下：

水位线的基本使用：

```
package flinklearn

import java.time.Duration

import org.apache.flink.api.common.eventtime.{SerializableTimestampAssigner, Watermark, WatermarkGenerator, WatermarkGeneratorSupplier, WatermarkOutput, WatermarkStrategy}
import org.apache.flink.api.java.utils.ParameterTool

object f3 {
  def apply(parameterTool: ParameterTool): f3 = new f3(parameterTool)

  def main(args: Array[String]): Unit = {
    val tool = ParameterTool.fromArgs(args)
    f3(tool).excute()
  }
}




class f3(parameterTool: ParameterTool) {

  import org.apache.flink.streaming.api.scala._

  def excute()={
    val env = StreamExecutionEnvironment.getExecutionEnvironment
    env.setParallelism(1)
    // 设置水位线的默认事件默认是毫秒
    env.getConfig.setAutoWatermarkInterval(500)

    val value = env.addSource(new clickSource)

    // 有序流的水位线生成策略
    value.assignTimestampsAndWatermarks( WatermarkStrategy.forMonotonousTimestamps().withTimestampAssigner(new SerializableTimestampAssigner[event] {
      override def extractTimestamp(element: event, recordTimestamp: Long): Long = {
        element.timestamp
      }
    }))


    // 乱序流的水位线生成方法
    // 这里的Duration 是java.time下的
    value.assignTimestampsAndWatermarks( WatermarkStrategy.forBoundedOutOfOrderness[event](Duration.ofSeconds(5)).withTimestampAssigner(new SerializableTimestampAssigner[event] {
      override def extractTimestamp(element: event, recordTimestamp: Long): Long = {
        element.timestamp
      }
    }))

    // 自定义水位线
    value.assignTimestampsAndWatermarks(new WatermarkStrategy[event] {
      override def createWatermarkGenerator(context: WatermarkGeneratorSupplier.Context): WatermarkGenerator[event] = {
        new WatermarkGenerator[event] {
          // 底层默认要实现的两个方法 但是flink内置了几种基本的策略，在WatermarkStrategy源码中
          // 事件触发
          val delay = 5000L
          // 定义属性保存最大时间戳
          var maxtx = Long.MinValue + delay + 1

           // 判断最大时间戳
          // 按照系统时间做调度
          override def onEvent(event: event, eventTimestamp: Long, output: WatermarkOutput): Unit = {
            maxtx = Math.max(maxtx,event.timestamp)
          }

//          // 按照数据进行调度
//          override def onEvent(event: event, eventTimestamp: Long, output: WatermarkOutput): Unit = {
//            maxtx = Math.max(maxtx,event.timestamp)
//            val watermark = new Watermark[event](maxtx)
//            output.emitWatermark(watermark)
//          }


          // 周期行的生产水位线
          override def onPeriodicEmit(output: WatermarkOutput): Unit = {
            val watermark = new Watermark[event](maxtx -delay -1)
            // 周期性发射
            output.emitWatermark(watermark)
          }

        }
      }
    })

  }
}

```

但是我们还可以在数据源机械能配置，自定义source的时候可以直接定义水位线等参数如下

```
package flinklearn

import java.util.Calendar

import org.apache.flink.streaming.api.functions.source.{RichParallelSourceFunction, RichSourceFunction, SourceFunction}
import org.apache.flink.streaming.api.watermark.Watermark

import scala.util.Random

object clickSource {

  def apply(): clickSource = new clickSource()

  def main(args: Array[String]): Unit = {

  }
}

/*
SourceFunction[T]
其中的泛型就是我们对应的返回的数据的类型
 */


class clickSource extends RichParallelSourceFunction[event]{

  // 标志位
  var flag = true


  def excute(): Unit ={

  }


  override def run(sourceContext: SourceFunction.SourceContext[event]): Unit = {
    // 随机数生成器
    val random =new  Random()

    // 定义选择的范围
    val user = Array("1","2","3")
    val url = Array("/cat","/.dog","/info")




    //使用循环不停的发送数据，标志位做为判断题条件，不停的发送数据
    while (flag){
      val eventtmp = event(user(random.nextInt(2)),url(random.nextInt(2)),Calendar.getInstance().getTimeInMillis)
      // 为要发送的数据指定时间戳,按照下面指定完成之后发送数据的时候就会知道哪一个是时间戳，就可以不实现withTimestampAssigner了
      sourceContext.collectWithTimestamp(eventtmp,eventtmp.timestamp)
      // 往下游直接发送水位线,然后下游就可以不用assignTimestampsAndWatermarks这个方法了，因为水位线已经生成完了
      sourceContext.emitWatermark(new Watermark(eventtmp.timestamp))

      // 每隔1s发送一条数据
      sourceContext.collect(eventtmp)
      Thread.sleep(1000)
    }

  }

  override def cancel(): Unit = {
    flag = false
  }

}
```

就可以了

水位线的正常就是像数据一样正常的流动，这个是单分区的时候

如果想发送到多个下游的子任务，我们应该广播出去，

但是如果上游有多个分区，那么他们广播的水位线如果不一样，下游该采用哪一个水位线？

答案是**最小的数据**

我们会设置一个分区水位线的概念，就是采取最小的分区水位线

### 窗口

我们要观察，或者对一定时间内的数据进行操作，一般定义窗口的时候都是左闭右开，滑动窗口是可以出现重复的数据

但是对于时间时间语义下乱序的时候，就会有迟到的数据，然后我们就要设置延迟时间

但是，既然又迟到的数据，那么也就会有超前的数据在这个窗口中，于是我们不能简单的理解把窗口想象成简单的窗口

我们可以想象成桶的概念，就是简单的，如果这个时间戳是复合这个窗口规定的时间，则会被拉到一个桶中，

这样就不会出现时间不对的数据导致观察错误

**窗口的分类：**

* 时间窗口

  * 滚动窗口：就是头连着尾巴一样，一直看，生产很多都是基于滚动窗口的，就类似于把数据分成很多个框框，挨个看
  * 滑动窗口：基于上面滚动窗口，就像一个滑块一样的，从头滑到尾，也叫跳动窗口，滑动窗口的参数是滑动步长，就是每次滑动滑动的距离，如果把滑动步长跳到整个数据那么长，就会变成滚动窗口了
  * 会话窗口：他的标准并不是给窗口设置一个固定的大小，开始和结束的规律也是完全没有的，窗口之间一定没有重叠的，会复杂点
  * 全局窗口：就是全局的，默认是不会触发计算的因为数据不会停下，但是可以设置触发器，进行设置
* 计数窗口

  * 滚动窗口：同上
  * 滑动窗口：同上
  * 会话窗口：同上
  * 全局窗口：同上

时间窗口略微的复杂点，计数则更为简单

窗口api：可以堪称df的api的一小部分

首先，我们要确定我们做没做keyby

如果keyby了，则要通过调用.window进行开始，会在多个并行子任务上执行，针对每一个key进行执行

如果没做keyby，则是用调用.windowall(),相当于并行度都变成1

无论是上面的哪一个window/windowall

都要街上窗口分配器，然后加上聚合函数

除了全都要我们自定义的窗口分配器以外，flink都提供了内置的function

如下：

```
package flinklearn



import org.apache.flink.api.common.eventtime.{SerializableTimestampAssigner, WatermarkStrategy}
import org.apache.flink.api.java.utils.ParameterTool
import org.apache.flink.streaming.api.windowing.assigners.{EventTimeSessionWindows, ProcessingTimeSessionWindows, SlidingEventTimeWindows, SlidingProcessingTimeWindows, TumblingEventTimeWindows, TumblingProcessingTimeWindows}
import org.apache.flink.streaming.api.windowing.time.Time
import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction

object flinkWindos {
  def apply(parameterTool: ParameterTool): flinkWindos = new flinkWindos(parameterTool)

  def main(args: Array[String]): Unit = {
    val tool = ParameterTool.fromArgs(args)
    flinkWindos(tool).ecxcute()
  }
}


class flinkWindos(parameterTool: ParameterTool){

  import org.apache.flink.streaming.api.scala._

  def ecxcute()={
    val env = StreamExecutionEnvironment.getExecutionEnvironment
    val zihan = env.addSource(new clickSource)

    val zihan1 = zihan.assignTimestampsAndWatermarks(WatermarkStrategy.forMonotonousTimestamps().withTimestampAssigner(
      new SerializableTimestampAssigner[event] {
        override def extractTimestamp(element: event, recordTimestamp: Long): Long = {
          element.timestamp
        }
      }))

    zihan1.map(data => {(data.uaer,1)})
      .keyBy(_._1)
      .window(TumblingEventTimeWindows.of(Time.seconds(7)))// 基于事件时间的滚动窗口 , 偏移量为后面的参数
//      .window(TumblingProcessingTimeWindows.of(Time.days(1),Time.hours(-8))) // 基于处理时间的滚动窗口
//      .window(SlidingEventTimeWindows.of(Time.days(1),Time.minutes(10),Time.hours(-8))) // 基于时间时间的滑动窗口 步长为10min
//      .window(SlidingProcessingTimeWindows.of(Time.days(1),Time.minutes(10),Time.hours(-8))) // 基于处理时间的滑动窗口 步长为10min
//      .window(EventTimeSessionWindows.withGap(Time.seconds(10))) //  基于事件时间的会话窗口
//      .window(ProcessingTimeSessionWindows.withGap(Time.seconds(10))) // 基于处理时间的会话窗口
//      .countWindow(10) // 大小为10的滚动计数窗口
//      .countWindow(10,2) // 大小为10的滑动计数窗口，步长为2

    //  窗口函数
    // 分为增量窗口 和 全窗口
    // 增量聚合 是每来一条数据，就处理一条数据，然后存储他的状态，等窗口满足条件，直接输出
    // 全窗口，则是类似批处理的形式，把数据都聚集在一起，然后满足条件执行操作，在输出


    /*
    增量聚合函数包括（典型） ： ReduceFunction AggregateFunction
    规约聚合：reduceFunction -> 两两进行规约，就和之前简单函数的那个是一样的
    */
      // reduce 他在规约的过程中，中间是不能变的，就是数据的输入，输出，规则都一样
//      .reduce( (x,y)=> {
//        (x._1,x._2+y._2)
//      } )
//      .print()
    // aggre 则可以改变类型，比上面更为灵活
        .aggregate(new tryFunction)

    env.execute()

  }



}


class tryFunction extends org.apache.flink.api.common.functions.AggregateFunction[(String,Int),(Long,Set[String]),Double] {
  override def createAccumulator(): (Long, Set[String]) = {
    (0,Set[String]()) // 赋初值
  }

  // 计算过程
  override def add(value: (String, Int), accumulator: (Long, Set[String])): (Long, Set[String]) = {
    (value._2 + accumulator._1 , accumulator._2 + value._1)
  }

  // 结果
  override def getResult(accumulator: (Long, Set[String])): Double = {
    accumulator._1/accumulator._2.size
  }

  // 会话窗口要用的
  override def merge(a: (Long, Set[String]), b: (Long, Set[String])): (Long, Set[String]) = ???
}
```

全窗口函数：

就相当于针对于全局的窗口函数，而且它可以获取更多的信息

窗口函数现在处于一个迭代的过程中，所以可能会略微复杂些

首先本身上的窗口函数是通过.apply进行调用的里面的传入参数是WindowFunction，这个是最早的时候用的不过现在已经快被弃用了

因为出现了个比他更好的Function，是ProcessWindowFunction，因为这个方法不光可以获取上下文window信息，还可以获取很多其他的属性

WindowFunction：而且他是富函数

```
trait WindowFunction[IN, OUT, KEY, W <: Window] extends Function with Serializable {

  /**
    * Evaluates the window and outputs none or several elements.
    *
    * @param key    The key for which this window is evaluated.
    * @param window The window that is being evaluated.
    * @param input  The elements in the window being evaluated.
    * @param out    A collector for emitting elements.
    * @throws Exception The function may throw exceptions to fail the program and trigger recovery.
    */
  def apply(key: KEY, window: W, input: Iterable[IN], out: Collector[OUT])
}
```

ProcessWindowFunction

```
abstract class ProcessWindowFunction[IN, OUT, KEY, W <: Window]
    extends AbstractRichFunction {

  /**
    * Evaluates the window and outputs none or several elements.
    *
    * @param key      The key for which this window is evaluated.
    * @param context  The context in which the window is being evaluated.
    * @param elements The elements in the window being evaluated.
    * @param out      A collector for emitting elements.
    * @throws Exception The function may throw exceptions to fail the program and trigger recovery.
    */
  @throws[Exception]
  def process(key: KEY, context: Context, elements: Iterable[IN], out: Collector[OUT])

  /**
    * Deletes any state in the [[Context]] when the Window expires
    * (the watermark passes its `maxTimestamp` + `allowedLateness`).
    *
    * @param context The context to which the window is being evaluated
    * @throws Exception The function may throw exceptions to fail the program and trigger recovery.
    */
  @throws[Exception]
  def clear(context: Context) {}

  /**
    * The context holding window metadata
    */
  abstract class Context {
    /**
      * Returns the window that is being evaluated.
      */
    def window: W

    /**
      * Returns the current processing time.
      */
    def currentProcessingTime: Long

    /**
      * Returns the current event-time watermark.
      */
    def currentWatermark: Long

    /**
      * State accessor for per-key and per-window state.
      */
    def windowState: KeyedStateStore

    /**
      * State accessor for per-key global state.
      */
    def globalState: KeyedStateStore

    /**
      * Emits a record to the side output identified by the [[OutputTag]].
      */
    def output[X](outputTag: OutputTag[X], value: X);
  }
}

```

下面我简单用ProcessWindowFunction进行创建

```
package flinklearn


import org.apache.flink.streaming.api.scala.function.{ProcessWindowFunction, WindowFunction}
import org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows
import org.apache.flink.streaming.api.windowing.time.Time
import org.apache.flink.streaming.api.windowing.windows.TimeWindow
import org.apache.flink.util.Collector

object flinkwindowall {
  def apply(): flinkwindowall = new flinkwindowall()

  def main(args: Array[String]): Unit = {
    flinkwindowall().excute()
  }
}


class flinkwindowall(){

  import org.apache.flink.streaming.api.scala._



  def excute(): Unit ={
    val env = StreamExecutionEnvironment.getExecutionEnvironment

    val value = env.addSource(new clickSource)

    // 指定一个无关的数据，代表全局
    value.assignAscendingTimestamps(_.timestamp) // 创建水位线
      .keyBy(data => "key") // 设置全局分区
      .window(TumblingEventTimeWindows.of(Time.seconds(10))) // 开窗
      .process(new firstProcessWindowFunction ) // 调用ProcessWimdowFunction的方法


    env.execute()
  }
}

class firstProcessWindowFunction extends ProcessWindowFunction[event,String,String,TimeWindow]{
  override def process(key: String, context: Context, elements: Iterable[event], out: Collector[String]): Unit = {
    // 使用set进行去重
    var userset = Set[String]()


    // 从element中提取元素
    elements.map(userset += _.uaer)
    val uv = userset.size
    // 提取窗口信息，进行输出
    val end = context.window.getEnd
    val start = context.window.getStart

    println(s"从${start} 到 ${end} 的uv是${uv}")


  }
}

```

可以把上述的全窗口和增量放到一起，通过Aggregatortion里面可以传入两个参数，一个是增量的，一个是全窗口的

就表式，增量的结果变成了全窗口的输入，就是两者结合如下：

```
package flinklearn



import org.apache.flink.api.common.eventtime.{SerializableTimestampAssigner, WatermarkStrategy}
import org.apache.flink.api.java.utils.ParameterTool
import org.apache.flink.streaming.api.scala.function.ProcessWindowFunction
import org.apache.flink.streaming.api.windowing.assigners.{EventTimeSessionWindows, ProcessingTimeSessionWindows, SlidingEventTimeWindows, SlidingProcessingTimeWindows, TumblingEventTimeWindows, TumblingProcessingTimeWindows}
import org.apache.flink.streaming.api.windowing.time.Time
import org.apache.flink.streaming.api.windowing.windows.TimeWindow
import org.apache.flink.util.Collector

object flinkWindos {
  def apply(parameterTool: ParameterTool): flinkWindos = new flinkWindos(parameterTool)

  def main(args: Array[String]): Unit = {
    val tool = ParameterTool.fromArgs(args)
    flinkWindos(tool).ecxcute()
  }
}


class flinkWindos(parameterTool: ParameterTool){

  import org.apache.flink.streaming.api.scala._

  def ecxcute()={
    val env = StreamExecutionEnvironment.getExecutionEnvironment
    val zihan = env.addSource(new clickSource)

    val zihan1 = zihan.assignTimestampsAndWatermarks(WatermarkStrategy.forMonotonousTimestamps().withTimestampAssigner(
      new SerializableTimestampAssigner[event] {
        override def extractTimestamp(element: event, recordTimestamp: Long): Long = {
          element.timestamp
        }
      }))

   val zihan2 =  zihan1.map(data => {(data.uaer,1)})
      .keyBy(data => "key")
//      .window(TumblingEventTimeWindows.of(Time.seconds(7)))// 基于事件时间的滚动窗口 , 偏移量为后面的参数
//      .window(TumblingProcessingTimeWindows.of(Time.days(1),Time.hours(-8))) // 基于处理时间的滚动窗口
      .window(SlidingEventTimeWindows.of(Time.seconds(10),Time.minutes(2))) // 基于时间时间的滑动窗口 步长为10min
//      .window(SlidingProcessingTimeWindows.of(Time.days(1),Time.minutes(10),Time.hours(-8))) // 基于处理时间的滑动窗口 步长为10min
//      .window(EventTimeSessionWindows.withGap(Time.seconds(10))) //  基于事件时间的会话窗口
//      .window(ProcessingTimeSessionWindows.withGap(Time.seconds(10))) // 基于处理时间的会话窗口
//      .countWindow(10) // 大小为10的滚动计数窗口
//      .countWindow(10,2) // 大小为10的滑动计数窗口，步长为2

    //  窗口函数
    // 分为增量窗口 和 全窗口
    // 增量聚合 是每来一条数据，就处理一条数据，然后存储他的状态，等窗口满足条件，直接输出
    // 全窗口，则是类似批处理的形式，把数据都聚集在一起，然后满足条件执行操作，在输出


    /*
    增量聚合函数包括（典型） ： ReduceFunction AggregateFunction
    规约聚合：reduceFunction -> 两两进行规约，就和之前简单函数的那个是一样的
    */
      // reduce 他在规约的过程中，中间是不能变的，就是数据的输入，输出，规则都一样
//      .reduce( (x,y)=> {
//        (x._1,x._2+y._2)
//      } )
//      .print()
    // aggre 则可以改变类型，比上面更为灵活
       zihan2.aggregate(new tryFunction11, new firstProcessWindowFunction1).print()

    env.execute()
   
  }



}

import  org.apache.flink.api.common.functions._
class tryFunction11 extends AggregateFunction[(String,Int),(Long,Set[String]),Double] {
  override def createAccumulator(): (Long, Set[String]) = {
    (0L,Set[String]()) // 赋初值
  }

  // 计算过程
  override def add(value: (String, Int), accumulator: (Long, Set[String])) = {
    (value._2 + accumulator._1 , accumulator._2 + value._1)
  }

  // 结果
  override def getResult(accumulator: (Long, Set[String])): Double = {
    accumulator._1/accumulator._2.size
  }

  // 会话窗口要用的
  override def merge(a: (Long, Set[String]), b: (Long, Set[String])): (Long, Set[String]) = ???
}

class firstProcessWindowFunction1 extends ProcessWindowFunction[Double,Double,String,TimeWindow]{
  override def process(key: String, context: Context, elements:Iterable[Double], out: Collector[Double]): Unit ={


    var total:Double = 0
    elements.map(total+=_)
    // 提取窗口信息，进行输出
    val end = context.window.getEnd
    val start = context.window.getStart
    println(s"从${start} 到 ${end} 的rate是${elements}额外的统计信息是${total}")


  }


}

```

## 处理迟到数据

可以允许迟到数据

通过调用windowStream下的allowedLateness,设置允许迟到时间，等到达时间，则会发送到下游

还可以通过测输出流，进行收集过于迟到的数据，但是对这个侧输出流的操作是影响不到窗口的，和窗口相当于是分开的

代码：

```
package flinklearn
import java.time.Duration
import java.util.Calendar

import org.apache.flink.api.common.eventtime.{SerializableTimestampAssigner, WatermarkStrategy}
import org.apache.flink.streaming.api.scala._
import org.apache.flink.streaming.api.scala.function.ProcessWindowFunction
import org.apache.flink.streaming.api.windowing.assigners.{TumblingEventTimeWindows, TumblingProcessingTimeWindows}
import org.apache.flink.streaming.api.windowing.time.Time
import org.apache.flink.streaming.api.windowing.windows.TimeWindow
import org.apache.flink.util.Collector
import tool._
object dealdelaydata {

  def main(args: Array[String]): Unit = {
    val environment = StreamExecutionEnvironment.getExecutionEnvironment
    val value = environment.socketTextStream("43.140.193.43", 6000).map(data=>{
      val strings = data.split(" ")
      loginfo(strings(0),strings(1))
    })
    val resulttmp = value.assignTimestampsAndWatermarks(WatermarkStrategy.forBoundedOutOfOrderness(Duration.ofSeconds(2)).withTimestampAssigner(new SerializableTimestampAssigner[loginfo] {
      override def extractTimestamp(element: loginfo, recordTimestamp: Long): Long = {
        element.dt.toLong
      }
    }))

//    val resulttmp2 = resulttmp.keyBy(_.log).window(new TumblingProcessingTimeWindows()).process(new myprocessTimeWindow)
//
//    resulttmp2.print()

    val flag = new OutputTag[loginfo]("test")
    val resluttmp3 = resulttmp.keyBy(_.log).window(  TumblingProcessingTimeWindows.of(Time.seconds(10))).allowedLateness(Time.seconds(10)).sideOutputLateData(flag).process( new myprocessTimeWindow)
    resluttmp3.print("resulttmp3的原始数据")
    resluttmp3.getSideOutput(flag).print("侧输出流")

    environment.execute()
  }
}

class myprocessTimeWindow extends ProcessWindowFunction[loginfo,String,String,TimeWindow] {
  override def process(key: String, context: Context, elements: Iterable[loginfo], out: Collector[String]): Unit = {

    out.collect(s"处理时间${context.window.getStart}~${context.window.getEnd}用户${key}的点击次数${elements.size}当前水位线为${context.currentWatermark}")
  }
}



import  org.apache.flink.api.common.functions._
class myeventTimewindow extends AggregateFunction[loginfo,String,String]{
  override def createAccumulator(): String = ???

  override def add(value: loginfo, accumulator: String): String = ???

  override def getResult(accumulator: String): String = ???

  override def merge(a: String, b: String): String = ???
}
```

## 处理函数

### 基本处理函数（ProcessFunction）
