---
title: java里的日期和Object的一些方法
date: 2022-10-18 17:44:10
categories: 日志
comments: "true"
tag: java
---
# Java.util.Date

```
Date d = new Date();
System.out.Println(d);
```

一般这样直接打印出，是中国国际化标准化时间
但是一般除了getTime别的都过时了，保不准会在什么时候就舍弃

## getmonth

他是用农历算的，范围是0-11

```
d.getMonth();
```

## getYear

获取从1900年到现在的年数

```
d.getYear();
```

## getDate

获取到现在的日期

```
d.getDate();
```

## getHours

获取现在的小时

```
d.getHours();
```

## getMinutes

获取现在的分钟数

```
d.getMinutes();
```

## getSeconds

获取当前的秒数

```
d.getSeconds();
```

## getDays

获取当前日期范围是0-6，周一到周六

```
d.getDay();
```

## getTime

获取从1970年到现在时间

```
d.getTime();
```

## compareTo

自动排序：正数是大于 ， 0是相等 ， -1 是小于

```
d.compareTo(d);
```

## 注解

```
@Deprecated
 代表过时的，会让方法上面画上横线
```

# java.sql.Date

## 实例化

```
java.sql.Date d = new java.sql.Date(date.getTime);
// 获取时间,包含天月的
```

## Time

```
java.sql.Time d  = new java.sql.Time(date.getTime);
// 获取时间
```

## Timestamp

```
java.sql.Timestamp d = new java.sql.Timestamp(date.getTime);
// 获取精确到毫秒数的时间
```

# 格式化

```
SimpleDateFormat s = new SimpleDateFormat("yyyy-MM-dd:mm:ss.SSS");
```

## format日期变字符串

```
String string s.format(date);
```

## 字符串变日期

```
s.parse("2000-11-12 13:14:15.000");
// 但是这个可能会有错误，所以，我们需要用try catch包住他
```

# Ccalender

用静态方法实例化，new 不了

```
Calendar c = Calendar.getLnstance();
```

## set设置

set和get基本相同

```
c1.set(Calendar.MONTH ， xxx)；
c1.set(Calendar.HOURS , xxx);等
// 这里xxx代表一个int型的数字，会自动进位，如果xxx超过11则会自动进位，对其他的小时，秒数也同样是适用
```

## get获取

```
c.get(Calendar.MONTH);
c.get(Calendar.DATE);
等,要通过一系列常量来控制他
```

## add计算

```
c.add(Calendar.MONTH , 1);
// 单纯是加到其中前一个变量上，可以进位。还有其他的方法，比如huors等
```

## getTime

转换成Date型，然后就可以用SimpleDateFormat了

# Localdate

```
LocalDate l = LocalDate.now(); // 获取当前日期
```

- 最大支持999999999-12-31
- 最小支持-999999999-01-01

## adjiustInto

调整指定的时间对象与此对象时间相同

```
l.adjustInto(l)
```

## equals

检查这个日期是不是等于另外一个日期

```
l.equals(d)
```

## format

使用指定格式格式化日期

```
l.format(null);
```

## get

## set

## getDayofMonth

获取月份字段

```
l.getDayofMonth();
```

## getDayofWeek

同上只是获取星期几，这个是个枚举

```
l.getDayOfWeek();
```

## getDayofYear

同上只是获取日期字段

```
l.getDayofYear();
```

## getChronology

获取ios的日历系统的

```
l.getChronology();
```

## hashcode

返回这个日期的哈希码

```
l.hashcode();
```

## isAfter

检查日期是不是在这个日期之后

```
l.isAfter(l);
```

## isBefore

同上

## isEqual

检查这个日期是不是等于指定日期

```
l.isEqual(l);
```

## isLeapYear

根据ios日历，检查是不是闰年

```
l.isLeapYear();
```

## now

获取当前的时间
初始化方法

## parse

同上面的parse

```
l.parse(null);
```

## plus

返回此日期的副本，并添加指定的金额。

```
l.plus(null);
```

## plusDays

返回指定天数的副本

```
l.plusDays(0);
```

## plusMonths

返回这个LocalDate的副本，其指定的时间段以月为单位

```
l.plusMonths(0);
```

## plusweeks

返回这个LocalDate的副本并以指定周期添加周数

```
l.plusWeeks(0);
```

## plusYears

返回这个LocalDate的副本其中指定的时间段以添加的年数访问

```
l.plusYears(0);
```

## query

返回指定的查询查询日期

```
l.query(null);
```

## with

返回此日期的调整的副本

- 其和上面一样有对单独地方调整的函数，比如日期月份等

```
l.with(l);
		l.withDayOfMonth(0);
		l.withDayOfYear(0);
		l.withMonth(0);
		l.withYear(0);
```

## toString

将日期转换为字符串

```
l.toString();
```

# 方法的综合应用

## 计算每个月的天数通过Calendar运行

```
		C1.add(Calendar.MONTH, 1);
		C1.add(Calendar.DAY_OF_MONTH, -(当前天数));
		System.out.println(C1.getTime());
```

## LocalDateTime的实际应用

```java
package lesson12;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.TemporalField;

public class TestMain4 {

	public static void main(String[] args) {
//		LocalTime
//		LocalDate
		LocalDateTime ldtDateTime = LocalDateTime.now();
		System.out.println(ldtDateTime);
		System.out.println(ldtDateTime.getDayOfWeek().getValue()); // 2
		System.out.println(ldtDateTime.getMonth()); // 10不会走 国外的历法
		System.out.println(ldtDateTime.getMonthValue()); 
	
		LocalDateTime ldtDateTime2 = LocalDateTime.of(2022, 11, 11, 12, 12, 12);
		System.out.println(ldtDateTime2);
	
		DateTimeFormatter dFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
		String string = dFormatter.format(ldtDateTime);
		System.out.println(string);
	
		LocalDateTime ldtDateTime3 = LocalDateTime.parse("2022-10-18 15:21:30", dFormatter);
		System.out.println(ldtDateTime3);
	
		LocalDateTime ldtDateTime4 = LocalDateTime.from(dFormatter.parse("2022-10-18 15:21:30"));
		System.out.println(ldtDateTime4);
	}
}
```

# Object

## getClass

获取反射

## hashCode

获取hash值，约等于地址

## equals

- 比较对象的值
- ==对比的是地址

## clone

暂时不让用，意义是克隆属性,但是对于引用类型直接克隆是克隆地址，就会造成改一个进而全部都改变，但是有办法，可以进行深克隆进而解决

- 浅克隆：就是只用一次克隆
- 深克隆：通过多次克隆进而使每个被克隆出来的个体都有不同地址的相同引用类型

### 使用克隆的方法

- Cloneable:  标记型接口，先实现标记性接口 。 JDK就2个标记接口Serializable和Cloneable

  - 1. 覆盖Object的clone方法;
    2. 实现标记Cloneable;

## finalize

finalize代表GC回调，就是让垃圾回收不要回收他，但是一般不让用，因为会容易造成卡死，或者因为有关联关系的对象而无法进行进行回收

```
java
  package lesson12;
  
  public class TestMain6 {
  
  	public static void main(String[] args) {
  		Student student = new Student("jerry", 2);
  		abc();
  		student = null;
  		System.out.println(111);
  	
  		// 通知jvm在适当时候进行GC
  		System.gc();
  		System.out.println(222);
  		for (;;) {
  		
  		}
  	
  	}
  
  	private static void abc() {
  		// TODO Auto-generated method stub
  		Student student = new Student("tom", 1);
  	}
  
  }
  Student {
  	@Override
  	protected void finalize() throws Throwable {
  		System.out.println(this + "被回收了");
  	}
  }
```

# static 代码块和非static代码块

- static 静态代码块。  运行时记载类，只调用一次。

  - 一次性的操作。例如： 加载资源，加载驱动。
- 非静态代码块，       每次实例化都会调用

```java
package lesson12;

public class TestMain7 {

	static {
		System.out.println("这是静态代码块");
	}
	{
		System.out.println("这是非静态代码块");
	}
	public static void main(String[] args) {
		TestMain7 a1 = new TestMain7();
		TestMain7 a2 = new TestMain7();
	}
}

```
