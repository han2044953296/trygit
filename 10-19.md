---
title: 设计模式和反射
date: 2022-10-19 8:30:00
categories: 日志
comments: "true"
---

# 单例模式 #
- 一个类只有一个实例
- 通过private ， 构造方法
- static方法
- 饿汉式
- --------------------------------------------------------------
```
public class testmain1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		A a1 = A.getInstance();
		
	}

}
class A {
	private A() {
		
	}
	private static A a1 = new A();
	public static A getInstance() {
		return a1;
	}
}
```
- --------------------------------------------------------
- 懒汉式
- ----------------------------------------------------
```

	package 作业;
	public class testmain1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		A a1 = A.getInstance();
		B a2 = B.getInstance();
	}

	}
	
	class B {
		private B() {
		
	}
	private static B ai;
	public synchronized static B getInstance() {
		if(ai == null) {
			ai = new B();
		}
		return ai;
	}
	}
```
- 开发的时候懒汉式用的比较多，因为可控
- 但是一般都在懒汉式哪里添加一个线程锁，为了线程安全，就是synchronized
# 工厂模式 #
- 创建型设计模式
- 通过方法创建对象
## 简单工厂模式 ##
- 静态工厂方法模式，例如单例模式，单例模式是特殊的工厂模式

```
	class Diver {
		public static Car driverCar(String s) {
			if(s.equalsIgnoreCase("宝马")) {
				return new Car("宝马");
			}
			if(s.equalsIgnoreCase("奔驰")) {
				return new Car("奔驰");
			}
			if(s.equalsIgnoreCase("奥迪")) {
				return new Car("奥迪");
			}
		}
	}
```
## 工厂方法模式 ##
- 非静态方法，不同的工厂生成不同的产品

```

	package factory;
	public  class bzfactory {
	
	public  Car product() {
		return new Car();
	}
	}
	class BenzCar extends bzfactory{
	public Car product() {
		return new bz();
	}
	}

	class bmwfactory extends bzfactory{
	public Car product() {
		return new bmw();
	}
	}

	class Car{
	
	}
	class bz extends Car{
	
	}
	class bmw extends Car{
	
	}
	class audi extends Car{
	
	}
```

- 这样可以不用动代码，可以直接加类，进而直接引
- 而第一种要把别的人已经打包好的解包进而对其代码进行操作
- 而这种不用，只要新加几个类就可以
## 抽象工厂模式 ##
- 工厂的工厂模式
- 给用户提供一个接口，可以创建多个产品族中的对象

```
	package com.icss.javasechapter.factory;
//抽象工厂模式
	interface Car{
		public void drive();
	}

	interface SportsCar extends Car{
		public boolean isConvertible();
	}

	interface BussinessCar extends Car{
		public boolean isAutoDoor();
	}
	
	// 具体产品角色
	class BenzSprotsCar implements SportsCar {
		public void drive() {
			System.out.println("Driving Benz S");
		}

		@Override
		public boolean isConvertible() {
			// TODO Auto-generated method stub
			return true;
		}
	}
	class BenzBussinessCar implements BussinessCar {
		public void drive() {
			System.out.println("Driving Benz B");
		}

	@Override
		public boolean isAutoDoor() {
			// TODO Auto-generated method stub
			return false;
				}	
	}

	class BmwSprotsCar implements SportsCar {
		public void drive() {
			System.out.println("Driving Bmw S ");
		}

		@Override
		public boolean isConvertible() {
			return true;
		}
	}
	class BmwBussinessCar implements BussinessCar {
		public void drive() {
			System.out.println("Driving Bmw B ");
		}

		@Override
		public boolean isAutoDoor() {
		// TODO Auto-generated method stub
		return false;
		}	
	}


	interface CarFactory{
		public SportsCar getSportsCar();
		public BussinessCar getBussinessCar();
	}
	
	class BenzCarFactory implements CarFactory{

		@Override
		public SportsCar getSportsCar() {
			// TODO Auto-generated method stub
			return new BenzSprotsCar();
		}

	@Override
	public BussinessCar getBussinessCar() {
		// TODO Auto-generated method stub
		return new BenzBussinessCar();
	}
	
	}

	class BmwCarFactroy implements CarFactory{

		@Override
		public SportsCar getSportsCar() {
		// TODO Auto-generated method stub
			return new BmwSprotsCar();
		}

		@Override
		public BussinessCar getBussinessCar() {
		// TODO Auto-generated method stub
			return new BmwBussinessCar();
		}
	
	}

	// 抽象产品角色，具体产品角色与简单工厂模式类似，只是变得复杂了些，这里略。
	// 抽象工厂角色
	class AbstractCarFactory{
	
	public static CarFactory getCarFactory(String name){
		if("Benz".equals(name)){
			return new BenzCarFactory();
		}else if("Bmw".equals(name)){
			return new BmwCarFactroy();
		}else{
			throw new RuntimeException();
		}
	}
	
	}



	public class MagnateAbstractFactory {
		public static void main(String[] args) {
			try {
				CarFactory factory = AbstractCarFactory.getCarFactory("Bmw");
				BussinessCar car = factory.getBussinessCar();
				car.drive();
				System.out.println(car.isAutoDoor());
			} catch (Exception e) {
			}
		}
	}
```
## 观察者模式 ##
- 订阅与发布
- java通过Observable和Observer来实现
```
	package 作业;

	public class lesson13 {

		public int aaa =0;
		public MyObsever[] array = new MyObsever[10];
		int index = -1;
		public void addObsever(MyObsever obs) {
				array[++index > 9 ? index = 0 : index] =obs;
		}
		public void setAaa(int newvalue) {
			this.aaa = newvalue;
			for(int i =0; i < array.length ; i++) {
				if(array[i] == null)break;
					array[i].update(this.aaa , newvalue);
				}
			this.aaa = newvalue;
		}
	
		public static void main(String[] args) {
			MyObsever ob = new MyObsever();
			lesson13 data = new lesson13();
			data.addObsever(ob);
			data.setAaa(10000);
		}
		
		}
	


	class MyObsever {
		String name;
		public void update(int aaa , int newvalue) {
			System.out.println("观察者" + this.name + "," + aaa + "变成" + newvalue);
		}
		}

```
- 简单来说就是群发消息，或者说是改变github上的代码的那种改变
## 代理模式 ##
- 代理模式给一个对象提供代理对象，比如代打，比如代刷xxx等
```
	package 作业;
	public class TestMain4 {
		public static void main(String[] args) {
			// TODO Auto-generated method stub
			Target t = new Target();
			Proxy proxy = new Proxy();
			proxy.target = t;
			proxy.price();
			}
	}
	class Target {
		public void price() {
			System.out.println("---100--");
		}
	}
	class Proxy {
		Target target;
		public void price() {
			try {
				System.out.println("100");
				target.price();
				System.out.println("50");
			} catch (Exception e) {
				// TODO: handle exception
				System.out.println("10");
			}
		}
	}
```
- 就相当于中间商赚差价，商家会把货发送到代理这里，代理再提高价格发送出去，上面的这个叫静态代理
## 动态代理 ##
- 动态代理要用接口来实现
```
	package lesson13;
	import java.lang.reflect.InvocationHandler;
	import java.lang.reflect.Method;
	import java.lang.reflect.Proxy;
	import java.nio.channels.NonWritableChannelException;
	public class TestMain4 {
		public static void main(String[] args) // 主方法调用代理的 
		{
			DynamicTargetInf inf = DynamicProxFactory.getInstance();	
			inf.price();
			int r = inf.add(1, 2);
			System.out.println(r);
		}
	}
	interface DynamicTargetInf // 要代理的接口 
	{
		void price();
		int add(int i, int j);
	}
	class DynamicTarget implements DynamicTargetInf // 要代理的目标类，我们接下来要代理这里的方法
	{
		public void price() {
			System.out.println("--target-100--");
			}
		@Override
		public int add(int i, int j) {
			System.out.println("--target-i + j--");
			return i + j;
		}
		}
		// invocationHandle   invoke执行 handle句柄    welcome,xxx
		class DynamicProxFactory implements InvocationHandler // 代理控制器，就是代理对象每次要运行方法都要经过他
		{
		DynamicTargetInf target = new DynamicTarget();	// 一般这个地方是要传值进来的，不过这里为了方便，我们就直接赋值了
		// 代理对象每次运行方法的时候会执行
		@Override
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable // invoke方法是InvocationHandler接口的方法，这个方法是执行的意思
		{
				Object result = null; // 定义一个返回值 ，Object类代表可以转化成任何类型
			try {  // try catch包裹，一是为了判断是不是出错，二是为了安全性
			System.out.println("-之前-100---");
			// 反射。当前方法执行。target对象的当前方法， args方法的参数
			result = method.invoke(target, args);
			//	target.price();
			System.out.println("-之后-50---");	
		} catch (Exception e) {
			System.out.println("-异常-10---");
		}
		return result;
		}
		public static DynamicTargetInf getInstance() // 要代理的目标的接口的实例化方法 ， 通过这个方法会把要代理对象的接口和代理工厂连接到一起
		{
		Object object = java.lang.reflect.Proxy.newProxyInstance(DynamicProxFactory.class.getClassLoader(), new Class[] {DynamicTargetInf.class}, new DynamicProxFactory()); // 这里的三个参数其实是，第一个是类加载器 ， 第二个是目标接口的类数组 ， 第三个是代理工厂的句柄，也就是句柄
		return (DynamicTargetInf) object;
	}
	}
```
- 对于静态的代理，每一个方法都要写一个代理，于是就很麻烦，可是对于动态的代理，他会自动的把那个方法里的方法都代理一边，只要在主函数里调用就行，
- 其实基本上思想就是，把要代理的目标变成一个接口，然后通过实例化这个接口，再通过接口的特性，让代理去实现目标的方法
- 私有的方法无法代理
# 反射，类的类型 #
类的类型，就是所有类都可以有的东西比如：属性，构造方法，方法。


- 可以用这些类的类型去创建一个新类
- 而我们如果想获取这个类的类型，就要用到反射，
- 他可以获取这个类的类型，就是上面说的属性，构造方法，方法

```

	package 作业;
	import java.lang.reflect.Constructor;
	public class wjw1 {
	public static void main(String[] args) {
		// 获取反射的三种方式 第一种
		Class clzz1 = student.class;
		// 第二中 
		student student = new student();
		Class a = student.getClass();
		// 第三种
		try {
			Class ae = Class.forName("作业.student");
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		Constructor[] cons = clzz1.getConstructors(); // 查看构造器
		for (int i = 0; i < cons.length; i++) {
			System.out.println(cons[i]);
			}
		Field[] d = a.getFields(); // 查看变量，非私有的
		for (int i = 0; i < d.length; i++) {
			System.out.println(d[i]);
		}
		Field[] f = a.getDeclaredFields(); // 私有变量只能这样查看
		for (int i = 0; i < f.length; i++) {
			System.out.println(f[i]);
		}
			Constructor Con; // 获取有特定参数的构造器
		try {
			Con = clzz1.getConstructor(new Class[] {String.class , int.class});//里面放那个类型的对应的.class
			} catch (NoSuchMethodException | SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		try { // 通过反射进行实例化，证明了，实例化不一定非要用new
			Object object = Con.newInstance(new Object[] {343,"sdajkdha"});
			} catch (InstantiationException | IllegalAccessException | IllegalArgumentException
				| InvocationTargetException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 
		}
	}
```

- 上面，是我们要运行的方法里如何写

```	

	package 作业;	
	public class student {
	private String name;
	private String num;
	private String sex;
	public int age;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getNum() {
		return num;
	}
	public void setNum(String num) {
		this.num = num;
	}
	public String getSex() {
		return sex;
	}
	public void setSex(String sex) {
		this.sex = sex;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public student() {
		super();
		// TODO Auto-generated constructor stub
	}
	public student( int x , String name) {
		this.age = x;
		this.name = name;
		// TODO Auto-generated constructor stub
	}
	clzz1.getMethods() // 获取里面所有可以访问的方法
	clzz1.getMethod(name, parameterTypes) // 获取特定的可以访问的方法
	clzz1.getDeclaredMethod(name, parameterTypes); // 查找特定参数的自己定义的方法
	clzz1.getDeclaredMethods(); // 查询所有自己定义的方法
	Method m = clzz1.getDeclaredMethod(name, parameterTypes);
	Object r = m.invoke(obj, args); // 执行前面一个参数里的方法m方法 ， 后面的一个是这个方法的参数
	
	
	 Field f1 =	clzz1.getField("name"); // 获取单独的与里面字符串匹配的变量 ， 如果是私有的要用declaer方法，比如
	 Field f2 = clzz1.getDeclaredField("name"); // 可以获取私有的变量
	 f1.setAccessible(true); // 修改访问权限修饰符，true代表public false代表private
	}

```

- 下面只是个普通的方法
- 这是两个class，要注意，因为都是public，所以必须单独建立两个class，才可以
# 注解 #
- 用@interface
```
	package 作业;
	@Target (value = {ElementType.CONSTRUCTOR,ElementType.FIELD,ElementType.METHOD,ElementType.TYPE}) // target是代表要修饰的目标种类，比如方法，构造器，属性等
	@Retention(value = RetentionPolicy.SOURCE) // 代表这个存活的位置，一般我们用不到，这个是存活于源码里，编译之后就无了
	@Retention(value = RetentionPolicy.CLASS) // 这个是存活与class中
	@Retention(value = RetentionPolicy.RUNTIME) // 这个是存活在运行时
	public @interface lesson14 {
	}
```

- 上面的@Retention只能用一个，而且只能选择一个
- 而后再有一个类


```
	package 作业;
	@lesson14
	public class try1 {
		@lesson14
		public static void main(String[] args) {
			// TODO Auto-generated method stub
		}
	}
```
- 上面是一般用法。
- 如果在接口上面增加@Target，就是代表让你可以修饰的东西
- @Retention 代表设置其存活的地方
## value ##
可以在接口内写value，如果加上了value则在引用的时候要在括号内写上内容
如下：
```
	public @interface lesson14 {
	String value()
	default "默认信息"; // 代表默认值
	}
```
```
	@lesson14("klsdajhal")
	或者@lesson14(value = "sadajd")
```

