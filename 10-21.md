---
title: 字符流
date: 10/21/2022 8:42:15 AM  
categories: 日志
comments: "true"
tag: java
---
# Write

- Write是抽象方法
- 其里面定义了传输大小（在源码中）
- 在write里

```
private static final int WRITE_BUFFER_SIZE = 1024;
```

- 所谓的字符流只是把字节流包装起来，证据在源码里

```
package 项目实训;

	import java.io.FileWriter;
	import java.io.IOException;
	import java.io.Writer;

	public class char流 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	try {
		Writer w = new FileWriter("D:/a.txt");
		w.write("hello world");
		w.append("hello Bgido");
		w.write("hello java".toCharArray());
		w.flush();
		w.close();
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	}

	}
```

- 注意这里的write是直接在文件里重写数据，而append是增加数据，因为write底层调用的是write方法

# Read

- 出现的原因，是因为字节流可能存不住，所以才出现，会造成乱码

## 字符分类以及编码格式

- 一般在英文状态下一个字母或字符占用一个字节，一个汉字用两个字节表示。
- ASCII 码中，一个英文字母(不分大小写)为一个字节，一个中文汉字为两个字节。
- UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。
- Unicode 编码中，一个英文为一个字节，一个中文为两个字节。
- 符号：英文标点为一个字节，中文标点为两个字节。例如：英文句号 . 占1个字节的大小，中文句号 。占2个字节的大小。
- UTF-16 编码中，一个英文字母字符或一个汉字字符存储都需要 2 个字节(Unicode 扩展区的一些汉字存储需要 4 个字节)。
- UTF-32 编码中，世界上任何字符的存储都需要 4 个字节。

## 代码

```

	package 项目实训;
	import java.io.FileInputStream;
	import java.io.FileReader;
	import java.io.InputStream;
	import java.io.InputStreamReader;
	import java.io.Reader;
	public class inputchar1 {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		try {
			Reader reader = new FileReader("D:/a.txt");
			reader.close();
			// 这个也可以读取文件
			Reader reader1 = new InputStreamReader(new FileInputStream("D:/a.txt") , "UTF-8"); // 古老的方式，不过可以直接改代码的编码格式
			char[] buffer = new char[10];
			int len = 0;
			while((len = reader1.read(buffer)) != -1) {
				System.out.print(new String(buffer , 0 ,len));
			}
			reader1.close();
			while((len = reader.read(buffer)) != -1) {
				System.out.print(new String(buffer, 0, len));
			}
			reader.close();
		} catch (Exception e) {
			// TODO: handle exception
		}
	}
	}
```

# 具体的流

## buffered系类

- 代表缓冲区系类
- 

```

	package 项目实训;
	import java.io.BufferedInputStream;
	import java.io.BufferedReader;
	import java.io.FileInputStream;
	import java.io.FileNotFoundException;
	import java.io.FileReader;
	import java.io.IOException;

	public class sdahasdk {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		try {
			BufferedInputStream us = new BufferedInputStream(new FileInputStream("D:/a.txt")); // 要自己定义缓冲区
			us.skip(1);
			byte[] buffer = new byte[10];
			int len = 0;
			while((len = us.read(buffer)) != -1) {
				System.out.println( new String(buffer , 0 ,len ));
			}
			us.close();
		
			BufferedReader r = new BufferedReader(new FileReader("D:/a.txt")); // 里面有设置默认的缓冲区在源码里可以点进去查看
			while(r.ready()) // ready是可读性，可读就true，不可读就fasle
			{
				System.out.println(	r.readLine());
			}
	
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	}
```

- 只有顶层类的方法是没有线程锁的
- 同样也有writer的方法

```
BufferedWriter wwe = new BufferedWriter( new FileWriter("D:/a.txt"));
```

- 然后通过wwe.xxx访问方法

# InputStreamReader/Writer

- 比较古老
- 因为可以设置编码格式
- 在构造方法里
- 和上面的FileInputStream一样

# ObjectInputStream

```

	package 项目实训;
	import java.io.Serializable;
	public class stu implements Serializable{
	public stu() {
		super();
		// TODO Auto-generated constructor stub
	}
	public stu(int x , String name) {
		this.age = x;
		this.name = name;
		// TODO Auto-generated constructor stub
	}
	private String name;
	private transient int age;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	@Override
	public String toString() {
		return "stu [name=" + name + ", age=" + age + "]";
	}
	}

```

- 这个是个学生类，代表我们要实例化的类，要加个可序列化的标记性接口
- transient是不参与序列化的

```
package 项目实训;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

public class lesson15 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		try {
			ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream("D:/student.dat"));
			stu s = new stu(15 , "tom");
			oo.writeObject(s);
			oo.flush();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 
	}

}

```

## 读取

```

	package 项目实训;
	import java.io.FileInputStream;
	import java.io.FileNotFoundException;
	import java.io.FileOutputStream;
	import java.io.IOException;
	import java.io.ObjectInputStream;
	import java.io.ObjectOutputStream;
	public class lesson15 {
	public static void main(String[] args) {
		// TODO Auto-generated method stub

		try {
		
			ObjectInputStream d = new ObjectInputStream(new FileInputStream("D:/student.dat"));
			Object o = d.readObject();
			System.out.println(o);
			d.close();
		
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 
	}


	}
```

# Scanner

```

	package 项目实训;
	import java.io.FileInputStream;
	import java.io.FileNotFoundException;
	import java.util.Scanner;
	public class scanner {
	public static void main(String[] args) {
		// TODO Auto-generated method stub

		try {
			Scanner scanner = new Scanner( new FileInputStream("D:/a.txt") , "UTF-8");
			while(scanner.hasNext()) {
				System.out.println(scanner.nextLine());
			}
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	}
```

# Channnel流

- 其是新io包里的
- 是nio里的，用的是堆外内存
- 就是jvm内存，所以效率会比在堆里的数组缓冲区效率更高
- 追主要的是对接，管道分为输入管道和输出管道
- 当他们对接上就可以实现复制等操作了

```

	package 项目实训;
	import java.io.File;
	import java.io.FileInputStream;
	import java.io.FileNotFoundException;
	import java.io.FileOutputStream;
	import java.io.IOException;
	import java.nio.channels.FileChannel;
	public class Channel {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		File file = new File("D:/a.txt");
		FileInputStream ii;
		try {
			ii = new FileInputStream(file);
			FileChannel cha = ii.getChannel();
			FileChannel out = new FileOutputStream("D:/a1.txt").getChannel();	
			cha.transferTo(0, file.length(), out); // 这个输入管道的对接口 三个参数 ，第一个是开始复制的起始下标，第二个是文件长度 ，第三个是输出管道
			out.transferFrom(cha, 0, file.length()); // 这个是输出管道的接口 三个参数 ，第一个是输入管道，第二个是起始下标 ，第三个是文件长度
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	
	}

	}

```

- 两种管道对接的方式造成的结果是一样的，都是复制文件，但是如果这两个代码要制作的文件存在，则进行覆盖

# StringBuffer和StringBuilder

- 解决字符串的加法的问题，
- 字符串的+是方法的重载，每次都会返回一个对象
- 而下面两个则是用堆运存运算省区了一个变量
- 而builder无线程锁，所以比buffer要快

```
	package 项目实训;
	public class sr {
	public static void main(String[] args) {
		String s = "shdghgsg";
		long start = System.currentTimeMillis();
		 // 拼接太费事
		String h = s + "shak";
		long end = System.currentTimeMillis();
		StringBuffer sb =new StringBuffer();
		System.out.println(end - start);
		sb.append("world");
		long start1 = System.currentTimeMillis();
		 // 拼接太费事
		sb.append("world");
		long end1 = System.currentTimeMillis();
		System.out.println(end1 - start1);
		 // 更快的
		StringBuilder sd = new StringBuilder();
		long start2 = System.currentTimeMillis();
		 // 拼接太费事
		sd.append("world");
		long end2 = System.currentTimeMillis();
		System.out.println(end2 - start2);
	}
	}
```

## 比较快的排序方式

- Arrays.sort(要排序的数组)默认是正序
- 也可以变成倒序，但是要是泛型数组就可以

```

		int[] a = {3,4,5,1,3,5,5};
		Arrays.sort(a);
		for (int i : a) {
			System.out.println(i);
		}
	
```

# 多线程

- 进程是程序对应的资源
- 线程是cpu运行的最小单位
- 线程是随机切换，一个程序中

## 启动线程

```

	package 项目实训;

	public class xiancheng {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		System.out.println(Thread.currentThread());

		Task1 task1 = new Task1();
		Thread t1 = new Thread(task1);
		t1.setName("第一个线程"); // 线程的名字
		t1.start(); // 线程开始
		new Thread(task1).start(); // 这种方式也可以进行线程启动
	}

	}
	class Task1 implements Runnable // 任务
	{

	@Override
	public void run() {
		// TODO Auto-generated method stub
		for (int i = 0; i <101; i++) {
		
			System.out.println(Thread.currentThread() + "@" +i);
		}
	}

	}

```

- 在做一件事的时候还是单线程比较快，多线程可以一起干很多事情，所以就相当于一个人和多个人的差距
- 意思就是单线程不一定比多线程慢，因为多线程存在上下文切换
- 首先分配cpu资源的单位是进程。一个进程所获得到的cpu资源是一定的。程序在执行的过程中消耗的是cpu，比如一个单核cpu，多个线程同时执行工作时，需要不断切换执行(上下文切换)，单个线程时间耗费更多了，而单线程只是一个线程跑。
- 多线程的总体执行时间和单线程是一样的，但是多线程中单个线程的执行时间是单线程的多倍。
  多线程提高的是并发数量，比如现在有一个4核cpu的服务器，同一时间可执行4个线程，这样处理线程任务的速度比较快。但是多出来的线程，5个，6个，7个，多出的线程还是要等待。

### 上下文切换

多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。

## 总结

所以说其实多线程不一定能够比单线程快是因为上下文切换，以及线程等待的问题
