---
title: 集合
date: 10/25/2022 1:45:07 PM 
categories: 日志
comments: "true"
---
# 泛型（任意引用类型） #
- 作用:就是可以让其内的变量无类型，直到用的时候才指定类型，解决了强制转换问题
- 代码如下：
```

			package 作业;
		
			public class gdg {
		
			public static void main(String[] args) {
				// TODO Auto-generated method stub
		
				sfdhkja<String> a = new sfdhkja(); // 尖括号里面的就是泛型的类型
				a.setName("小明");
				System.out.println(a.getName());
				System.out.println(a);
				sfdhkja<Integer> b = new sfdhkja();
				b.setName(11111);
				System.out.println(b.getName());
			}
		
		}
		class sfdhkja<E> {
			E name;
		
			public sfdhkja() {
				super();
				this.name = name;
			}
		
			public E getName() {
				return name;
			}
		
			public void setName(E name) {
				this.name = name;
			}
			
		}

```
## 接口 ##
### boolean add(E) ###
把任意对象类型加进list中
### iterator ###
返回集合的迭代器，用于遍历集合
### default修饰的 ###
代表接口中有方法体
### int size ###
### 并行流和串型流 ###
### Object toArray() ###
可以指定泛型的
### foreach ###
代码如下
```
		package 重新开始;
		
		import java.util.ArrayList;
		import java.util.Collection;
		import java.util.Iterator;
		
		public class jeiko {
		
			public static void main(String[] args) {
				// TODO Auto-generated method stub
		
				Collection<String> c1 =new ArrayList<>();
				c1.add("中国");
				c1.add("韩国哦");
				c1.add("hsakdj");
				System.out.println(c1.size());
				Iterator<String> ra = c1.iterator();
				while(ra.hasNext()) {
					String item = ra.next();
					System.out.println(item);
					ra.remove(); // 删除元素
				}
				System.out.println("-------------------------------");
				for (String string : c1) {
					System.out.println(string);
					
				}
				System.out.println("------------------------------------");
				c1.forEach(System.out::println);
				
			}
		
		}

```
- 只有第一种才可以进行便循环边删除
- 其他都不可以
- 但是第三种最帅，代码量也最少
# 讲解 #


- Colllection继承了Iterable接口
- list线性，有序集合
- set无序集合
- 旗下是
- ArrayLinst
- LinkedList
- Vector
- 下面是set的
- HashSet
- TreeSet
## List ##
- 线性集合 ，有下标
- add(index , E)
- set(index ,E)
- get(index)
```
		
		package 重新开始;
		
		import java.util.List;
		import java.util.Vector;
		
		public class Main1 {
		
			public static void main(String[] args) {
				// TODO Auto-generated method stub
		
				List<String> list = new Vector<String>();
				list.add("1");  // 先往list里添加元素
				list.add("12"); // 同上
				System.out.println(list);  // 直接打印是全部打印出来
				list.add(0,"121"); // 在下表为0的地方添加121
				list.set(2, "dhkjsdhj"); // 把下表为2的地方设置为dhkjsdhj
				System.out.println(list.size()); // 获取list的size就是大小
				
				list.forEach(System.out::println); // 超级帅气的循环语句，本身是lambal表达式
				for(int i =0; i < list.size() ; i++) {
					String item = list.get(i);
					System.out.println(item);
				}
				
			}
		
		}


```
### ArrayList ###
- 底层封装的数组
- 扩容的时候每次扩容一半
- 海量添加的时候是很慢的，就是修改长度很慢
- 查询快，因为有下标
### Vector ###
- 可控增量，且线程安全
- 底层是数组，且有线程锁，
- 10，20，40 ，每次扩容一倍，但是是可以控制增量的
- 比ArrayList慢
### LinkedList ###
- 底层封装的是节点，双向链表，每一个节点都有前一个节点和后一个节点的引用
- 单向链：修改快
- 双向链：就是双向的，前后都有元素
- 特点：修改快，但是查询慢
- 可以用作与自己定义栈
```

		class MyStack<E> {
			LinkedList<E> data;
			public E pop()  {
			return	data.pollLast();
				
			}
		}
```

## Set ##
- 无序集合
- 会自动去重，就是有重复的就会	不添加新的元素
```


		Set<Integer> set = new HashSet<Integer>();
		set.add(11);
		set.add(1111);
		set.add(898);
		set.add(11);
		set.forEach(System.out::println);

```
### HashSet ###
- 因为这里的去重机制是根据hashcode和equals来的，默认的时候，可以像正常的列表一样，但是我们可以进行覆盖hashcode和equals
- 不覆盖
```

			package 重新开始;
			
			import java.util.HashSet;
			import java.util.Set;
			
			public class Sst {
			
				public static void main(String[] args) {
					// TODO Auto-generated method stub
			
					Set<Integer> set = new HashSet<Integer>();
					set.add(11);
					set.add(1111);
					set.add(898);
					set.add(11);
					set.forEach(System.out::println);
					
					Set<stu> s1 =new HashSet<stu>();
					s1.add(new stu());
					s1.add(new stu());
					s1.add(new stu());
					System.out.println(s1.size());
				}
			
			}
			class stu{
				private int num;
				private String name;
				
				public stu() {
					super();
					// TODO Auto-generated constructor stub
				}
				public int getNum() {
					return num;
				}
				public void setNum(int num) {
					this.num = num;
				}
				public String getName() {
					return name;
				}
				public void setName(String name) {
					this.name = name;
				}
				@Override
				public String toString() {
					return "stu [num=" + num + ", name=" + name + "]";
				}
			}

```
- 覆盖之后

```

		package 重新开始;
		
		import java.util.HashSet;
		import java.util.Set;
		
		public class Sst {
		
			public static void main(String[] args) {
				// TODO Auto-generated method stub
		
				Set<Integer> set = new HashSet<Integer>();
				set.add(11);
				set.add(1111);
				set.add(898);
				set.add(11);
				set.forEach(System.out::println);
				
				Set<stu> s1 =new HashSet<stu>();
				s1.add(new stu());
				s1.add(new stu());
				s1.add(new stu());
				System.out.println(s1.size());
			}
		
		}
		class stu{
			private int num;
			private String name;
			
			public stu() {
				super();
				// TODO Auto-generated constructor stub
			}
			public int getNum() {
				return num;
			}
			public void setNum(int num) {
				this.num = num;
			}
			public String getName() {
				return name;
			}
			public void setName(String name) {
				this.name = name;
			}
			@Override
			public String toString() {
				return "stu [num=" + num + ", name=" + name + "]";
			}
			@Override
			public int hashCode() {
				final int prime = 31;
				int result = 1;
				result = prime * result + ((name == null) ? 0 : name.hashCode());
				result = prime * result + num;
				return result;
			}
			@Override
			public boolean equals(Object obj) {
				if (this == obj)
					return true;
				if (obj == null)
					return false;
				if (getClass() != obj.getClass())
					return false;
				stu other = (stu) obj;
				if (name == null) {
					if (other.name != null)
						return false;
				} else if (!name.equals(other.name))
					return false;
				if (num != other.num)
					return false;
				return true;
			}
			
		}

```
- 也可以在生成覆盖的时候少选几个变量这样这些变量就会变成唯一的筛选变量 ，相当于放宽变量范围
- 原理是封装了hashmap，利用key和value
