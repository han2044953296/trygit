---
title: SetTree
date: 10/26/2022 9:51:27 AM 
categories: 日志
comments: "true"
---
# TreeSet #
- 其是基于compareable的，
- 进行add的时候放的如果是引用类型，则要实现compareable接口，因为他就是用这个接口来实现的
- 对于基本类型，则不用
- 如果这样就会报错
```
		
		package 重新开始;
		
		import java.util.Set;
		import java.util.TreeSet;
		
		public class copyfilethread {
		
			public static void main(String[] args) {
				// TODO Auto-generated method stub
		
				Set<String> set = new TreeSet<String>();
				set.add("2020-10-19");
				set.add("1010-10-20");
				System.out.println(set);
				Set<stu> SET = new TreeSet<stu>();
				SET.add(new stu("小明" , 1));
				SET.add(new stu("snisnh" , 2));
				SET.add(new stu("狗蛋"  , 1));
				SET.forEach(System.out::println);
			}
		
		}
```

- stu类

```


		class stu {
			private int num;
			private String name;
			
			public stu( String name , int num) {
				this.name = name;
				this.num = num;
				// TODO Auto-generated constructor stub
			}
			
			public stu() {
				super();
				// TODO Auto-generated constructor stub
			}
			public int getNum() {
				return num;
			}
			public void setNum(int num) {
				this.num = num;
			}
			public String getName() {
				return name;
			}
			public void setName(String name) {
				this.name = name;
			}
			@Override
			public String toString() {
				return "stu [num=" + num + ", name=" + name + "]";
			}
			@Override
			public int hashCode() {
				final int prime = 31;
				int result = 1;
				result = prime * result + ((name == null) ? 0 : name.hashCode());
				result = prime * result + num;
				return result;
			}
			@Override
			public boolean equals(Object obj) {
				if (this == obj)
					return true;
				if (obj == null)
					return false;
				if (getClass() != obj.getClass())
					return false;
				stu other = (stu) obj;
				if (name == null) {
					if (other.name != null)
						return false;
				} else if (!name.equals(other.name))
					return false;
				if (num != other.num)
					return false;
				return true;
			}
		
			// 大于0是正数，小于0是负数 ，等于0是相等 ，
			
			
		}
```
- 这样会报错，是类型转换的错误。
- 因为它实现的是compareable接口，对比引用类型的时候用的是这个接口里的方法
- 所以在stu类实现这个接口就可以不报错了

```

		class stu implements Comparable<stu>{
			private int num;
			private String name;
			
			public stu( String name , int num) {
				this.name = name;
				this.num = num;
				// TODO Auto-generated constructor stub
			}
			
			public stu() {
				super();
				// TODO Auto-generated constructor stub
			}
			public int getNum() {
				return num;
			}
			public void setNum(int num) {
				this.num = num;
			}
			public String getName() {
				return name;
			}
			public void setName(String name) {
				this.name = name;
			}
			@Override
			public String toString() {
				return "stu [num=" + num + ", name=" + name + "]";
			}
			@Override
			public int hashCode() {
				final int prime = 31;
				int result = 1;
				result = prime * result + ((name == null) ? 0 : name.hashCode());
				result = prime * result + num;
				return result;
			}
			@Override
			public boolean equals(Object obj) {
				if (this == obj)
					return true;
				if (obj == null)
					return false;
				if (getClass() != obj.getClass())
					return false;
				stu other = (stu) obj;
				if (name == null) {
					if (other.name != null)
						return false;
				} else if (!name.equals(other.name))
					return false;
				if (num != other.num)
					return false;
				return true;
			}
		
			// 大于0是正数，小于0是负数 ，等于0是相等 ，
			@Override
			public int compareTo(stu o) {
			return 0;
			}
			
		}
```
- 但是这样他只能往set里添加一个值
- 因为这个compare默认的时候就是这样
- 如果要再进行精度筛选则要，在被覆盖的compareto方法中自己定义，可以改成
```

		public int compareTo(stu o) {
				// TODO Auto-generated method stub
				if(this.num == o.num) {
					return this.name.length() - o.name.length();
				} else {
					return this.num - o.num;
				}
			}

```
- 这样就会让如果学号相同，就会按照姓名的长度排序，小的在上面
- 总之就是可以在这个compareto这里设置规则
- 可控性强
- 这里只有数组的是length是属性，其他都是方法
- 集合的叫size
- 这个是用于实体类，数据类实现接口用 ， 表达的是自然的顺序，又叫自然排序
# 比较器 #
- 比较器是对于list来说的
- comparetor ：比较器，比上一个更自由 ，可以控制排序的方式，升序或者降序
```

		List<stu> list = new ArrayList<stu>();
		System.out.println("----------------------");
		list.add(new stu("下" , 1 , 89.1));
		list.add(new stu("下" , 2 , 88.1));
		list.add(new stu("下" , 21 , 87.1));
		list.add(new stu("下" , 22 , 86.1));
		list.add(new stu("下" , 21 , 85.1));
		list.add(new stu("下" , 221 , 84.1));
		list.add(new stu("下" , 21 , 83.1));
		list.add(new stu("下" , 21 , 82.1));
		
		Collections.sort(list , (a,b) -> -((int)(b.getScore() - a.getScore() * 100 ))); // 这个里面的代表 ， 我们的比较规则， 前面代表要排序的集合，list不去重 ， a,b代表两个元素list中的，后面的就是比较的规则了，一般是升序排序，但是我们可以通过添加-的方法，让他进行降序，他底层也是tree
		list.forEach(System.out::println);
```
- 通过lambal表达式进行比较排序
- 但是其实这个sort方法也是Arrays.sort，它是将所有元素转入一个数组，对数组进行排序，然后，将排好序 的序列复制回列表 ，
- sort()是根据需要排序的数组的长度进行区分的:
- 首先先判断需要排序的数据量是否大于60。
- 小于60：使用插入排序，插入排序是稳定的
- 大于60的数据量会根据数据类型选择排序方式：
- 基本类型：使用快速排序。「因为基本类型不需要考虑稳定性」
- Object类型：使用归并排序「因为归并排序具有稳定性」
- 注意：不管是快速排序还是归并排序。在二分的时候小于60的数据量依旧会使用插入排序
-  Collections.reverseOrder()也可以进行降序排序 , 只不过是要基本类型
# 映射Map #
- 是一种接口
- 是一种<k , V> 结构 ，就是一个key对应一个value，其key不会重复，而value可以重复
- 一个<Ｋ，V>叫一个ｅｎｔｒｙ
- 万能<Ｋ，V>他可以代表一个对象
## 方法 ##
- ｃｌｅａｒ清除所有映射
- ｂｏｏｌｅａｎ　ｃｏｎｔａｉｎｓＫｅｙ（Ｏｂｊｅｃｔ　ｋｅｙ）：判断一个ｋｅｙ是不是存在
- ｅｎｔｒｙＳｅｔ（）获取ｅｎｔｒｙ集合，就是条目集合
，返回类型是一个Ｓｅｔ
- ｇｅｔ（ｋｅｙ）根据ｋｅｙ获取ｖａｌｕｅ
- ｋｅｙＳｅｔ（）返回ｋｅｙ的集合
- ｐｕｔ（K，ｖ），往，ｍａｐ加入一条数据，但是存在相同的ｋｅｙ就覆盖
- ｒｅｍｏｖｅ（ｋ）删除ｋｅｙ
- ｓｉｚｅ（）条目个数
- Ｃｏｌｌｅｃｔｉｏｎ＜Ｖ＞　ｖａｌｕｅｓ（）获取值组成的集合
```
		package 重新开始;
		
		import java.util.HashMap;
		import java.util.Map;
		
		public class Main2 {
		
			public static void main(String[] args) {
				Map<String , String> map = new HashMap<>();
				map.put("akjsdhs", "sdjal");
				map.put("dshd" , "sdjjdjd");
				System.out.println(map.get("dshd"));
				System.out.println(map.containsKey("dshd"));
				System.out.println(map.remove("dshd"));
				System.out.println(map.size());
				System.out.println(map.entrySet());
				System.out.println(map.containsKey("dshd"));
				map.clear();
				System.out.println(map.size());
				
			}
		}
		

```
