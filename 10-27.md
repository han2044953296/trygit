---
title: Map
date: 10/27/2022 9:00:17 AM 
categories: 日志
comments: "true"
tag: java
---
# Map

- Map和集合是无关系的
- Map是个接口
- 旗下有hashMap和TreeMap
- 简单代码

```

		Map<String , String> map1 = new HashMap<>();
			map1.put("1", "事假");
			map1.put("2", "病假");
			map1.put("3", "产假");
			map1.put("2", "施加");
			Set<String> ks = map1.keySet();
			Iterator<String> it = ks.iterator();
			while(it.hasNext()) {
				String item = it.next();
				System.out.println("key" + item + "@value:" + map1.get(item));
			}
		

```

- entrySet

```

				Set<Map.Entry<String, String>> km = map1.entrySet();
				Iterator<Map.Entry<String, String>> il = km.iterator();

			
				while(il.hasNext()) {
				Entry<String , String> entry = il.next();
				System.out.println(entry.getKey() + entry.getValue());
				}

				for (Entry<String, String> entry : km) {
					System.out.println(entry.getKey() + entry.getValue());
				}

				km.forEach(new Consumer() {
				@Override
				public void accept(Object t) {
					// TODO Auto-generated method stub
					System.out.println(t);
				}}); // Consumer里面有个抽象方法 ，accept，我们要做的事情放进这个accept里，就代表对其每个元素进行accept里的操作 ，就是lambda的表达式
	

```

- 上述是两种遍历方式，迭代器可边遍历便删除，是我们最古老的，可是也是唯一有这个功能的 ，iterator
- 其他的都要遍历完了才能再删除
- 而且entrySet比keySet是要更快点的（单纯遍历）
- 迭代器的算法是要比后来的算法速度快的，遍历的时候

## lambda表达式

- lambda表达式是很便捷的一种方法
- 要求：定义规则，定义几个变量
- 首先，我们要定义一个接口

```

	interface Yunsuan{
		public int yunsuan(int i , int j);
	
	}

```

- 然后在这个接口上增加@FunctionalInterface ，注意这个标志是让这个接口只有一个抽象方法，多个抽象方法会报错
- 这一步是定义我们的，几个元素
- 接下来我们定义一个函数 ，让这个接口当作参数 ，并且给这个接口传入两个参数

```

		public static int getresult(int a , int b, Yunsuan yunsuan) {
			return	yunsuan.yunsuan(a, b);
			}

```

- 这样 ，我们就算是把这个规则实体化了，接下来我们只要调用这个规则的实例化，就可以对这两个数进行任意操作了
- 比如

```

		System.out.println(getresult(3,2, (i,j)->i+j)); // 前面两个是实参 ，后面的是规则就这样写就行 ，格式固定，但是语法不固定

```

- 上面的foreach里嵌套的就算lambda的表达式

# Map特殊事项

- 如果在map里把key放入引用类型，则对比key的操作会变成对比hashcode和equals，可控性更强

```


		package 重新开始;
	
		import java.util.HashMap;
		import java.util.Map;
	
		public class TEstmain1 {
	
			public static void main(String[] args) {
				// TODO Auto-generated method stub
	
				Map<stu , Object> map = new HashMap<>();
			
				map.put(new stu("小明"  , 1), 1);
				map.put(null , null);
				map.put(new stu("狗蛋" , 1) , 2);
				System.out.println(map.size());
				map.forEach((k , v) -> {System.out.println(k + "@" +v);});
			}
	
		}
```

- stu类，通过自动生成hashcode和equals，（我这里只生成了num的）

```

		class stu implements Comparable<stu>{
			private int num;
			private String name;
			private double score;
			public stu( String name , int num) {
				this.name = name;
				this.num = num;
				// TODO Auto-generated constructor stub
			}
			public stu( String name , int num , double m) {
				this.name = name;
				this.num = num;
				this.score = m;
				// TODO Auto-generated constructor stub
			}
		
			public stu() {
				super();
				// TODO Auto-generated constructor stub
			}
			public int getNum() {
				return num;
			}
			public void setNum(int num) {
				this.num = num;
			}
			public String getName() {
				return name;
			}
			public void setName(String name) {
				this.name = name;
			}
			@Override
			public String toString() {
				return "stu [num=" + num + ", name=" + name + ", score=" + score + "]";
			}
			@Override
			public int hashCode() {
				final int prime = 31;
				int result = 1;
				result = prime * result + num;
				return result;
			}
			@Override
			public boolean equals(Object obj) {
				if (this == obj)
					return true;
				if (obj == null)
					return false;
				if (getClass() != obj.getClass())
					return false;
				stu other = (stu) obj;
				if (num != other.num)
					return false;
				return true;
			}
	
			// 大于0是正数，小于0是负数 ，等于0是相等 ，
			@Override
			public int compareTo(stu o) {
				// TODO Auto-generated method stub
				if(this.num == o.num) {
					return this.name.length() - o.name.length();
				} else {
					return o.num - this.num;
				}
			}
	
			public double getScore() {
				return score;
			}
	
			public void setScore(double score) {
				this.score = score;
			}
		
		}
```

# lambda加for循环 加上TreeMap

- 通过treeMap实现

```


		package 重新开始;
	
		import java.util.HashMap;
		import java.util.Map;
		import java.util.TreeMap;
	
		public class TEstmain1 {
	
			public static void main(String[] args) {
				// TODO Auto-generated method stub
	
			
				TreeMap<stu , Object> map11 = new TreeMap();
				map11.put(new stu("小明",  1), 1);
				map11.put(new stu("狗蛋" ,  2) ,2);
				map11.put(new stu("linux" , 3), 3);
				map11.put(new stu("狗蛋" ,  2) ,99);
				map11.forEach(TEstmain1::abc);
			}
	
			public static void abc(stu s , Object value) {
				System.out.println(s + "@" +value);
			}
		}


```

- 上述的是针对foreach有两个参数的情况，可以定义一个函数，让他去传递参数，和lambda一样
