---
title: shell
date: 11/2/2022 12:08:22 PM 
categories: 日志
comments: "true"
---

# shell #
- 文件命名 ： 结尾一般以.sh结尾
- 不要编译 
- 文件第一行 ，一般写一个编辑器 ，就比如：#！bin/bash
- 编写脚本
- 添加权限
- chmod添加权限
## 运行 ##
- sh ./xxx.sh（脚本名字）
- 如果给予了执行权限就可以直接执行
- debug
- 在 #！bin/bash 后面加一个 -x
- 就可以看见程序运行的过程
- 还可以用 sh -x xxx脚本名字
# 在shell里定义变量以及引用 #
- 用read xx xx xx ：代表要从键盘输入3次，以空格分割 ， 如果要在自变量里面定义空格可以用 "xxx xxx" 这样就可以当成一个变量输入了
- key=value ： 定义变量
- 等号前后不能有空格
- 引用变量则用$xxx（变量的名字）
- 但是其中有单引号和双引号和反引号的区别
- 如果是单引号和双引号都是默认定义成字符串
- 如果是反引号`` 里面的会被解释成系统命令，并且执行
- 引用变量一般是要通过${} 而不是$
- 因为如果要拼接字符串的时候 ，我们就可以${name}xxxx（要拼接的内容）
## 特殊的命令 ##
- 如果要在里面定义参数 ， 则$1代表脚本的第一个需要输入的参数 ， $2 ,$3...要第二个第三个。。。
- 而$0 :获取当前的文件名字
- $? : 返回执行之后的状态 ： 0是正常执行 ， 非0是错误
- $*代表所有传入的内容
- $#代表传入的数量
- $$代表是当前进程的进程号
- $@把传入的参数作为一个字符串输出，但是里面仍然认为由多个字符串而$*则是认为他只有一个字符串
- 转义字符 ： 和c一样
- 定义数组 ： arr=（zs lis ww zl wrm）
- 获取数组里的元素 ： ${arr[*]} :这个是获取所有的 。 
- 但是这个里面不能由；
- 如果要查看单个和java里一样，把【】中的换成从0开始的数字
- 代表查看数组里的元素个数 ： `${井号arr[*]}`
- 两种括号的形式
- 由子shell执行 ，不会影响到这个shell ```（）```
- 由当前shell执行 ，会影响到这个shell ```{}```
- 权限判断：
-  `-r` ：读权限
-  `-w` ：写权限
-  `-x` ：执行权限
-  `-e` ：文件是不是存在
-  `-d` ：是不是目录
-  `-f` ：是不是文件
-  `-c` ：是不是字符设备
-  `-b` ：是不是块设备
-  `-s` ：文件是不是非空
-  `-l` ：符号连接
## 对变量以及字符串的操作 ##
- `${num:-val}` : 若num存在则是num , 要不然就是val
- `${num!=val}` : 如果num存在，则是num 要不然就是val 且将num赋值为val
# 流程控制 #
- `if else`
- `if condition(条件判断);then`
- `command`
- `else`
- `command`
- `fi` 
- `condition` ： [] 比如：[ 1 == 2 ] 变量以及判断符号前后有空格
- 值判断 ：
- 常规的都可以用
- `=` 等于
- `==`等于
-  `-ne` 数值不等
-  `-eq` 数值相等
-  `-gt` 大于
-  `-ge` 大于等于
-  `-le` 小于等于
-  `-lt` 小于
- `if con; then`
- `command`
- `elif con; then`
- `com`
- `....`
- 后面`elif`可以无限加
- 同时也有`break`和`countinue`
## 与或非 ##
- 与 `||`
- 或 `&&`
## for循环 ##
- `for var in con1 con2 con3`
- `do`
- `程序段`
- `done`
- `for((i=0;i<10;i++))`
- `do`
- `程序段`
- `done`
## while ##
- `while【con】`
- `do`
- `程序段`
- `done`
## until ##
- `until【con】`
- `do`
- `程序段`
- `done`
- 这个和`while`相反 ，条件为错，一直执行
- 上述的程序段中可以用let i++等
- 这个`con`可以应用（（））或者中括号都行
## case ##
- `case $变量名 in`
- `"值 1"）`
- `如果变量的值等于1 ，则执行程序1`
- `；；`
- `"值 2"）`
- `如果变量的值等于2 ，则执行程序2`
- `；；`
- `。。。还可以衔接很多的`
- `*)`
## 对字符串的操作 ##
- 字符串的长度 ： `${井号xxx}`
- 从下标n处开始进行提取 ： `${xxx:n}`
- 从下表为n处提取m个 ： `${xxx:n:m}`
- 用new替换xxx中出现的第一个mm ： `${xxx/mm/new}`
- 用new替换xxx中出现的所有mm ： `${xxx//mm/new}`
- IFS变量进行字符串分割
- 
# 定义函数 #
- 函数名（）{}
- fnction 函数名（）{}
- 函数的返回值可以应用return来进行结束
# shell分析工具 #
- cut ：剪
- cut[选项参数] filename
-  `-f` 列号，第几列
-  `-f 2 `：代表第二列
-  `-f 2-` ：代表第二列之后的所有
-  `-d` 分隔符，按照指定的分隔符分割列，默认是\t
-  `-c` 按照字符切割 后面夹n表示第几列 如-c1
- `awk` : 文本分析工具 或者叫 gawk
- `awk[选项参数] '/pattern1{action1} /pattern2/{action2}...' (filename)`
- 选项参数
-  `-F` ：指定输入文件分隔符
-  `-v` ：赋值一个用户自己定义的变量
- 打印第一和第二列 ： `awk '{print $1，$2}' （filename）`
- awk一般和cat联用 ： `cat xxx | awk '{print $1，$2}'`
- 也可以这样 ： `cat xxx | awk '{print $1","$2}'` : 这样代表会让其中两列用，分割的形式表示出来
- 还可以加上 ：`cat xxx | awk 'BEGINH{print xxx}{print $1","$2}END{print mmm}'` ：就会在开始及结束的时候分别加上xxx和mmm
-  `-f` 则是执行脚本
-  还可以 `cat xxx | awk -v i=1 -F ":" '{print $3 +i}'` :代表xxx文件的由：分割的第3列都加一在输出
-  内置变量
-  `FILENAME` ：文件名
-  `NR` ： 已读的记录数（行号）
-  `NF` ： 浏览记录的域的个数（切割后的列的个数）
- 获取第一行 `cat xxx | awk 'NR==1{print}'`
- 里面的条件==可以换成  > < >= <=
- 
- `sed` : 文本替换(回去自己查)
- 把文本中 d 替换成 m ,每行第一次遇见a才会替换
- `sed -i 's/d/m/'` xxx文件名
- 全文替换
- `sed -i 's/d/m/g'` xxx文件名
- 把值路径替换成/root
- `sed -i 's//fata/spark//root` xxx文件'
- 不过会爆错
- 不过加上\就对了
- `sed -i 's\/fata\/spark\/root'` xxx文件'
- `sed -i 's#/root#/data/spark#g'` xxx文件
# 正则表达式 #
- 模糊式的匹配搜索
- pattern
- 最简单的正则 ： 直接给一个关键字 就是grep的时候
- 特殊字符
- ^作为一行的开头 ：比如^a 代表以a开头
- $作为一行的结束 ：比如n$ 代表以n结尾
- 正则可以多种一起应用
- 比如 ^$代表空行
- grep -n显示行号
- 通配符 ： . 代表匹配一个任意的字符
- 比如 ： r..t :代表r和t中间有两个字符的
- 特殊字符 ： * ：代表一个字符出现任意次数
- 比如 o* 代表o出现任意次数
- .*则表示任意一个字符出现任意次数 ，甚至可以匹配空字符串
- 于是可以和上面的联用 ： ^a.*b$
- 代表以a开头 b结尾 中间任意字符的
- 字符区间：
- []表示匹配其中范围内的字符
- 比如[0-9]* ：任意长度的数字
- [0,7] : 0或7
- 还可以这样写 ： [a-c , b-f]
- [ab]* ：代表任意以ab组成的 比如 ：aab
 abb 等
- 转义字符 \
- 当我们要搜索$等关键字的时候
- 要'反斜杠$' :表示转义 ，才可以用做搜索
## 例子 ##
- 匹配手机号
- `^1[345678][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$`
-  `^1[345678][0-9]{9}$`
-  但是下面的花括号是扩展
-  要用`grep -E ^1[345678][0-9]{9}$ `才可以
-  但是上面的最开始的是都可以支持的
-  