---
title: 数据可视化
date: 12-08 8.53 
categories: 日志
comments: "true"
tag: xxl
---
# 数据可视化的数据库选择

一般选择响应数据库比较快的一般是 秒级，或者毫秒级 ： 不要选择hive

因为hive太慢

我们一般都把数据最后导入到mysql里

作业：

自己做一个dashboard

# xxl

定时任务调度

就是按照每天都要做的任务

* crontab 进行 用的比较少 而因为不方便
* 定时任务的调度的框架
  * ozio , azkaban,airflow,xxl,dolphinscheduler
  * 现在ozio 和 azkaban 因为操作比较反人类，所以不太推荐
  * airflow ： 通过python进行任务调度的
  * 公司首选 dolphinscheduler ，其次 xxl
* 针对 xxl 或者 dolphinscheduler 可以串联的方式进行执行调度，就是a任务完成，直接执行b任务等等
* 但是crontab它要设置时间间隔，不可以串联的方式进行执行
* 多任务之间的依赖关系 ：
  * DAG 有向无环图
* xxl 官网 ： 国人开发的 `https://github.com/xuxueli/xxl-job`
  * 架构：主从架构，分布式架构
  * 老大：调度中心
  * 小弟：调度器
* 其他的都是apache的

## 部署

下载源码 ；

导入idea 进行编译

初始化“调度数据库”xxl源数据库 -》 mysql中

首先在mysql中执行语句

```
#
# XXL-JOB v2.4.0-SNAPSHOT
# Copyright (c) 2015-present, xuxueli.

CREATE database if NOT EXISTS `xxl_job` default character set utf8mb4 collate utf8mb4_unicode_ci;
use `xxl_job`;

SET NAMES utf8mb4;

CREATE TABLE `xxl_job_info` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `job_group` int(11) NOT NULL COMMENT '执行器主键ID',
  `job_desc` varchar(255) NOT NULL,
  `add_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `author` varchar(64) DEFAULT NULL COMMENT '作者',
  `alarm_email` varchar(255) DEFAULT NULL COMMENT '报警邮件',
  `schedule_type` varchar(50) NOT NULL DEFAULT 'NONE' COMMENT '调度类型',
  `schedule_conf` varchar(128) DEFAULT NULL COMMENT '调度配置，值含义取决于调度类型',
  `misfire_strategy` varchar(50) NOT NULL DEFAULT 'DO_NOTHING' COMMENT '调度过期策略',
  `executor_route_strategy` varchar(50) DEFAULT NULL COMMENT '执行器路由策略',
  `executor_handler` varchar(255) DEFAULT NULL COMMENT '执行器任务handler',
  `executor_param` varchar(512) DEFAULT NULL COMMENT '执行器任务参数',
  `executor_block_strategy` varchar(50) DEFAULT NULL COMMENT '阻塞处理策略',
  `executor_timeout` int(11) NOT NULL DEFAULT '0' COMMENT '任务执行超时时间，单位秒',
  `executor_fail_retry_count` int(11) NOT NULL DEFAULT '0' COMMENT '失败重试次数',
  `glue_type` varchar(50) NOT NULL COMMENT 'GLUE类型',
  `glue_source` mediumtext COMMENT 'GLUE源代码',
  `glue_remark` varchar(128) DEFAULT NULL COMMENT 'GLUE备注',
  `glue_updatetime` datetime DEFAULT NULL COMMENT 'GLUE更新时间',
  `child_jobid` varchar(255) DEFAULT NULL COMMENT '子任务ID，多个逗号分隔',
  `trigger_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '调度状态：0-停止，1-运行',
  `trigger_last_time` bigint(13) NOT NULL DEFAULT '0' COMMENT '上次调度时间',
  `trigger_next_time` bigint(13) NOT NULL DEFAULT '0' COMMENT '下次调度时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE `xxl_job_log` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `job_group` int(11) NOT NULL COMMENT '执行器主键ID',
  `job_id` int(11) NOT NULL COMMENT '任务，主键ID',
  `executor_address` varchar(255) DEFAULT NULL COMMENT '执行器地址，本次执行的地址',
  `executor_handler` varchar(255) DEFAULT NULL COMMENT '执行器任务handler',
  `executor_param` varchar(512) DEFAULT NULL COMMENT '执行器任务参数',
  `executor_sharding_param` varchar(20) DEFAULT NULL COMMENT '执行器任务分片参数，格式如 1/2',
  `executor_fail_retry_count` int(11) NOT NULL DEFAULT '0' COMMENT '失败重试次数',
  `trigger_time` datetime DEFAULT NULL COMMENT '调度-时间',
  `trigger_code` int(11) NOT NULL COMMENT '调度-结果',
  `trigger_msg` text COMMENT '调度-日志',
  `handle_time` datetime DEFAULT NULL COMMENT '执行-时间',
  `handle_code` int(11) NOT NULL COMMENT '执行-状态',
  `handle_msg` text COMMENT '执行-日志',
  `alarm_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '告警状态：0-默认、1-无需告警、2-告警成功、3-告警失败',
  PRIMARY KEY (`id`),
  KEY `I_trigger_time` (`trigger_time`),
  KEY `I_handle_code` (`handle_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE `xxl_job_log_report` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `trigger_day` datetime DEFAULT NULL COMMENT '调度-时间',
  `running_count` int(11) NOT NULL DEFAULT '0' COMMENT '运行中-日志数量',
  `suc_count` int(11) NOT NULL DEFAULT '0' COMMENT '执行成功-日志数量',
  `fail_count` int(11) NOT NULL DEFAULT '0' COMMENT '执行失败-日志数量',
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `i_trigger_day` (`trigger_day`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE `xxl_job_logglue` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `job_id` int(11) NOT NULL COMMENT '任务，主键ID',
  `glue_type` varchar(50) DEFAULT NULL COMMENT 'GLUE类型',
  `glue_source` mediumtext COMMENT 'GLUE源代码',
  `glue_remark` varchar(128) NOT NULL COMMENT 'GLUE备注',
  `add_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE `xxl_job_registry` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `registry_group` varchar(50) NOT NULL,
  `registry_key` varchar(255) NOT NULL,
  `registry_value` varchar(255) NOT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `i_g_k_v` (`registry_group`,`registry_key`,`registry_value`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE `xxl_job_group` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `app_name` varchar(64) NOT NULL COMMENT '执行器AppName',
  `title` varchar(12) NOT NULL COMMENT '执行器名称',
  `address_type` tinyint(4) NOT NULL DEFAULT '0' COMMENT '执行器地址类型：0=自动注册、1=手动录入',
  `address_list` text COMMENT '执行器地址列表，多地址逗号分隔',
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE `xxl_job_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(50) NOT NULL COMMENT '账号',
  `password` varchar(50) NOT NULL COMMENT '密码',
  `role` tinyint(4) NOT NULL COMMENT '角色：0-普通用户、1-管理员',
  `permission` varchar(255) DEFAULT NULL COMMENT '权限：执行器ID列表，多个逗号分割',
  PRIMARY KEY (`id`),
  UNIQUE KEY `i_username` (`username`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE `xxl_job_lock` (
  `lock_name` varchar(50) NOT NULL COMMENT '锁名称',
  PRIMARY KEY (`lock_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

INSERT INTO `xxl_job_group`(`id`, `app_name`, `title`, `address_type`, `address_list`, `update_time`) VALUES (1, 'xxl-job-executor-sample', '示例执行器', 0, NULL, '2018-11-03 22:21:31' );
INSERT INTO `xxl_job_info`(`id`, `job_group`, `job_desc`, `add_time`, `update_time`, `author`, `alarm_email`, `schedule_type`, `schedule_conf`, `misfire_strategy`, `executor_route_strategy`, `executor_handler`, `executor_param`, `executor_block_strategy`, `executor_timeout`, `executor_fail_retry_count`, `glue_type`, `glue_source`, `glue_remark`, `glue_updatetime`, `child_jobid`) VALUES (1, 1, '测试任务1', '2018-11-03 22:21:31', '2018-11-03 22:21:31', 'XXL', '', 'CRON', '0 0 0 * * ? *', 'DO_NOTHING', 'FIRST', 'demoJobHandler', '', 'SERIAL_EXECUTION', 0, 0, 'BEAN', '', 'GLUE代码初始化', '2018-11-03 22:21:31', '');
INSERT INTO `xxl_job_user`(`id`, `username`, `password`, `role`, `permission`) VALUES (1, 'admin', 'e10adc3949ba59abbe56e057f20f883e', 1, NULL);
INSERT INTO `xxl_job_lock` ( `lock_name`) VALUES ( 'schedule_lock');

commit;


```

然后再把从GitHub上下载的文件夹用idea打开进行编译

进行配置我们的web端口以及数据库：在application.properties文件中，然后配置一下

配置好之后maven，之间打成jar包，然后上传到linux服务器上

运行java -jar 上传的文件的路径

然后会报错，就创建个文件夹就好了 `mkdir -p /data/applogs/xxl-job`

使用su 进行用户切换

然后通过chown 进行修改组以及用户 `chown -R hadoop:hadoop /data`

然后再次运行就可以了

然后在调度器管理页面添加调度器，然后分配任务就可以了

# 钉钉报警

钉钉机器人可发送的类型

* 文本
* 链接
* markdown
* actioncard
* feedcard

weget  ： 从互联网上下载的时候用的 ： 下载安装包 ，但是占用网络资源较大，且会一直重复下载直到结果成功，所以占用的资源较大

curl ： 发送请求的，发送网页请求访问的，也可以进行下载

* -o ： 把访问的一个页面存储到文件里

机器人发送消息

```
curl '机器人的token'
-H 'Content-type:application/json'
-d '{"msgtype" : text}'
```

需求 ：

* 日志数据 ： hdfs 上 linux user_click.log
* 例子： u01,鼠标,ios

```
u01,鼠标,ios
u01,鼠标,ios
u01,鼠标,ios
u01,鼠标,ios
u01,鼠标,ios
u02,键盘,android
u02,键盘,android
u02,键盘,android
u02,键盘,android
u03,显示器,ios
u04,托特包,ios
```

* 业务数据 ：mysql user_info

```
u01,子航
u02,祖安
u03,海哥
u04,轩轩
```

统计：

uid ， name ，sku ， os 每个用户点击商品的次数

```
select bianhao,shop_name,caozuoxit,count(*) as cishu from user_click1 group by bianhao,shop_name,caozuoxit;
```

取出表中重复数据，的次数做个排序

```
select shop_name,caozuoxit,name,row_number() over (partition by name) as rm from (
select * from user_click1 left join user_info on user_click1.bianhao=user_info.bianhao
) as king
```

不重复字段标识为1

```
u01,子航,鼠标,ios 1
u01,子航,鼠标,ios 2
u01,子航,鼠标,ios 3
u04,托特包,ios 1
```

统计表中不重复的数据，一起做排序，但是对于重复数据它还是对自己排序

```
select name,caozuoxit,shop_name,row_number() over(partition by cishu) from (
select * from user_click1 left join (
select bianhao,count(*) as cishu from user_click1 group by bianhao,shop_name,caozuoxit
) as count_click on count_click.bianhao=user_click1.bianhao
left join user_info on count_click.bianhao=user_info.bianhao  
) as ds;
上述是取巧的方法
下面是正经的方法
select count_clickbianhao,name,caozuoxit,shop_name,row_number() over(order by cishu) as rm from (
select * from user_click1 left join (
select bianhao as count_clickbianhao,count(*) as cishu from user_click1 group by bianhao,shop_name,caozuoxit
) as count_click on count_click.count_clickbianhao=user_click1.bianhao 
left join user_info on count_click.count_clickbianhao=user_info.bianhao  
) as jj where cishu = 1 
union all
select count_clickbianhao,name,caozuoxit,shop_name,row_number() over(partition by (name,caozuoxit,shop_name,cishu)) from (
select * from user_click1 left join (
select bianhao as count_clickbianhao,count(*) as cishu from user_click1 group by bianhao,shop_name,caozuoxit
) as count_click on count_click.count_clickbianhao=user_click1.bianhao 
left join user_info on count_click.count_clickbianhao=user_info.bianhao  
) as j where cishu != 1;
```

整个流程使用xxl进行调度

最后结果导入到mysql

数据导入mysql保证幂等性
