---
title: 云原生教学视频
date: 12-10 8.53 
categories: 云原生（哔哩哔哩）
comments: "true"
tag: 云原生
---
# 云原生

理解 ： 理解上要把他们拆开理解会更好

云 ：云基础设施（cloud）

原生：native ：在云计算平台里可以原生的计算和运行的

云原生的概念由来：
2013年被prvoyal公司的Ms提出

2015年谷歌带头成立了云原生的计算基金会

云原生的定义 ：

基于微服务原理而开发的应用，用容器的方式打包，在运行时，容器由运行于云基础设施之上的平台进行调度，应用开发采用持续交付和devOps实践

2015年：容器化封装+自动化管理+面向微服务

2018年：容器化封装+面向微服务+服务网格+声明格式API

云原生有利于各种组织在共有云，私有云和混合云等新动态环境中，构建和运行可扩展性的应用

微服务 ：把原有的单体应用拆分为多个独立自治的组件，每个组件都可以独立开发，设计，测试，运维，部署，这个组件可以单独的对外进行服务，我们称其为微服务

容器化：docker容器，容器属于it基础设施层概念，是比虚拟机更轻量化的隔离工具，是微服务的最佳载体

使用k8s的资源调度与容器编排，可以实现docker容器更优管理，进一步实现其PaaS能力

服务网格

服务网格存在的目的，就是中心化的服务治理框架

以往需要对微服务或者对api接口区做治理和管理请求

不可以改变基础设施指的是镜像：日后如果想再次改变他的部署，可以用镜像进行改变

应用部署：命令行：声明式

DevOps

借助云原生的相关技术，DevOps的时代才到来

云原生的最佳实现的实现三个层面

服务编排要实现计算资源弹性化

服务构建和部署要实现高可用

实践驱动基础设施标准初始化

云原生应用的领域

云原生的生态也已经覆盖到了，大数据，人工智能，边缘计算，区域局等领域

云原生的编排以及管理

编排与调度k8s

原生调用grpc

服务代理envoy

api网关apisix

服务网格istio

服务发现coreDns

消息和流式处理kafka

Severless ：只是对服务器的关心比较少，并不是完全无服务器

自动化配置：ansible

数据库：不赘述了

容器镜像仓库：harbor

定义及镜像制作：helm

密钥管理：spiffe

存储技术：ceph

网络技术：calico

监控分析：prometheus

等

# 4步制作超级精简的大厂docker镜像

## 什么是镜像

镜像是：分层联合文件系统

一种轻量级，可执行的独立软件包

镜像大小：有大有小

曾经网易蜂巢logo镜像只有585B

`docker pull hub.c.163.com/public/logo`

精简docker镜像的优势

减少构建时间

减少磁盘使用量

减少下载时间

提高安全性

## 镜像的分层原理

doccker镜像的分层

第一层：本机的系统

第二层：镜像上安装的虚拟环境比如：python

第三层：打的补丁文件

`docker pull busybox:latest`

拉下来之后我们对它进行多层的镜像,进行演示一遍

拉下来之后随便找个地方创建个文件叫dockerfile

```

FROM busybox
RUN mkdir /tmp/foo
RUN dd if=/dev/zero of=/tmp/foo/bar bs=1048576 count=100
RUN rm /tmp/foo/bar
EOF
```

上面这个是设置swap的交换分区的代码，count后面跟着的是字节数，bs是每秒的吞吐量

然后同步到docker容器上并执行这个文件 `docker build -t busybox:text . `这个语句的意思是根据本地镜像，加上我们的文本语句，进行创建我们的一个新的docker镜像，后面的.代表这个文件夹里所有的文本文件，也可以单独指明是哪一个文本文件

运行之前

```shell
[root@VM-8-16-centos dockerfile]# docker images | grep busybox
busybox                     latest    334e4a014c81   4 days ago      4.86MB

```

运行之后

```shell
[root@VM-8-16-centos dockerfile]# docker images | grep busybox
busybox                     text      efa9b412f2f7   4 minutes ago   110MB
busybox                     latest    334e4a014c81   4 days ago      4.86MB
```

这个新的镜像是基于我们之前的busybox进行创建的，而且执行了上面的分区文件

我们通过代码查看一下我们的容器代码情况 通过 `docker inspect busybox:容器的标识`

容器的标识就是 TAG

```bash
REPOSITORY                  TAG       IMAGE ID       CREATED             SIZE
busybox                     text      efa9b412f2f7   About an hour ago   110MB
busybox                     latest    334e4a014c81   4 days ago          4.86MB
gitlab/gitlab-ce            latest    08f00af277b7   5 days ago          2.79GB
hub.c.163.com/public/logo   latest    6fbdd13cd204   6 years ago         585B
```

然后我们分别查看一下text和latest的代码情况，我们查看最后的layter有几层

`docker inspect busybox:text`

```shell
"Layers": [
                "sha256:98004ed6104b2f4cc21559ea6e4a742ebf6731e37b5d1b04013ca68862749ba3",
                "sha256:c7a7aa6d1d87d0af266545bb8a56bdedfc79a14be948c092900ffb841c919c87",
                "sha256:88d1f859f65e27bca2996107976f04ed974c062b507b33b2388b2228b5d80122",
                "sha256:8e9b239d68ef8acc6fe2b2a82c7c803a79f0bdc5bf200b6d35fc2b062de24963"
            ]
```

`docker inspect busybox:latest`

```shell
 "Layers": [
                "sha256:98004ed6104b2f4cc21559ea6e4a742ebf6731e37b5d1b04013ca68862749ba3"
            ]
        },

```

简单来说，一个run就是一层

## 制作精简镜像

但是我们如何精简镜像呢，就像上述所说，仅仅用了三个命令，就多了100m

而且docker最多只有127个run

接下来我们来制作一个精简的redis的docker镜像

先创建一个dockerfile2文件在文件中输入

```shell
FROM 192.168.5.160/library/ubantu:trusty
ENV VER    3.0.0
ENV TARBALL http://download.redis.io/releases/redis-$VER.tar.gz
RUN apt-get update
RUN apt-get install -y curl make gcc
RUN curl -L $TARBALL | tar zxv
WORKDIR redis-$$VER
RUN make
RUN make install
WORKDIR /
RUN apt-get remove -y --auto-remove curl make gcc
RUN apt-get clean
RUN rm -rf /var/lib/apt/lists/* /redis-$$VER

```

save 和 export

导出的区别 ：

export 导出的包括的东西更多一点，它有压缩功能，保留历史层，有历史层的可以进行回滚操作 ;算是导出容器，

容器相当于镜像加个读写层

save 导出的仅仅是镜像，不保留历史层

但是下完之后是300多M有点大

我们对他进行缩小

缩小的方式

用更小的基础镜像 `debain`

如下

```
FROM 192.168.5.160/library/debain:jessie
ENV VER    3.0.0
ENV TARBALL http://download.redis.io/releases/redis-$VER.tar.gz
RUN apt-get update
RUN apt-get install -y curl make gcc
RUN curl -L $TARBALL | tar zxv
WORKDIR redis-$$VER
RUN make
RUN make install
WORKDIR /
RUN apt-get remove -y --auto-remove curl make gcc
RUN apt-get clean
RUN rm -rf /var/lib/apt/lists/* /redis-$$VER
```

成功之后会发现少了很多的空间

然后再进一步瘦身
把dockerfile里的命令串联起来

如下

```

FROM 192.168.5.160/library/debain:jessie
ENV VER    3.0.0
ENV TARBALL http://download.redis.io/releases/redis-$VER.tar.gz
RUN apt-get update && \
apt-get install -y curl make gcc && \
curl -L $TARBALL | tar zxv && \
WORKDIR redis-$$VER && \
make && \
make install && \
WORKDIR / && \
apt-get remove -y --auto-remove curl make gcc && \
apt-get clean && \
rm -rf /var/lib/apt/lists/* /redis-$$VER
```

通过串联命令编排之后的镜像体积比不编排的能小上一半左右

压缩镜像 ： 但是有时候并不会好使，但是能压缩多少就压缩多少吧，对一个外来镜像进行压缩的时候，可能会比较明显

`docker save 镜像的名字 | docker-squash -verbose -t 生成的镜像的名字 | docker load 这个对mac不好使，再linux可以`

使用容器专用的基础镜像 —— scratch 或者busybox作为基础镜像

上面两个是空镜像，所以我们可以把docker里的程序文件拿出来，打包成gz的压缩包

然后再用空镜像再次生成一个容器，进行极致的压缩

这种方式进行的docker容器对于redis而言，会被压缩到个位数的空间，而且可以正常运行

dockerfile

```
FROM scratch
ADD 压缩的文件及其依赖 /
COPY redis.conf /etc/redis/redis.conf
EXPOSE 6379
CMD ["usr/local/bin/redis-server"]
 ENTRYPOINT ["docker-entrypoint.sh"]
```

其中压缩的文件是从debain上搞来的依赖，以及redis的包一起打的压缩

EXPOSE ：设置的是端口

查询依赖的方式，通过 ldd 查出所需要的.so文件

然后把所以依赖都打包成tar或者gz文件，用scratch

至于如何获取空镜像，我们可以通过官网命令 `tar cv --files-from /dev/null | docker import - scratch`

就会自动获取了

实操

首先拉去空镜像

对于已经拉去过空镜像的同学就不用了

```
tar cv --files-from /dev/null | docker import - scratch
```

拉去之后找到我们的模板机

然后进入我们的模板机里 `docker exec -it 名字 /bin/bash`

然后找到我们的程序比如我找的是redis-server

然后我们找到之后通过ldd命令查看他的依赖 `ldd redis-srever`

查看到依赖之后把文件夹结构以及文件都弄出来，通过cp命令 ` docker cp 模板机的名字:文件路径 宿主机的路径`

然后我们把所有的文件，都打包成一个tar.gz `tar -zxcf 生成的文件名（带tar.gz的） 打包的内容的路径`

然后我们编辑dockerfile文件如下

```
FROM scratch #从什么镜像中创建
ADD 压缩的文件及其依赖 / # 通过ADD可以把文件自动解压
COPY redis.conf /etc/redis/redis.conf #redis 的配置文件
EXPOSE 6379 #端口号
CMD ["usr/local/bin/redis-server"] #这个相当于解释器，要用的
```

然后执行 `docker build -t 生成的容器的内容 -f dockerfile`

构建容器，最后成功之后，通过 `docker run -d --name 你的image的名字 你自己起的名字 `

然后就运行成功了

我们通过docker images

查看一下存储大小如下 ：

```
redis-01           latest    c654e9a88af9   13 minutes ago   22.3MB
scratch            latest    89a161411e52   2 hours ago      0B
busybox            latest    334e4a014c81   4 days ago       4.86MB
redis              latest    3e12e2ceb68f   5 days ago       117MB
gitlab/gitlab-ce   latest    08f00af277b7   5 days ago       2.79GB
```

如上所属，redis-01 是我们自己创建的，redis是官方提供的

差距显而易见

## 构建企业debian 10 基础测试镜像
