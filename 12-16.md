---
title: kafka
date: 12-16 8.40
categories: 日志
comments: "true"
tag: kafka
---
MQ:消息中间件

* java -》 rabbitMq kafka
* 大数据 -》 kafka，pular ， solar

# kafka：

* 在cdh平台叫cdk

官网：kafka.apache.org

他是一个流式的分布式平台，构建实时的数据通道，流式数据分析，流式的app

实时处理/流式处理

离线处理/批处理

消息中间件：

* 消息：event-》事件-》数据
* 数据存储的地方：中间件

kafka的特性

* 高吞吐量
* 可扩展性：支持分布式
* 永久性存储 ：有数据过期时间
* 高可用

kafka的特点：

* 读写（发布和订阅）
* 存储流式的数据
* 可以进行数据的处理
  * 正常的kafka处理，是在它后面接一个实时处理的框架 spark/fink
  * kafkaStreaming ：是kafka自带的专门处理数据的功能（性能：以及数据的丢包什么的差距会比较大）

部署：kafka的版本要选择

* apache
* cdk

一般选择稳定版，最新版bug多

还可以根据后面的框架选择 ：根据sparkStreaming 来选择kafka的版本 ： spark对kafka的最低的版本是0.10.0 （目前3.x的spark）

kafka：

* 0.10之后都可以

kafka用的是scala写的

kafka2.8版本bug多，因为2.8版本做了个尝试，就是抛去zk，但是尝试失败了，最终出现多个bug

我们目前用2.2.1的版本

kafka的架构：

* 生产者 ： producer 发送数据的
* kafka ：broker 真正是属于卡夫卡的，其余是不属于kafka的组件的
* 消费者 ：customer 取出数据 ，但是数据并不会传出去，只是把副本发出去

这里的数据也叫events

扩展架构：

* broker kafka的集群的一个节点 ，相当于我们的机器
* broker：topic 主题
  * 负责存储events
  * 订阅和发送都是基于topic来实现的
    * 只要订阅了这个topic，就可以知道他里面的数据
    * 发送也是同理
    * 一个kafka里可以有多个topic
    * 相当于这个是个有编号的数据仓库
    * 关于kafka的topic，我们是和他的效率成一个曲线波动的，比如在一定区间上升的比较多，一定区间反而下降

topic ：

* partition：分区
  * 一个topic可以有多个paitition
  * 每个partition是一个有序的序列
  * 分区并不是越多越好，最好是可以被我们的机器整除的，避免数据倾斜
  * 其分区中每个分区都有一个标记信息，叫offset，在offset规定的时间里，我们可以随意的消费这个数据，他会一直在
  * 而且和可以对offset的值进行修改
* topic的数据是放在不同的目录下面的，就是分区下面

部署 ：

解压 - 》 软连接 -》 环境变量 -》 vim server.properties

* borker.id : id编号
* log.retention.huors:数据保留的时间
* zookeeper.connect:zk的链接
* log.dirs：数据的存储文件夹
* hostname：机器的名字
* port：kafka对外的端口

更改成功之后，我们启动我们的kafka

kafka的启动有两种方式，然后我们可以通过jps进行查看它

简单的命令：`kafka-server-start.sh  -daemon $KAFKA_HOME/config/server.properties`

## 查看kafka的topic

```
kafka-topics.sh \
--list \
--zookeeper bigdata3:2181,bigdata4:2181,bigdata5:2181/kafka
```

## 创建topic

```
kafka-topics.sh \
--create \
--zookeeper bigdata3:2181,bigdata4:2181,bigdata5:2181/kafka \
--topic dl2262 \
--partitions 6 \
--replication-factor 3
```

注意 ：

partition的随便指定，最好是机器的倍数

副本-》容错

replication-factor topic的副本数小于等于机器数

## 查看详细的topic信息

```
kafka-topics.sh \
--describe \
--zookeeper bigdata3:2181,bigdata4:2181,bigdata5:2181/kafka \
--topic dl2262 


Topic:dl2262	PartitionCount:6	ReplicationFactor:3	Configs:
	Topic: dl2262	Partition: 0	Leader: 1	Replicas: 1,0,2	Isr: 1,0,2
	Topic: dl2262	Partition: 1	Leader: 2	Replicas: 2,1,0	Isr: 2,1,0
	Topic: dl2262	Partition: 2	Leader: 0	Replicas: 0,2,1	Isr: 0,2,1
	Topic: dl2262	Partition: 3	Leader: 1	Replicas: 1,2,0	Isr: 1,2,0
	Topic: dl2262	Partition: 4	Leader: 2	Replicas: 2,0,1	Isr: 2,0,1
	Topic: dl2262	Partition: 5	Leader: 0	Replicas: 0,1,2	Isr: 0,1,2

第一行 ： topic的总体情况 topic的名字 分区数量 分区数量 副本数量
第二行及以下 ： topic名字 分区的编号 leader的编号：负责对外进行读写的kafka的编号 Replicas:当前分区副本在哪些机器上是编号 isr： 负责对外进行读写请求的读写的顺序（机器编号）
实际上是有个顺序的，leader的分配以及，读写的顺序
```

## 删除topic

个人建议生产上不要删除topic

当topic的数量变多的时候，如果你删除了一个，则它可能会崩掉

修改也同上 ：

```
kafka-topics.sh \
--delete \
--zookeeper bigdata3:2181,bigdata4:2181,bigdata5:2181/kafka \
--topic dl2262 
```

topic ： 有俩个数据

* 磁盘上
* zk中的

执行之后，那个topic会被打上删除的标记，但是实际上数据还是在磁盘上的

如果真的想删除，可以在conf里加上 ，delete.topic.enable=true

## 修改topic

```
kafka-topics.sh \
--alter \
--zookeeper bigdata3:2181,bigdata4:2181,bigdata5:2181/kafka \
--topic dl2262 \
--partitions 6 \
--replication-factor 3
```

想修改什么就加什么参数

但是生产上也不要用：因为可能会导致kafka崩

补充：

* kafka如何进行数据迁移
* kafka进行压力测试

## 生产数据

```
kafka-console-producer.sh \ 
--broker-list bigdata3:9092,bigdata4:9092,bigdata35:9092 \
--topic test
```

正常我们是通过代码的方式进行编写的

官网的wproduceapi里有详细的介绍

首先要加入我们的代码

```
        <dependency>
			<groupId>org.apache.kafka</groupId>
			<artifactId>kafka-clients</artifactId>
			<version>2.1.0</version>
		</dependency>
```

而对于Streaming要添加

```
        <dependency>
			<groupId>org.apache.kafka</groupId>
			<artifactId>kafka-streams</artifactId>
			<version>2.1.0</version>
		</dependency>

```

kafka封装了一套二进制通信协议，用于对外提供各种各样的服务，对于producer而言，用户可以使用任意编程语言按照该协议的格式进行编程，从而实现向kafka发送消息。这组协议本质上为不同的协议类型分别定义了专属的紧凑二进制字节数组格式，然后通过socket发送给合适的broker，之后等待broker处理完成后返还响应给producer。

每个producer都是独立进行工作的，与其他producer之间没有关联，目前producer的首要功能就是向某个topic的某个分区发送一条消息，所以它首先需要确认到底向topic的哪个分区写入消息，这就是分区器（partitioner）的事情。kafka producer提供了一个默认的分区器，对于每条待发送的消息，如果该消息指定了key，那么该partitioner会根据key的哈希值来选择目标分区，若没有，会使用轮询的方式确认目标分区。当然，producer的API赋予了用户自行指定目标分区的权力。

在确认了目标分区后，producer要做的第二件事就是要寻找这个分区对应的leader，只有leader才能响应客户端发送过来的请求，而剩下的从节点中有一部分会同步该消息。因此在发送消息时，producer有不等待任何副本的响应便返回成功，或者只等待leader响应写入操作之后再返回成功。
代码如下 ；

```
import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.Producer;
import org.apache.kafka.clients.producer.ProducerRecord;

import java.util.Properties;

public class ProducerTest {

    public static void main(String[] args) {
        Properties props = new Properties();
        // 必须
        props.put("bootstrap.servers","121.5.240.148:9092");
        // 被发送到broker的任何消息的格式都必须是字节数组
        props.put("key.serializer","org.apache.kafka.common.serialization.StringSerializer");
        props.put("value.serializer","org.apache.kafka.common.serialization.StringSerializer");
        // 非必须参数配置
        // acks=0表明producer完全不管发送结果；
        // acks=all或-1表明producer会等待ISR所有节点均写入后的响应结果；
        // acks=1，表明producer会等待leader写入后的响应结果
        props.put("acks","-1");
        // 发生可重试异常时的重试次数
        props.put("retries",3);
         // producer会将发往同一分区的多条消息封装进一个batch中，
        // 当batch满了的时候，发送其中的所有消息,不过并不总是等待batch满了才发送消息；
        props.put("batch.size",323840);
         // 控制消息发送延时，默认为0，即立即发送，无需关心batch是否已被填满。
        props.put("linger.ms",10);
        // 指定了producer用于缓存消息的缓冲区大小，单位字节，默认32MB
        // producer启动时会首先创建一块内存缓冲区用于保存待发送的消息，然后由另一个专属线程负责从缓冲区中读取消息执行真正的发送
        props.put("buffer.memory",33554432);
        // 设置producer能发送的最大消息大小
        props.put("max.request.size",10485760);
        // 设置是否压缩消息，默认none
        props.put("compression.type","lz4");
        // 设置消息发送后，等待响应的最大时间
        props.put("request.timeout.ms",30);

        Producer<String,String> producer = new KafkaProducer<String, String>(props);
        for(int i = 0;i<5;i++){
            producer.send(new ProducerRecord<>("my-replicated-topic","key"+i,"value"+i));
        }

        producer.close();

    }
}
```

kafka producer发送消息的主方法是send方法，在底层完全地实现了异步化发送，并且通过Java提供的Future同时实现了同步发送和异步发送+回调两种发送方式。而上述代码使用的是第三种方式，即发送之后便不再理会发送结果，这种方式在实际中是不被推荐使用的。

**如果发送时连接不上，需要修改kafka配置文件重启**

```
listeners=PLAINTEXT : 外网ip
advertised.listeners=PLAINTEXT : 外网ip
```

异步发送 ：

实际上所有的写入操作默认都是异步的，send方法会返回一个Java Future对象供用户稍后获取发送结果，这就是所谓的回调机制。具体代码如下：

```
producer.send(record,new Callback(){
  @Override
  public void onCompletion(RecordMetadata metadata,Exception exception){
    if(exception == null){
      System.out.println("消息发送成功");
    } else {
      System.out.println("消息发送失败");
    }  
  }
});  

```

上面的代码中，Callback就是发送消息后的回调类，其onCompletion方法的两个输入参数metadata和exception不会同时非空，当消息发送成功时，exception为null，当消息发送失败时，metadata就是null。Callback实际上是一个Java接口，因此可创建自定义的Callback实现类来处理消息发送后的逻辑。

同步发送

同步发送和异步发送其实就是通过Java的Future来区分的，调用Future.get()等待返回结果，即是同步发送，具体代码如下：

```
ProducerRecord<String, String> record = new ProducerRecord<>("my-replicated-topic","key"+i,"value"+i);
 RecordMetadata recordMetadata = producer.send(record).get();

```

使用Future.get()方法会一直等待下去直到broker将结果返回给producer程序，当结果返回时，get()方法要么返回发送结果，要么抛出异常交由producer自行处理。如果没有错误，get将返回对应的RecordMetadata实例。

### 消息分区机制

producer发送过程中需要确定将消息发送到topic的哪一个分区，默认的分区器会尽力确保具有相同key的所有消息都被发送到相同的分区上；若没有指定key，会以轮询的方式来确保消息在topic的分区上均匀分配。

### kafka的发送异常

当前kafka的错误类型包含了两类：可重试异常和不可重试异常，常见的可重试异常如下：

* LeaderNotAvailableException：分区对应的leader不可用，通常出现在leader换届选举时，因此是瞬时的异常，重试之后可自行恢复。
* NotControllerException：表明controller当前不可用，在经历新一轮的选举，重试之后可自行恢复。
* NetworkException：网络瞬时异常，可重试。

所有可重试的异常都继承自or.apache.kafka.common.errors.RetriableException，对于这些可重试的异常，如果在producer程序中配置了重试次数，那么只要在规定的重试次数内自行恢复了，便不会出现在onCompletion的exception中。若超过了重试次数仍没成功，就会被封装到exception中，此时就需要producer程序自行处理这种异常。

没有继承自RetriableException的其他异常都属于不可重试异常，这类异常表明了一些非常严重或kafka无法处理的问题。

### 自定义分区机制

自定义分区器需要实现org.apache.kafka.clients.producer.Partitioner接口，分区逻辑写在partition()方法中，例如：

```
public class AuditPartitioner implements Partitioner {

    private Random random;

    @Override
    public void configure(Map<String, ?> map) {
        // 该方法实现必要资源的初始化工作
        random = new Random();
    }

    @Override
    public int partition(String topic, Object keyObj, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) {
        String key = (String)keyObj;
        // 获取该topic可用的所有分区
        List<PartitionInfo> partitionInfoList = cluster.availablePartitionsForTopic(topic);
        int partitionCount = partitionInfoList.size();
        int auditPartition = partitionCount -1;

        return key == null || !key.contains("audit") ? random.nextInt(auditPartition) : auditPartition;
    }

    @Override
    public void close() {
         // 该方法实现必要资源的清理
    }

}

```

使用自定义分区器：`props.put("partitioner.class","xx.xx.AuditPartitioner"); `

### 自定义序列化器

自定义序列化器需要实现org.apache.kafka.common.serialization.Serializer接口，在serializer方法中实现序列化逻辑，例如：

首先定义一个POJO对象

```
public class User{
  private String firstName;
  private String lastName;
  private int age;
  private String address;

  public User(String firstName,String lastName,int age,String address){
  this.firstName=firstName;
  this.lastName=lastName;
  this.age=age;
  this.address=address;
  }
  
}  

```

由于要用jackson-mapper-asl包中的ObjectMapper来将对象转成字节数组，因此需要将其依赖引入：

```
<dependency>
  <groupId>org.codehaus.jackson</groupId>
  <artifactId>jackson-mapper-asl</artifactId>
  <version>1.9.13</version>
</dependency>  
```

接下来创建serializer

```
public class UserSerializer implements Serializer{
  private ObjectMapper objectMapper;
  
  @Override
  public void configure(Map config,boolean isKey){
      objectMapper = new ObjectMapper();
  }

  @Override
  public byte[] serialize(String topic,Object data){
    byte[] res = null;
    try{
      res = objectMapper.writeValueAsString(data).getBytes("utf-8");
    }catch(Exception e){
      logger.warn("failed to serialize the object: {}", data, e);
    }
    return res;
  }

   @Override
   public void close(){}
}   

```

使用自定义的序列化器 `props.put("value.serializer","xx.xx.UserSerializer"); `

### producer[拦截器](https://so.csdn.net/so/search?q=%E6%8B%A6%E6%88%AA%E5%99%A8&spm=1001.2101.3001.7020)

producer拦截器使得用户在消息发送前和producer回调逻辑执行前可对消息做一些定制化处理，允许使用多个拦截器构成拦截器链。拦截器的实现接口是org.apache.kafka.clients.producer.ProducerInterceptor。interceptor可能运行在多个线程中，因此在具体实现时用户需要确保线程安全。下面以一个简单的双interceptor组成的拦截链为例。第一个interceptor会在消息发送前将时间戳信息加到消息value的最前部，第二个interceptor会在消息发送后更新成功发送消息或失败发送消息数。

```
public class TimeStampPrependerInterceptor implements ProducerInterceptor<String,String> {
    /**
     * producer确保在消息被序列化前调用该方法
     * 可以在该方法中对消息做任何操作
     */
    @Override
    public ProducerRecord onSend(ProducerRecord record) {
        return new ProducerRecord(record.topic(),record.partition(),record.timestamp(),record.key(),System.currentTimeMillis() +","+record.value().toString());
    }

    /**
     * 该方法会在消息被应答之前或消息发送时调用
     */
    @Override
    public void onAcknowledgement(RecordMetadata recordMetadata, Exception e) {

    }

    @Override
    public void close() {

    }

    @Override
    public void configure(Map<String, ?> map) {

    }
}

```

```
public class CounterInterceptor implements ProducerInterceptor<String,String> {

    private int errorCounter = 0;
    private int successCounter = 0;

    @Override
    public ProducerRecord<String, String> onSend(ProducerRecord<String, String> record) {
        return record;
    }

    @Override
    public void onAcknowledgement(RecordMetadata recordMetadata, Exception e) {
        if (e == null) {
            successCounter++;
        }else{
            errorCounter++;
        }
    }

    @Override
    public void close() {
        System.out.println("Successful sent: " + successCounter);
        System.out.println("Failed sent: " + errorCounter);
    }

    @Override
    public void configure(Map<String, ?> map) {

    }
}

```

使用自定义interceptor：

```
List<String> interceptors = new ArrayList<>();
interceptors.add("xx.xx.TimeStampPrependerInterceptor");
interceptors.add("xx.xx.CounterInterceptor");
props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG,interceptors);
```

### 消息的可靠发送

Java版本的producer采用异步发送机制，send方法将消息放入缓冲区，由一个专属I/O线程负责从缓冲区中提取消息并封装进消息batch中，然后发送出去。这个过程存在着数据丢失的窗口，即若I/O线程发送之前producer崩溃，则存储缓冲区中的消息会全部丢失。producer的另一个问题就是消息的乱序，假设现发送record1和record2两条消息，由于某些原因导致record1未发送成功，同时kafka又配置了重试机制，那么producer重试record1成功后，record1在日志中的位置可能反而位于record2之后。

### 无消息丢失配置

```
// 该配置控制 KafkaProducer.send() 和 KafkaProducer.partitionsFor() 将阻塞多长时间。此外这些方法被阻止，也可能是因为缓冲区已满或元数据不可用。在用户提供的序列化程序或分区器中的锁定不会计入此超时。默认为60000ms。
max.block.ms=60000

acks=all
retries=Integer.MAX_VALUE

// 该参数设置为1使producer在某个broker发送响应之前将无法再给broker发送请求，可防止topic同分区下的消息乱序问题，
max.in.flight.requests.per.connection=1

// 设置不允许非ISR中的副本被选举为leader，从而避免broker端因日志问题造成消息的丢失
unclean.leader.electionenable=false

replication.factor=3
// 用于控制某条消息至少被写入到ISR中的多少个副本才算成功
min.insync.replicas=2

enable.auto.commit=false

使用带回调机制的send发送消息
Callback逻辑中显式立即关闭producer
```

## 消费数据

```
kafka-console-consumer.sh \
--bootstrap-server bigdata3:9092,bigdata4:9092,bigdata5:9092 \
--topic dl2262 \
--from-beginning 
```

--from.beginning :开始消费的位置

问题：消费乱序 ：数据产生的问题和消费顺序不一致

如何保证kafka消费全局有序

* 多分区：不可能
  * 可以解决，spark ， flink 计算的结果是不对的
  * source ：mysql  id = 1 进行的操作 ： insert delete update
  * 然后把mysql里的binlog采集到kafka -》 flink/spark -》hbase/phonenix
  * 因为消费乱序，可能会出现问题
  * 思路：
    * 单分区 ：会影响spark或者flink的吞吐量 原因 ： 原来3个分区，三个并行度 ，现在一个，就慢了
    * 多分区 ：可以利用单分区有序解决全局有序
* 单分区：可以，单分区数据是有序的

消费者消费kafka的数据是以消费者组的方式进行消费的

消费者组 ：

* 一个组内共享一个消费者组的id
* 组内的所有消费者协调在一起去消费指定的topic的分区数据
* 每个分区只能由一个消费者组的一个消费者消费
* 不能由一个消费者组的多个消费者进行重复消费
* 生产上
  * 一般是一个消费者，在一个消费者组里
  * 就是可以消费全部分区数据
  * 上述是小公司和一般情况的大公司
  * 大公司 ：
    * 会用到消费者组 不同消费者处理不同分区数据

java api custome

```
package kafkacustome;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.KafkaConsumer;

import java.io.IOException;
import java.util.Collections;
import java.util.Properties;

public class customertestautooffset
{
    public static void main(String[] args) throws IOException, InterruptedException {
        //1 新建一个consumer对象
        Properties properties = new Properties();
        properties.load(customertestautooffset.class.getClassLoader().getResourceAsStream("consumer1.properties"));
        KafkaConsumer<String, String> consumer = new KafkaConsumer<String, String>(properties);

        //2 用这个对象接收消息
        //发布订阅模式接收消息，先订阅
        consumer.subscribe(Collections.singleton("dl2262"));
        while(true){
            //从订阅的话题中拉取数据
            ConsumerRecords<String, String> poll = consumer.poll(2000);
            if(poll.count() == 0){
                Thread.sleep(100);
            }
            //消费拉取到的数据
            for (ConsumerRecord<String, String> record : poll) {
                System.out.println(record);
            }
        }

        //3 关闭资源
        //consumer.close();
    }
}

```

其中“dl2262”是名为的topic的名字，其中groupid一样的就会分配到一起

其中 ： consumer1.properties内容是

```
key.deserializer=org.apache.kafka.common.serialization.StringDeserializer
value.deserializer=org.apache.kafka.common.serialization.StringDeserializer
bootstrap.servers=bigdata3:9092,bigdata4:9092,bigdata5:9092 
enable.auto.commit=true
group.id=test1
auto.offset.reset=earliest
```

上述是自动offset的

然后接下来是我们自己提交offset的

手动提交offset的方法有两种：分别是commitSync（同步提交）和commitAsync（异步提交）。两者的相同点是，都会将本次poll的一批数据最高的偏移量提交；不同点是，commitSync阻塞当前线程，一直到提交成功，并且会自动失败重试（由不可控因素导致，也会出现提交失败）；而commitAsync则没有失败重试机制，故有可能提交失败。

修改配置文件中的enable.auto.commit=false选项并在消费拉取到的数据之后添加consumer.commitSync();语句即可。由于同步提交offset有失败重试机制，故更加可靠

```
			 //消费拉取到的数据
            for (ConsumerRecord<String, String> record : poll) {
                System.out.println(record);
            }
            consumer.commitSync();

```

同步提交offset更可靠一些，但是由于其会阻塞当前线程，直到提交成功。因此吞吐量会收到很大的影响。在更多的情况下，会选用异步提交offset的方式。

## kafka数据存储

partition：下面存储就是数据，一段一段相同大小的Segment文件

Segment ：逻辑概念

* 它由log 和index文件组成
  * log :实实在在的数据 ，包括元数据 默认大小 1G是由 `log.segment.bytes控制单位是字节在配置文件里`
  * index：是我们的位置信息
* segment的命名规则
  * offset.index和offset.log
  * offset : 偏移量 -》数据event的标号，在topic下的编号
  * 比如 ： `00000000000000000000.index 00000000000000000000.log`
  * 然后如果达到后面最大值，则按照临界的offset来延续比如 `0000000000000003333333.index`等

借助脚本命令查看.log文件

* 因为kafka对数据的存储是按照他自己的存储方式来的，所有我们要查看.log文件的话要用其提供的脚本文件

```
kafka-run-class.sh \
kafka.tools.DumpLogSegments \
--files /home/hadoop/data/kafka/dl2262-0/00000000000000000000.log \
--print-data-log \
> 0.log
```

上述就是把其文件进行翻译，并存储在0.log中

在index文件中其中是offset：物理地址的形式

它是以稀疏表的方式进行维护的并不是每一条的都维护

## 面试题

如何查找offset为11865的数据？简述过程

解答 ：

* 通过二分查找算法 ， 查找offset为11865的最大Segment的文件组
* 去临近的最大的的index文件里再再用二分查找，找到对应的offset
* 如何看见其对应的partition：就是其物理地址
* 根据物理地址去迅速定位位置，按顺序查找，一直找到它

## 交付语义

消息交付语义 （生产者消费者都有）：

* at most once : 消息可能会丢，不会重复
* at least once ：不会丢失，但是可能会重复 ，没有事务，交付和记录是分开的，如果交付完成，再记录的时候挂了，下次启动就会继续从没有记录的位置进行交付，数据会重复
* exactly once ： 每个数据仅仅交付一次,增加了一个事务的情况，只有交付和记录都完成才可以继续往下
* producer ：

  * 发送数据的时候也有交付语义的
  * kafka 0.11.0 之前至少一次 会导致数据重复 ：at least once
  * 但是 0.11.0之后，包括0.11.0 ，会变成精准交付 : exactly once
* kafka版本，大于等于0.11.0版本
* customer：

  * 问题 ：如何存储上次消费到哪一个offset
    * 取决于，你的消费者组件，看他们支持什么消费者对应的交付语义
      * sparkStreaming ： 如上的三种
        * at most once
        * at least once
        * exactly once
        * 所以我们可以选择至少一次，精准一次，但是至少一次可能由重复问题
        * 但是90%sparkingStream和struedstreaming用至少一次，因为精准一次操作起来比较复杂
      * flink同理
      * 其他再议
    * offset信息如何维护？
      * 先了解
      * CheckPoints ：很简单，但是弊端也很多 ：生产上不能用 ，因为问题多
        * 首先会有小文件问题 ，代码变更整个spark项目就不能用了，就是之前记录的chackpoint信息就失效了
      * kafka itself ：比较推荐 ，简单不用自己写，人家给你生成好的 ，就是最少一次的
      * use your own data store ： 自己开发 ，用外部的数据源存储offset ，redis ，mysql ，hbase，建议使用hbase是最好的，但是另外两个也可以用的，但是有要求，每分钟的请求次数，mysql可能扛不住，redis可以 ，hbase可以 ， 不推荐用 redis
        * 可以达到精准一次的语义
  * 总的来说工作中用至少一次和精准一次用的很多，flink用的精准一次比较多,其他的至少一次就比较多

## 副本和数据同步

例子 ：8个分区 1个副本 8节点

kafka ：

* log 数据 ：topic 三份数据副本
  * hdfs 100多个节点 3副本ok
  * 但是kafka才8个节点，3副本大概会崩坏
  * 所以一般是一天或者三天
  * 每个kafka集群都有leader和follower
* leader 和 follower
  * leader ： 负责对外读写的节点
  * follower ： 拉取分区上对应的数据 ，进行备份的
* 机制ack：
  * 消息发送确认机制
  * 针对produce的
  * ack 的值有 all 1,0,-1
  * 1
    * 只要一个分区副本成功写入通知就认为生产者推送消息成功了
  * 0
    * 完全就不管发送的结果
  * -1
    * 其是收到所有分区副本写入成功的通知才认为成功
  * all
    * 和-1一样
* 工作中的选择
* 大部分时间选择all ，-1
* 其次是1
* 最后是0
* 速度关系0是最快的，1是中间的，-1是最慢的当是多个节点的时候，如果是单个leader和follower的时候1和-1是一样的

kafka监控

* kafka manager首选  二开kafkamanager 可以自己加上 官网 `https://github.com/yahoo/CMAK`
* kafka eagle -》 也好用 不过相对上面的那个，就是lower点 ，部署简单好用 官网 `https://github.com/smartloli/EFAK`

## kafka测试

用Kafka官方自带的脚本，对Kafka进行压测。Kafka压测时，可以查看到哪个地方出现了瓶颈（CPU，内存，网络IO）。一般都是网络IO达到瓶颈。

kafka-consumer-[perf](https://so.csdn.net/so/search?q=perf&spm=1001.2101.3001.7020)-test.sh

kafka-producer-perf-test.sh

### Kafka Producer压力测试

```
bin/kafka-producer-perf-test.sh  \
--topic test \
--record-size 100 \
--num-records 100000 \
--throughput -1 \
--producer-props bootstrap.servers=bigdata3:9092,bigdata4:9092,bigdata5:9092

record-size是一条信息有多大，单位是字节。
num-records是总共发送多少条信息。
throughput 是每秒多少条信息，设成-1，表示不限流，可测出生产者最大吞吐量。

他会打印下面的语句
100000 records sent, 149253.731343 records/sec (14.23 MB/sec), 112.02 ms avg latency, 207.00 ms max latency, 97 ms 50th, 190 ms 95th, 206 ms 99th, 207 ms 99.9th.
参数解析：本例中一共写入10w条消息，吞吐量为14.23 MB/sec，每次写入的平均延迟为112.02毫秒，最大的延迟为207毫秒

```

### Kafka Consumer压力测试

```
kafka-consumer-perf-test.sh 
--broker-list bigdata3:9092,bigdata4:9092,bigdata35:9092 
--topic test 
--fetch-size 10000 
--messages 10000000 
--threads 1
 
--zookeeper 指定zookeeper的链接信息

--topic 指定topic的名称

--fetch-size 指定每次fetch的数据的大小

--messages 总共要消费的消息个数
测试结果说明：

start.time, end.time, data.consumed.in.MB, MB.sec, data.consumed.in.nMsg, nMsg.sec
2020-03-10 03:18:51:773, 2020-03-10 03:18:53:815, 19.0735, 9.3406, 200000, 97943.192
```

## Kafka 集群数据迁移

### 同集群迁移

同集群之间数据迁移，比如在已有的集群中新增了一个Broker节点，此时需要将原来集群中已有的Topic的数据迁移部分到新的集群中，缓解集群压力。

将新的节点添加到Kafka集群很简单，只需为它们分配一个唯一的Broker ID，并在新[服务器](https://cloud.tencent.com/product/cvm?from=10680)上启动Kafka。但是，这些新服务器节点不会自动分配任何数据分区，因此除非将分区移动到新增的节点，否则在创建新Topic之前新节点不会执行任何操作。因此，通常在将新服务器节点添加到Kafka集群时，需要将一些现有数据迁移到这些新的节点。

迁移数据的过程是手动启动的，执行过程是完全自动化的。在Kafka后台服务中，Kafka将添加新服务器作为其正在迁移的分区的Follower，并允许新增节点完全复制该分区中的现有数据。当新服务器节点完全复制此分区的内容并加入同步副本（ISR）时，其中一个现有副本将删除其分区的数据。

Kafka系统提供了一个分区重新分配工具（kafka-reassign-partitions.sh），该工具可用于在Broker之间迁移分区。理想情况下，将确保所有Broker的数据和分区均匀分配。分区重新分配工具无法自动分析Kafka群集中的数据分布并迁移分区以实现均匀的[负载均衡](https://cloud.tencent.com/product/clb?from=10680)。因此，管理员在操作的时候，必须弄清楚应该迁移哪些Topic或分区。

分区重新分配工具可以在3种互斥模式下运行：

* --generate：在此模式下，给定Topic列表和Broker列表，该工具会生成候选重新分配，以将指定Topic的所有分区迁移到新Broker中。此选项仅提供了一种方便的方法，可在给定Topic和目标Broker列表的情况下生成分区重新分配计划。
* --execute：在此模式下，该工具将根据用户提供的重新分配计划启动分区的重新分配。 （使用--reassignment-json-file选项）。由管理员手动制定自定义重新分配计划，也可以使用--generate选项提供。
* --verify：在此模式下，该工具将验证最后一次--execute期间列出的所有分区的重新分配状态。状态可以有成功、失败或正在进行等状态。

### 迁移过程实现

分区重新分配工具可用于将一些Topic从当前的Broker节点中迁移到新添加的Broker中。这在扩展现有集群时通常很有用，因为将整个Topic移动到新的Broker变得更容易，而不是一次移动一个分区。当执行此操作时，用户需要提供已有的Broker节点的Topic列表，以及到新节点的Broker列表（源Broker到新Broker的映射关系）。然后，该工具在新的Broker中均匀分配给指定Topic列表的所有分区。在迁移过程中，Topic的复制因子保持不变。

现有如下实例，将Topic为ke01，ke02的所有分区从Broker1中移动到新增的Broker2和Broker3中。由于该工具接受Topic的输入列表作为JSON文件，因此需要明确迁移的Topic并创建json文件，如下所示：

```
> cat topic-to-move.json
{"topics": [{"topic": "ke01"},
            {"topic": "ke02"}],
"version":1
}
```

准备好JSON文件，然后使用分区重新分配工具生成候选分配，命令如下：

```
> bin/kafka-reassign-partitions.sh --zookeeper bigdata3:2181,bigdata4:2181,bigdata5:2181/kafka  --topics-to-move-json-file topics-to-move.json --broker-list "1,2" --generate
```

该工具生成一个候选分配，将所有分区从Topic ke01，ke02移动到Broker1和Broker2。需求注意的是，此时分区移动尚未开始，它只是告诉你当前的分配和建议。保存当前分配，以防你想要回滚它。新的赋值应保存在JSON文件（例如expand-cluster-reassignment.json）中，以使用--execute选项执行。JSON文件如下：

```
{"version":1,"partitions":[{"topic":"ke02","partition":0,"replicas":[2]},{"topic":"ke02","partition":1,"replicas":[1]},{"topic":"ke02","partition":2,"replicas":[2]},{"topic":"ke01","partition":0,"replicas":[2]},{"topic":"ke01","partition":1,"replicas":[1]},{"topic":"ke01","partition":2,"replicas":[2]}]}
```

命令

```
> ./kafka-reassign-partitions.sh --zookeeper bigdata3:2181,bigdata4:2181,bigdata5:2181/kafka --reassignment-json-file expand-cluster-reassignment.json --execute
```

最后，--verify选项可与该工具一起使用，以检查分区重新分配的状态。需要注意的是，相同的expand-cluster-reassignment.json（与--execute选项一起使用）应与--verify选项一起使用，执行命令如下：

```
> ./kafka-reassign-partitions.sh --zookeeper bigdata3:2181,bigdata4:2181,bigdata5:2181/kafka --reassignment-json-file expand-cluster-reassignment.json --verify
```

同时，我们可以通过[Kafka Eagle](https://blog.csdn.net/m0_63722685?spm=1011.2124.3001.5343)工具来查看Topic的分区情况。

## 跨集群迁移

这里跨集群迁移，我们指的是在Kafka多个集群之间复制数据“镜像”的过程，以避免与单个集群中的节点之间发生的复制混淆。 Kafka附带了一个用于在Kafka集群之间镜像数据的工具。该工具从源集群使用并生成到目标集群。这种镜像的一个常见用例是在另一个数据中心提供副本。

另外，你可以运行许多此类镜像进程以提高吞吐量和容错（如果一个进程终止，其他进程将占用额外负载）。将从源集群中的Topic读取数据，并将其写入目标集群中具有相同名称的主题。事实上，“镜像”数据只不过是一个Kafka将消费者和生产者联系在了一起。

源集群和目标集群是完全独立的实体，它们可以具有不同数量的分区，并且偏移量将不相同。出于这个原因，镜像集群并不是真正意图作为容错机制（因为消费者的位置会有所不同）;为此，建议使用正常的集群内复制。但是，镜像进程将保留并使用消息Key进行分区，因此可以按Key保留顺序。

下面是一个跨集群的单Topic实例，命令如下：

```
> ./kafka-mirror-maker.sh --consumer.config consumer.properties --producer.config producer.properties --whitelist ke03
```

需要注意的是，consumer.properties文件配置源Kafka集群Broker地址，producer.properties文件配置目标Kafka集群地址。如果需要迁移多个Topic，可以使用 --whitelist 'A|B'，如果需要迁移所有的Topic，可以使用 --whitelist '*'。

执行跨集群迁移命令后，目标集群中使用Kafka Eagle中查看Topic Size大小看是否与源集群的Topic Size大小相等，或者使用SQL语句，验证是否有数据迁移过来，

跨集群迁移数据的本质是，Kafka启动了消费者读取源集群数据，并将消费后的数据写入到目标集群，在迁移的过程中，可以启动多个实例，提供迁出的吞吐量。
