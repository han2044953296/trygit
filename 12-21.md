---
title: SSM
date: 12-21 8.40
categories: 杂货技术栈
comments: "true"
tag: java
---
# spring

官网 ： spring.io

到今天它已经成为了一个生态圈，可以通过官网进行查看

先学习spring Framework  ： 底层的框架，是设计性框架

然后是spring boot ： 提高开发速度

而后是spring cloud ： 分布式开发相关技术

# spring FrameWork

2004年spring 1.0 问世

spring 1.0 是纯配置 2.0 引入了注解 3.0 引入了可以不写注解的 ，4.0 spring对jdk进行支持，5.0的时候要jdk8

## spring思想

我们现在的用纯javase的时候耦合度过高，则要改一点东西的时候要重新编译，解决方案，适用对象的时候会不要在主动用new对象，从外传进来，就可以把方法当作一个工具这个思想就是ioc（控制反转）

spring就做到了，spring容器：ioc容器，它用这个充当了ioc的外部，ioc容器要管理创建和初始化的过程，被创建或者被管理的对象叫bean

如果服务的依赖也在容器里，则ioc容器会自动把他们的关系绑好，绑关系的过程叫Di，基本思想就是充分解耦

## Ioc的入门案例思路

### 管理什么？

对应的bean：比如service 和 dao

### 如何告知被管理的文件？

通过配置文件

### 被管理的对象交给ioc容器，如何获取到ioc？

接口

### 如何从容器中获取bean

接口方法

### spring如何导入坐标

pom.xml

## 实现

先导入spring-context:在pom文件里导入

```
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>5.2.10.RELEASE</version>
    </dependency>
```

然后在resource文件夹里创建xml中选择spring的xml。随便命名

接下来我们编辑这个xml文件的内容

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
<bean id="hellobean" class="org.example.testbean.test"></bean>
</beans>
```

其中 class后面的包名里如下 ，上述的id是我们引出这个bean的依据，就是id 这个id在一个xml文件中是不可以重复的，后面的class代表我们要用这个id代表的类，也就是告诉ioc容器，是哪一个类被它管理了，其内部只是一个普通的方法

```
package org.example.testbean;

public class test {
    public void printhello(){
        System.out.println("hellospringbean");
    }

}

```

然后我们在一个java类里如下实现

```
package org.example;

import org.example.testbean.test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        ApplicationContext stx = new ClassPathXmlApplicationContext("applicationContext.xml");
        test hellobean = (test) stx.getBean("hellobean");
        hellobean.printhello();
    }
}

```

就可以了，上述ApplicationContext是一个接口，然后通过ClassPathXmlApplicationContext("applicationContext.xml")把我们的配置文件载入

## Di的入门案例

提供方法让其进入到对应的依赖中，以及添加配置

首先创建两个类 如下

```
package org.example.testbean;

public class test2 {
    private test tx;


    public void  printhellobean(){
        tx.printhello();
        System.out.println("Secondly hello ");
    }


    public test getTx() {
        return tx;
    }

    public void setTx(test tx) {
        this.tx = tx;
    }
}

------------------------------------------------------------------------------------
package org.example.testbean;

public class test {
    public void printhello(){
        System.out.println("hellospringbean");
    }

}

```

然后再spring的配置文件中加上，先添加上两个类的bean，然后进行关联 ，其中name是那一个类里的变量，ref是那个变量指向那一个bean所指向的类，就是bean的id

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="hellobean" class="org.example.testbean.test"></bean>
    <bean id="hellobean2" class="org.example.testbean.test2">
        <property name="tx" ref="hellobean"></property>
    </bean>
</beans>
```

然后再app方法，就是我们要执行的方法中加上

```
package org.example;

import org.example.testbean.test;
import org.example.testbean.test2;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        ApplicationContext stx = new ClassPathXmlApplicationContext("applicationContext.xml");
        test2 hellobean = (test2) stx.getBean("hellobean2");
        hellobean.printhellobean();
    }
}

```

这就是DI ，其实以前就自己用纯javaee代码实现过这个思想

### bean的别名

```
 <bean id="hellobean" name="test1 test3" class="org.example.testbean.test"></bean>
然后其他的地方调用它和id是一样的
```

可以用， ； 空格分割

spring 默认创建的bean是单例，就是一个对象无论是哪一个程序使用的相同的bean的id，它都是一个对象，可以进行设置

```
<bean id="hellobean" class="org.example.testbean.test" scope="prototype"></bean>
这样他就会创建多个对象
如果想创建单个对象，可以执行默认 ，或者singleton
```

为什么bean默认为单例？

* 为了控制bean的数量，以及减轻负担

spring管理对象的时候就是管理的复用的对象

适合其管理的对象 ：

* 表现层对象
* 业务层对象
* 数据层对象
* 工具对象

不适合的

* 封装实体的域对象

## bean实例化

### bean是如何创建的

bean的本质是对象，创建bean是使用方法

spring 创建bean的是无参的，无论是public 或者是private ，都可以调用，因为它是用反射调用的构造，但是如果你没有无参的构造方法，他会报错，就是bean创建的异常

spring的报错信息，我们一般是从后面往前看

### 工厂方法创建bean

使用静态工厂的方式创建bean

先创建testFactory类

```
package org.example.testbean;

public static class testFactory {
    public test testfac(){
        return new test();
    }
}

```

然后我们在配置文件中写下

```
 <bean id="factory" class="org.example.testbean.testFactory" factory-method="testfac"></bean>
```

然后再app类中执行的方法和上面一样

### 实例工厂初始化bean

创建个工厂类

```
package org.example.testbean;

public class testFactory {
    public  test testfac(){
        return new test();
    }
}

```

修改配置如下

```
    <bean id="factory" class="org.example.testbean.testFactory"></bean>
    <bean id="test" factory-method="testfac" factory-bean="factory"></bean>
```

然后正常调用test就ok了

### 使用接口创建

我们思考，因为上面两种每次改一次就要去配置文件进行修改，有点太麻烦了，我们可以创建一个类实现FactorBean的接口如下

```
package org.example.testbean;

        import org.springframework.beans.factory.FactoryBean;

public class testFactory2 implements FactoryBean<test> {
    @Override
    public test getObject() throws Exception {
        return new test(); // 要返回的对象
    }

    @Override
    public Class<?> getObjectType() {
        return test.class;//new 的对象的class
    }

    @Override
    public boolean isSingleton() {
        return true;//是不是单例
    }
}

```

如上：然后再配置文件里写入，

```
<bean id="factory2" class="org.example.testbean.testFactory2"></bean>
```

正常调用即可

经过上述，我们知道，我们实例化bean的方式大体上有三种，但是细分则是四种，因为最后一个是第三种的变种

## bean的生命周期

生命周期 ： 从创建到消亡的完整过程

bean生命周期 ： bean从创建到销毁的整体过程

bean生命周期的控制：再bean创建后到销毁前做的一些事情

代码及思路如下 ：

要进行生命周期的控制，我们就是控制bean创建的时候和销毁的时候做一些事情

我们在test中加入如下代码

```
package org.example.testbean;

public class test {
    public void printhello(){
        System.out.println("hellospringbean");
    }
    public void  init(){
        System.out.println("init");
    }
    public void destory(){
        System.out.println("destory");
    }
  
}

```

上面定义的init以及destory就是我们定义的初始化方法和销毁方法

然后我们要告诉我们的容器，我们的初始化方法和销毁方法

在配置文件里如下写

```
    <bean id="hellobean" class="org.example.testbean.test" init-method="init" destroy-method="destory"></bean>
```

最后在主程序调用的时候如下写

```
package org.example;

import org.example.testbean.test;
import org.example.testbean.test2;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {

// 这里不用ApplicationContext的原因是它并没有close的方法，是它的子类实现的接口有这个方法，所以就换成它的子类   
// ApplicationContext stx = new ClassPathXmlApplicationContext("applicationContext.xml");
        ClassPathXmlApplicationContext stx = new ClassPathXmlApplicationContext("applicationContext.xml");
        test hellobean = (test) stx.getBean("hellobean");
        hellobean.printhello();
        // 这个是比较暴力的方法直接杀死容器
        //stx.close();
        // 这个是告诉jvm当退出的时候关闭容器
        stx.registerShutdownHook();
    }
}

```

运行程序结果如下

```
init
hellospringbean
destory

Process finished with exit code 0
```

但是我觉得上述的步骤还是有点麻烦

我们可以让它在创建方法的时候就是直接把它标记为初始化方法以及销毁方法

在test2中进行如下操作

```
package org.example.testbean;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;

public class test2 implements InitializingBean , DisposableBean {
    private test tx;


    public void  printhellobean(){
        tx.printhello();
        System.out.println("Secondly hello ");
    }

    public test2() {
        System.out.println("Constru");
    }

    public test getTx() {
        return tx;
    }

    public void setTx(test tx) {
        this.tx = tx;
    }

    @Override
    public void destroy() throws Exception {
        System.out.println("destrory test2");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("init test2");
    }
}

```

然后我们在主程序中调用test2所对应的beanid

```
package org.example;

import org.example.testbean.test;
import org.example.testbean.test2;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
//        ApplicationContext stx = new ClassPathXmlApplicationContext("applicationContext.xml");
        ClassPathXmlApplicationContext stx = new ClassPathXmlApplicationContext("applicationContext.xml");
        test2 hellobean = (test2) stx.getBean("hellobean2");
        hellobean.printhellobean();
        // 这个是比较暴力的方法直接杀死容器
        //stx.close();
        // 这个是告诉jvm当退出的时候关闭容器
        stx.registerShutdownHook();
    }
}

```

执行结果如下

```
init
Constru
init test2
hellospringbean
Secondly hello 
destrory test2
destory

```

解释：

第一个init是test中的初始化方法，第二个是test2的构造器方法，然后才是test2的bean方法销毁也是同理，最后销毁test容器

所以bean的初始化方法的执行时间是在test的构造器方法之后的

## 依赖的注入方式

有几种方式可以传递数据往类里传递

* 普通方法 ： set
* 构造方法

在bean创建对象的时候如果我们一个类里需要的并不是引用类型，就是要基本类型改怎么办？

* Setter 注入
  * 简单类型
  * 引用类型
* 构造器注入
  * 简单类型
  * 引用类型

## Setter注入

### 注入引用类型

上述已经实现过了，通过在配置里写入

```
    <bean id="hellobean2" class="org.example.testbean.test2">
        <property name="tx" ref="hellobean"></property>
    </bean>
```

就可以但是当他是多个的时候我们可以在中间再加上一样的语句，就可以就是多加几个这 `<property name="tx" ref="hellobean"></property>`

### 注入基本类型

我们先在test中编写如下代码

```
package org.example.testbean;

import java.util.stream.StreamSupport;

public class test {
    private String mysqlname;
    private int maxConnection;

    public String getMysqlname() {
        return mysqlname;
    }

    public void setMysqlname(String mysqlname) {
        this.mysqlname = mysqlname;
    }

    public int getMaxConnection() {
        return maxConnection;
    }

    public void setMaxConnection(int maxConnection) {
        this.maxConnection = maxConnection;
    }

    public void printhello(){
        System.out.println("hellospringbean" + mysqlname + maxConnection);
    }
    public void  init(){
        System.out.println("init");
    }
    public void destory(){
        System.out.println("destory");
    }

}

```

然后我们在配置中编写

```
    <bean id="hellobean" class="org.example.testbean.test" init-method="init" destroy-method="destory">
        <property name="mysqlname" value="dl2262"></property>
        <property name="maxConnection" value="10"></property>
    </bean>

```

这里value传值是什么类型的我们不用多管因为spring会自动帮我们转换类型

运行主程序结果

```
init
Constru
init test2
hellospringbeandl226210
destrory test2
destory

```

解释 ： spring关联两个容器的时候，并不是说你调用其中一个容器另外一个容器就完全没反应，它本质上还是初始化两个容器，只不过根据你调用的方法不同显示和不显示而已

因为在配置中

```
    <bean id="hellobean2" class="org.example.testbean.test2">
        <property name="tx" ref="hellobean"></property>
    </bean>
```

test2是和test关联在一起的，所以test2的初始化bean和销毁bean也在这里，但是它并没有执行test2的构造器方法，也就是并没有实力这个类，它只是走了容器的初始和销毁

## 构造器注入

首先构造器注入分为三种

### 最标准的构造器注入

首先我们在test中编写如下

```
package org.example.testbean;

import java.util.stream.StreamSupport;

public class test {
    private String mysqlname;
    private int maxConnection;

    public test(String mysqlname, int maxConnection) {
        this.mysqlname = mysqlname;
        this.maxConnection = maxConnection;
    }

    public String getMysqlname() {
        return mysqlname;
    }

    public void setMysqlname(String mysqlname) {
        this.mysqlname = mysqlname;
    }

    public int getMaxConnection() {
        return maxConnection;
    }

    public void setMaxConnection(int maxConnection) {
        this.maxConnection = maxConnection;
    }

    public void printhello(){
        System.out.println("hellospringbean" + mysqlname + maxConnection);
    }
    public void  init(){
        System.out.println("init");
    }
    public void destory(){
        System.out.println("destory");
    }

}

```

然后再在配置文件中编写

```
    <bean id="hellobean" class="org.example.testbean.test" init-method="init" destroy-method="destory">
        <constructor-arg name="maxConnection" value="1000">
        </constructor-arg>
        <constructor-arg name="mysqlname" value="dl2262"></constructor-arg>
    </bean>
```

执行主程序的app

```
init
Constru
init test2
hellospringbeandl22621000
destrory test2
destory
```

然后是传入引用类型

先在test2中如下编写

```
package org.example.testbean;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;

public class test2 implements InitializingBean , DisposableBean {
    private test tx;


    public void  printhellobean(){
        tx.printhello();
        System.out.println("Secondly hello ");
    }

    public test2(test tx) {
        this.tx = tx;
        System.out.println("Constru");
    }

    public test getTx() {
        return tx;
    }

    public void setTx(test tx) {
        this.tx = tx;
    }

    @Override
    public void destroy() throws Exception {
        System.out.println("destrory test2");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("init test2");
    }
}

```

然后在配置文件中编写

```
    <bean id="hellobean2" class="org.example.testbean.test2">
        <constructor-arg name="tx" ref="hellobean"></constructor-arg>
    </bean>
```

执行主程序中的app

```
init
Constru
init test2
hellospringbeandl22621000
Secondly hello 
destrory test2
destory
```

结果如上

上述在配置里传入的参数是形参，就是构造器方法的变量的名字，有人就说这样传参，会不会导致偶合过高，和spring的初衷不符合，事实也是如此

### 第二种构造器

在配置文件中如下

```
    <bean id="hellobean" class="org.example.testbean.test" init-method="init" destroy-method="destory">
        <constructor-arg type="java.lang.Integer" value="1000">
        </constructor-arg>
        <constructor-arg type="java.lang.String" value="dl2262"></constructor-arg>
    </bean>
```

这种的确在某种程度上解决了偶合问题，不过却又引发出一种新问题，就是因为他说按照类型来给值的，如果构造器种有两个一样类型的值？如何解决

### 第三种构造器

配置文件如下

```
    <bean id="hellobean2" class="org.example.testbean.test2">
        <constructor-arg index="0" ref="hellobean"></constructor-arg>
    </bean>
```

就是用下标来控制

### 总结

构造器方法相比于setter方法是更快速，但是相对而言，如果出错也危害更大

自己定义的模块一般都采用setter，而官方的框架之类的一般都采用构造器的

## 自动装入

spring帮我们自动装配

自动装配的方式：

* 按类型：常用
* 按名称
* 按构造方法
* 不启用自动装配

我们先查看配置文件

如下

```
    <bean id="hellobean2" class="org.example.testbean.test2">
        <constructor-arg index="0" ref="hellobean"></constructor-arg>
    </bean>
```

我们把其改成

```
    <bean id="hellobean2" class="org.example.testbean.test2" autowire="byType"></bean>
或者
    <bean id="hellobean2" class="org.example.testbean.test2" autowire="byName"></bean>
等等
```

就变成自动装配了

注意点：

关于自动装配一般不装配基本数据，而且如果自动装配是装配byname ，则要求你构造器的形参和bean的id是一样的，如果是bytype则要求不能有一样的类

## 传递参数数组集合的

数组

List

Set

Map

Properties

在test中写下

```
package org.example.testbean;

import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.stream.StreamSupport;

public class test {
    private String mysqlname;
    private int maxConnection;

    private int[] array;
    private List<String> List;
    private Set<String> Set;
    private Map<String , String> Map;
    private Properties properties;


    public int[] getArray() {
        return array;
    }

    public void setArray(int[] array) {
        this.array = array;
    }

    public java.util.List<String> getList() {
        return List;
    }

    public void setList(java.util.List<String> list) {
        List = list;
    }

    public java.util.Set<String> getSet() {
        return Set;
    }

    public void setSet(java.util.Set<String> set) {
        Set = set;
    }

    public java.util.Map<String, String> getMap() {
        return Map;
    }

    public void setMap(java.util.Map<String, String> map) {
        Map = map;
    }

    public Properties getProperties() {
        return properties;
    }

    public void setProperties(Properties properties) {
        this.properties = properties;
    }

    public test(String mysqlname, int maxConnection) {
        this.mysqlname = mysqlname;
        this.maxConnection = maxConnection;
    }

    public String getMysqlname() {
        return mysqlname;
    }

    public void setMysqlname(String mysqlname) {
        this.mysqlname = mysqlname;
    }

    public int getMaxConnection() {
        return maxConnection;
    }

    public void setMaxConnection(int maxConnection) {
        this.maxConnection = maxConnection;
    }

    public void printhello(){
        System.out.println("hellospringbean" + mysqlname + maxConnection);
    }
    public void  init(){
        System.out.println("init");
    }
    public void destory(){
        System.out.println("destory");
    }

}

```

然后再配置文件中写下

```
 <bean id="tx" class="org.example.testbean.test" init-method="init" destroy-method="destory">
        <constructor-arg index="1" value="1000">
        </constructor-arg>
        <property name="array">
            <array>
                <value>100</value>
                <value>200</value>
                <value>300</value>
            </array>
        </property>
        <property name="set">
            <set>
                <value>hdkjdsfhjk</value>
                <value>daskhkash</value>
            </set>
        </property>
        <property name="list">
            <list>
                <value>dksahjdhak</value>
                <value>daskhkash</value>
            </list>
        </property>
        <property name="map">
            <map>
                <entry key="1" value="dfslkjfl"></entry>
                <entry key="2" value="dfslkjfl"></entry>
            </map>
        </property>
        <property name="properties">
            <props>
                <prop key="sdakjl">adslald</prop>
                <prop key="sdakjlw">adslald</prop>
            </props>
        </property>
        <constructor-arg type="java.lang.String" value="dl2262"></constructor-arg>
    </bean>
```

就成功了

## 数据源对象管理

在pom文件

```
    <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
      <version>1.1.16</version>
    </dependency>
```

然后在配置文件中加入

```
    <bean  class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://bigdata2:3306/try"></property>
        <property name="username" value="root"></property>
        <property name="password" value="liuzihan010616"></property>
    </bean>
```

然后主方法写入

```
ClassPathXmlApplicationContext stx = new ClassPathXmlApplicationContext("applicationContext.xml");
        DataSource hellobean = (DataSource) stx.getBean("dataSource");
        System.out.println(hellobean);
```

结果如下 ：

```
{
	CreateTime:"2022-12-28 08:49:29",
	ActiveCount:0,
	PoolingCount:0,
	CreateCount:0,
	DestroyCount:0,
	CloseCount:0,
	ConnectCount:0,
	Connections:[
	]
}
```

代表我们用druid成功

接下来我们换一个

在pom文件中加入

```
    <dependency>
      <groupId>c3p0</groupId>
      <artifactId>c3p0</artifactId>
      <version>0.9.1.2</version>
    </dependency>
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.6</version>
    </dependency>
```

然后再配置文件中写入

```
    <bean  class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://bigdata2:3306/try"></property>
        <property name="username" value="root"></property>
        <property name="password" value="liuzihan010616"></property>
    </bean>

    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
        <property name="jdbcUrl" value="jdbc:mysql://bigdata2:3306/try" ></property>
        <property name="user" value="root"></property>
        <property name="password" value="liuzihan010616"></property>
    </bean>

```

主方法没变

执行结果如下：

```
com.mchange.v2.c3p0.ComboPooledDataSource [ acquireIncrement -> 3, acquireRetryAttempts -> 30, acquireRetryDelay -> 1000, autoCommitOnClose -> false, automaticTestTable -> null, breakAfterAcquireFailure -> false, checkoutTimeout -> 0, connectionCustomizerClassName -> null, connectionTesterClassName -> com.mchange.v2.c3p0.impl.DefaultConnectionTester, dataSourceName -> 1hge16gatnx5ejf144h6k9|5a4aa2f2, debugUnreturnedConnectionStackTraces -> false, description -> null, driverClass -> com.mysql.jdbc.Driver, factoryClassLocation -> null, forceIgnoreUnresolvedTransactions -> false, identityToken -> 1hge16gatnx5ejf144h6k9|5a4aa2f2, idleConnectionTestPeriod -> 0, initialPoolSize -> 3, jdbcUrl -> jdbc:mysql://bigdata2:3306/try, maxAdministrativeTaskTime -> 0, maxConnectionAge -> 0, maxIdleTime -> 0, maxIdleTimeExcessConnections -> 0, maxPoolSize -> 15, maxStatements -> 0, maxStatementsPerConnection -> 0, minPoolSize -> 3, numHelperThreads -> 3, numThreadsAwaitingCheckoutDefaultUser -> 0, preferredTestQuery -> null, properties -> {user=******, password=******}, propertyCycle -> 0, testConnectionOnCheckin -> false, testConnectionOnCheckout -> false, unreturnedConnectionTimeout -> 0, usesTraditionalReflectiveProxies -> false ]

```

上述的所有都是可以再配置文件里进行设置的

如下：

```
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
        <property name="jdbcUrl" value="jdbc:mysql://bigdata2:3306/try" ></property>
        <property name="user" value="root"></property>
        <property name="password" value="liuzihan010616"></property>
        <property name="maxPoolSize" value="1000"></property>
    </bean>
```

上述就是简单的通过bean使用连接池的方法

### 加载properties

通过bean加载properties

首先创建一个properties文件

```
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=dbc:mysql://bigdata2:3306/try
jdbc.user=root
jdbc.password=liuzihan010616
```

然后要在配置文件中新建个命名空间如下，我们新建的命名空间是context

```
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context  
       http://www.springframework.org/schema/context/spring-context.xsd">
------------------------------------使用命名空间
<context:property-placeholder location="classpath:jdbc.properties" system-properties-mode="NEVER"></context:property-placeholder>
// 其中system-properties-mode 是设置系统变量的优先级，要不然系统变量如果和properties变量和名称重复，则会用系统变量的名
// location是设置要加载的properties的地址，这里可以用正则的,比如 *.properties
// 多个properties文件的时候用，分割
------------------------------------使用配置文件
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="${jdbc.driver}"></property>
        <property name="jdbcUrl" value="${jdbc.url}" ></property>
        <property name="user" value="${jdbc.user}"></property>
        <property name="password" value="${jdbc.password}"></property>
        <property name="maxPoolSize" value="1000"></property>
    </bean>

```

## 容器

初始化容器的两种方法：

```
package org.example;

import org.example.testbean.test;
import org.example.testbean.test2;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.context.support.FileSystemXmlApplicationContext;

import javax.sql.DataSource;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        //加载类路径下的配置文件
//        ApplicationContext stx = new ClassPathXmlApplicationContext("applicationContext.xml");
        ClassPathXmlApplicationContext stx = new ClassPathXmlApplicationContext("applicationContext.xml");
        // 加载绝对路径下的配置文件
        FileSystemXmlApplicationContext stx2 = new FileSystemXmlApplicationContext("F:\\bigdatajava\\src\\main\\resources\\applicationContext.xml");

	//下面三种都行
        DataSource hellobean = (DataSource) stx.getBean("dataSource");
  
        DataSource dataSource = stx.getBean("dataSource" , DataSource.class);
  
        DataSource dataSource1 = stx.getBean(DataSource.class);
	//_------------------------------------------------------------------------------------------
        System.out.println(hellobean);
        //hellobean.printhello();
        // 这个是比较暴力的方法直接杀死容器
        //stx.close();
        // 这个是告诉jvm当退出的时候关闭容器
        stx.registerShutdownHook();

    }
}

```

BeanFactory 是ApplicationContext的最顶层接口，所以用这个也可以达到容器的效果，不过因为他有缺陷，所以后来不用了

通过以下方法实例容器：

```
        Resource resource = new ClassPathResource("applicationContext.xml");
        BeanFactory bf = new XmlBeanFactory(resource);
```

BeanFactory是延迟加载 ：就是不是之间把所用的类初始化，等到用到才会加载

我们可以在配置文件里加上 `lazy-init="true"`

```
 <bean id="tx" class="org.example.testbean.test" init-method="init" destroy-method="destory" lazy-init="true">
```

就可以了

## 注解开发

注解开发的基本定义就是通过注解减缓spring的配置文件的负担

比如 如下 ：

```
<bean id="hellobean2" class="org.example.testbean.test2" autowire="byName">
```

上述的配置文件中获得信息就可以通过注解代替：

* 找到对应类
* 放上注解

如下：

```
package org.example.testbean;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.stereotype.Component;

@Component("hellobean2")
public class test2 implements InitializingBean , DisposableBean {
    private test tx;


    public void  printhellobean(){
        tx.printhello();
        System.out.println("Secondly hello ");
    }

    public test2() {
    }

    public test2(test tx) {
        this.tx = tx;
        System.out.println("Constru");
    }

    public test getTx() {
        return tx;
    }

    public void setTx(test tx) {
        this.tx = tx;
    }

    @Override
    public void destroy() throws Exception {
        System.out.println("destrory test2");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("init test2");
    }
}

```

在配置文件里可以把上面的那句替换为

```
<conetext:component-scan base-package="org.example.testbean"></conetext:component-scan>
```

这句话默认是扫描org.example.testbean下的所有包并且找出带有注解的class

然后如果在@Component不加括号也可以加载到，只不过在主App中调用的方法有些不一样

加括号的：

```
package org.example;

import org.example.testbean.test;
import org.example.testbean.test2;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.context.support.FileSystemXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

import javax.sql.DataSource;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        //加载类路径下的配置文件
//        ApplicationContext stx = new ClassPathXmlApplicationContext("applicationContext.xml");
        ClassPathXmlApplicationContext stx = new ClassPathXmlApplicationContext("applicationContext.xml");
        // 加载绝对路径下的配置文件
        FileSystemXmlApplicationContext stx2 = new FileSystemXmlApplicationContext("F:\\bigdatajava\\src\\main\\resources\\applicationContext.xml");

        Resource resource = new ClassPathResource("applicationContext.xml");
        BeanFactory bf = new XmlBeanFactory(resource);
    
        test2 hellobean2 = (test2) stx.getBean("hellobean2");
        hellobean2.printhellobean();


//        DataSource hellobean = (DataSource) stx.getBean("dataSource");
//
//        DataSource dataSource = stx.getBean("dataSource" , DataSource.class);
//
//        DataSource dataSource1 = stx.getBean(DataSource.class);
//
//        System.out.println(hellobean);
        //hellobean.printhello();
        // 这个是比较暴力的方法直接杀死容器
        //stx.close();
        // 这个是告诉jvm当退出的时候关闭容器
        stx.registerShutdownHook();

    }
}

```

不加括号的：

```
package org.example;

import org.example.testbean.test;
import org.example.testbean.test2;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.context.support.FileSystemXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

import javax.sql.DataSource;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        //加载类路径下的配置文件
//        ApplicationContext stx = new ClassPathXmlApplicationContext("applicationContext.xml");
        ClassPathXmlApplicationContext stx = new ClassPathXmlApplicationContext("applicationContext.xml");
        // 加载绝对路径下的配置文件
        FileSystemXmlApplicationContext stx2 = new FileSystemXmlApplicationContext("F:\\bigdatajava\\src\\main\\resources\\applicationContext.xml");

        Resource resource = new ClassPathResource("applicationContext.xml");
        BeanFactory bf = new XmlBeanFactory(resource);

        test2 hellobean2 = (test2) stx.getBean(test2.class);
        hellobean2.printhellobean();


//        DataSource hellobean = (DataSource) stx.getBean("dataSource");
//
//        DataSource dataSource = stx.getBean("dataSource" , DataSource.class);
//
//        DataSource dataSource1 = stx.getBean(DataSource.class);
//
//        System.out.println(hellobean);
        //hellobean.printhello();
        // 这个是比较暴力的方法直接杀死容器
        //stx.close();
        // 这个是告诉jvm当退出的时候关闭容器
        stx.registerShutdownHook();

    }
}

```

通过上述我们发现这两种分别是通过类型，以及名称

关于component是一个大的注解

那么在这个大的注解下面我们细化分了三个小的

* @Controller : 表现层定义
* @Servirce ：业务层bean定义
* @Respository ： 数据层bean定义

其他的和上述一样

## 纯注解开发

经过上述简单的学习，我们已经知道了注解开发，那么我们能不能用注解开发来代替配置文件？

当然可以：

我们经过上述的操作之后我们的配置文件还有一句

```
<conetext:component-scan base-package="org.example.testbean"></conetext:component-scan>
```

我们可以简单创建给config包以及旗下的configspring.class

然后添加上两个注解

* @Configuration
* @ComponentScan

如下 ：

```
package org.example.config;


import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan("org.example.testbean")
public class configspring {
}

```

然后再更改app里的代码如下 ：注 上述 ComponentScan("org.example.testbean")这里的包名越详细越好 ，而且多个和包名的时候用大括号 -> ComponentScan({"org.example.testbean","org.example.config"})

```
ApplicationContext ztx = new AnnotationConfigApplicationContext(configspring.class);
```

然后就正常用就好了，相当于注解开发的时候无括号的模式

## 通过注解控制生命周期

通过注解控制生命周期的方法

如下 ：

* @Scope("singleton") ：是不是单例
* @PostConstruct :初始化方法
* @PreDestory ： 销毁方法
* 等
