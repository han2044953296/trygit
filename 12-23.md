---
title: scala
date: 12-23 8.40
categories: 日志
comments: "true"
tag: scala
---
# 简介

Scala是一门多范式的编程语言，一种类似[java](https://baike.baidu.com/item/java/85979?fromModule=lemma_inlink)的编程语言,设计初衷是实现可伸缩的语言,并集成[面向对象编程](https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B?fromModule=lemma_inlink)和[函数式编程](https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B?fromModule=lemma_inlink)的各种特性。

官网 ： `www.scala-lang.org`

scala 是运行在jvm上的 ，所以scala是可以兼容java的

scala产生 ： 基于java进行开发而来的

scala安装前提 ： jdk

运行 ： 也需要生成字节码文件 如何再运行

开发 ： scala 的发明者 martin 编译器爱好者

两个语言 ： pizza 和 scala

java ： java 1.5 ： 加了泛型 ，增强for ，自动类型转换以及包装类 =》 基于 pizza

java 1.8 ： 类型推断，以及lambel表达式 =》 基于scala 加进去的

# 为什么要学习scala

首要原因是因为一个框架 Spark  ： 其底层就是scala开发的

Spark ：支持很多的语言 java ，py 等

flink：底层是java+scala =》 所以它可以支持java编程，也可以用java编程 ，也支持了py =》 现在主流用java

开发效率高且简单容易

scala 和 Java 的代码可以相互调用

在spark里可以，但是会比较奇怪

# scala部署

## 版本选择

3.x

2.x

依赖于spark来决定的 ： 对于spark 3.0的时候已经移除了Scala 2.11版本

spark 3.x:scala 2.12/2.13

spark 2.x: scala 2.11/2.12

我们的spark用的是3.x版本 ，所以我们用的是scala 2.12.14

因为spark底层用的就是这个版本的

## 安装部署

win ： 安装 scala =》 idea里安装 scala 插件

linux ： 安装 scala =》 目的=> 调试自己开发的代码  =》 和spark 完全无关系

win安装： 解压 -》 配置环境变量

linux ： 解压-》软连接 -》 配置环境变量

输入scala之后进入到交互式界面

结果如下

```
scala> 1+2
res0: Int = 3

```

说明我们结果数据的类型在scala里是可以推断出来的 ，前面的我res0是变量的名字

在idea里安装scala的插件 ： 打开idea -》 file -》 setting -》 上方搜索栏目 输入 Plugin -》 点击 Marketplace 搜索 Scala 如何安装第一个插件 ，安装完成之后重启idea即可，重启之后点击file -》 Prtoject Structure -》 点击 -》 global libraries 点击上面的加号 然后点击 Brower 然后选中自己的scala的目录 -》 添加成功应用就ok了 -》 我们验证一下是不是好用-》创建一个文件夹 -》make dir as root -》 创建example 类 -》 创建 test.scala ->在pom文件中添加依赖-》 进入之后，创建 如下代码

```
package example.test

object scala {
  def main(args: Array[String]): Unit = {
    printf("撒更何况的客户打");
    printf("sadkakhjd")
  }
}

------------------------pom
    <dependency>
      <groupId>org.scala-lang</groupId>
      <artifactId>scala-library</artifactId>
      <version>2.12.14</version>
    </dependency>

```

执行看看成功

成功如下

```
撒更何况的客户打sadkakhjd
Process finished with exit code 0
```

maven地址：

# 基本语法

## 值与变量

java ：

* 数据类型 变量名=值
* Int num=值
* final 值 ： 定义常量

scala

* val 声明之后 不可改变 =》 final
* var 声明之后 可以改变

### 声明变量和值

var 变量名 ：数据类型 = 值

val 变量名 : 数据类型 = 值

其中 `val lsdjllsdf= 90`和 `val lsdjllsdf:Int= 90`

是一样的因为他会自己进行类型推断

在scala里定义了一个变量要初始化的 ： 显示初始化

在scala虽然不支持隐式初始化，不过可以通过占位符达到这个目的 `var name:String=_`仅仅是编译不报错，但是运行就会报错了

注意：占位符这种方式一定要明确是什么类型

一般用于定义类里的属性，不知道改怎么赋值的时候的使用的

### 数据类型

scala里没有包装类

* String
* Int
* Long
* Float
* Double
* Boolean
* Char
* Unit
* Short
* Byte
* List
* Option
* Yourclass
* 数据类型转换与判断
  * 在scala里最顶层的是any -》 object
  * 其下有Anyval 和 AnyRef
    * Anyval
      * Unit ： => void 就是返回值是为空
      * 其余和java都一样
      * 为空则是nothing
    * AnyRef
      * String在引用里
      * List
      * Option
      * Yourclass
      * 如果为空则为null
  * 最底层是nothing 包括null的底层也是nothing

转换代码如下

```
    val lsdjllsdf:Int= 90
    val num1:Int = 10
    val num2:Double = 10.111
    val num3=num2.asInstanceOf[Int]
    val num4=num2.toInt
    println(num1)
    println(num2)
    println(num3)
    println(num4)
```

注意scala里不能把字符串转换成Int（这里的字符串是非数字类型的）就是如果是11.111等数字类的还是可以的

比如 ：

```
val xiangxiang:String = "ads"
 val num6=xiangxiang.toInt
 println(num6)
```

就会报错

```
Exception in thread "main" java.lang.NumberFormatException: For input string: "ads"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at scala.collection.immutable.StringLike.toInt(StringLike.scala:304)
	at scala.collection.immutable.StringLike.toInt$(StringLike.scala:304)
	at scala.collection.immutable.StringOps.toInt(StringOps.scala:33)
	at example.test.scala$.main(scala.scala:19)
	at example.test.scala.main(scala.scala)
```

### 集合

array

Range

List

大类的角度上讲：

* Seq
* Set
* Map

最顶层是Iterable

* -》Set
  * HashSet
  * ListSet
  * SorteSet
    * TreeSet
    * BitSet
* -》Map
  * HashMap
  * SorteMap
    * TreeMap
  * ListMap
* -》Seq
  * indexSeq
    * Range
    * String
    * Array
    * NumericRange
    * Vector
  * LinearSeq
    * List
    * Stream
    * Queue
    * Stack

快速构建集合的方法：

range：

* to ： 左闭右闭
* until ： 左闭右开的

scala api 方法

方法调用 ： 变量打点调用或者xxx按一个空格调用

流程控制：scala里没三目运算符

* 分支结构 ：
  * if else
  * 模式匹配
* 循环
  * for
  * while
  * 算子

代码如下

```
    val Scaoe = 111
    if (Scaoe >= 90){
      println("牛皮")
    }else if (Scaoe >= 60){
      println("差点意思")
    }else if (Scaoe <= 59){
      println("欠打了")
    }
----------------------------------------------------------------------循环
    val ints:Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 89)
    val iterator = ints.toIterator
    while (iterator.hasNext){
      val item = iterator.next()
      println(item)
    }
      for (item <- ints){
        println(item)
      }
   ints.foreach(println(_))
```

### 方法与函数

最简单的理解 ： def 定义方法

函数的本质就是特殊的方法

def 方法名字（参数名字：参数类型）：返回值类型={方法体}

例子如下

```
    sum(num1, num3)
    def sum(a1:Int,a2:Int): Unit ={
      val i = a1 + a2
      println(i)
    }
    tery(xiangxiang)
    def tery(fff:String): Unit ={
      println(fff)
    }

```

补充 ： 方法的返回值类型也可以不写，因为它会自动推断的类型和val一样

后面的unit是代表方法的返回值，因为结尾是printf所以返回值是void

函数就是把方法的一些东西进行省略 -》 方法名+ 关键字

`val ff=(a1:Int,a2:Int)=>( a1 + a2)`

方法里的参数

* 默认参数 ： 常规传参="xxx"比如 ` def tery(fff:String="default"): Unit ={ println(fff) }`如果有多个参数默认参数不可以放到中间，只能放在最后一个，不传就走默认，传了就走传的值
* 可变参数 :   * 例子 ` def sum(num:Int*):Unit ={print(num.size)}` 可变参数一般都放在最后一个变量/传入一个数组 ` def sum(arr:_*):Unit ={}`

注意：方法是顺序的，如果没有定义过这个方法的时候调用它是会报错的

它可以不写返回值，因为它最后一行会默认被当成返回值

递归调用的时候一定要指明返回值类型，要不然会报错

## 类

类里有属性方法构造器

class：代码如下

```
package example.test

object t1 {
  def main(args: Array[String]): Unit = {
    val dl226 =new Dl2262
    dl226.name="子航"
    println(dl226.age)
    println(dl226.name)
    dl226.listening()
  }
  private val hh:Int=100

  class Dl2262{

    private val hs:Int=1
    var name: String = _
    val age:Int=20
    def listening(teacher:String="双喜") = {
      println("教师" + "\t" + teacher +  "正在上课" + "\n" +  name + "\t" +  "正在听课")
    }

  }

}

```

伴生类：class 是object的伴生类 ，object 是class的伴生对象 ：伴生类是相当于class 伴生方法是相当于静态方法

```
object t1 {
  def main(args: Array[String]): Unit = {
    val dd = new A
    dd.f01()
    A.f01()
  }  
class A{
    def f01()={
      println("class ....class A")
    }
  }
  object A{
    def f01()={
      println("Class ......object A")
    }

  }
```

### 常用的操作

apply方法 ： 这里往往使用object A里的apply方法 去 new 一个class A

如下 ：

```
object t1 {
  def main(args: Array[String]): Unit = {
    val dd = new A
    dd.f01()
    A.f01()
 val tets:A = A()
    tets.f01()
  }  
class A{
    def f01()={
      println("class ....class A")
    }
  }
  object A{
    def f01()={
      println("Class ......object A")
    }
	 def apply( ): A = new A()

  }

```

### 构造器

主构造器 ： `class 类名（参数列表）`

如下 ：

```
  class A(name:String , age:Int){
  
    def f01()={
      println("class ....class A" + name + age)
    }
  }
```

有参构造器，出现的化无参构造器就失效了
附属构造器 ： `this（）`每个附属构造器的第一行必须调用主构造器或者其他附属构造器

```
  class A(name:String , age:Int){
    def this(){
      this(name,age)
    }
    def f01()={
      println("class ....class A" + name + age)
    }
  }
```

### 继承实现

```
object t1 {
  def main(args: Array[String]): Unit = {

    val b = new B("dakhsk", "asdkajsdhas")
    b.fo2("kdahjakhd")
    println(b.age)
    b.foq("adkshk")

  }


  class jicheng(name:String){
    val age:Int=10
    def foq(parm:String): Unit ={
      println(parm+ age + name)
    }
  }
  class B(name:String , gerner:String) extends jicheng(name){
    def fo2(parm:String): Unit ={
      println(parm+name+gerner)
    }
  }
```

先触发父类的构造器，然后才是子类的

抽象类实例化，只能通过子类继承的方式实现如下

```
  abstract class Pression{
    def a
    def b
    def c
    var name:String
  }
  class c extends Pression{
    override def a: Unit = {

    }

    override def b: Unit = {

    }

    override def c: Unit = {

    }

    override var name: String = _
  }
  
```

特征：接口

创建一个Trait 就是特征 ，然后子类去继承它 ，不一定要全部实现，继承都用extends关键字

但是这里不能多继承

scala集合包 ：scala.collection

* 可变
* 不可变

主要是针对长度

array ：

* 可变：变长数组
* 不可变：定长数组
  * array：
    * new `val arr=new Array[String](3)`
      * 添加元素 `arr(0)="zahngsan"`
      * 查看数组长度 `arr.length`
    * 不new `val arr2 = Array("1" ,1 ,'1')或者指定类型`

数组的遍历

```
    val Arr = new Array[String](4)

    for (elem <- Arr) {
      println(elem)
    }
  // 这个by 就是设置步长，就是每次运行之后是加多少，还是减多少
    for (i <- 0 until(Arr.length) by 1){
      println(Arr(i))
    }
  
    Arr.foreach(println(_))
```

数组api

* 反转 ： `Arr.reverse`会新生成一个数组
* 两个数组相加 ： `Arr ++ arr`
* 求和，最大最小等 `Arr.max/min/sum`
* 把数组内的元素转换成字符串的方式进行输出 `Arr.mkString`会把数组的元素进行拼接并会变成String
  * 参数 ： mkString（开始的的符号 ，分隔符 ，结束的符号）

变长数组

* ArrayBuffer ：先导包 ：import scala.collection.mutable.ArrayBuffer
  * 添加元素 ： `a +=1 `
  * 添加数组 ： `a ++=Arr`
* api
  * 插入数据 ： `a.insert(2,3,43,45,5,6)`代表从第二个位置来插入后面的数组
  * 移除数据 ： `a.remove(0,3)`从下表0开始移除三个元素

高阶函数：scala里的高级的api 重要的和spark core 比较类似

必须学明白

函数 ：Function 格式 ：`var/val 名字 = (参数列表) => 函数体`如果函数体内只有一行代码，是可以省略大括号的

调用： `名字(参数)`关于函数的类型 是 `(入参类型，有几个参数就有几个)=>返回值类型`

函数是特殊的方法

scala里是可以方法套方法的

相互转化 ：

hello 方法 可以通过 hello_变成函数

方法里也可以嵌套函数 ： 就是高阶函数

例子 ：

```
val a = () => println("dl2262....")
val b = (x:Int , y:Int) => {x+y}
def foo(f:()=>Unit)={
f()
}
foo(a)
还可以这么传
foo(() => println("scala厉害"))
-----------------------------------------高阶函数

def test05()={
def cal(a:Int,b:Int,op:(Int,Int)=>Int)={
op(a,b)
}
}
println(cal(10,20,(x:Int,y:Int)=>x+y))
println(cal(10,20,(x,y)=>x+y))
println(cal(10,20,_+_))
```

### map

map是一一映射的

比如 ： f:a=>b 类似 y=f（x）

例子 ：数组成2

```
val arr = Array(1,2,3,4,5,6,7)
arr.map((x:Int)=>x*2)
简写 
arr.map((x)=>x*2)
arr.map(x=>x*2) //传入参数只有一个，括号可以省略
arr.map(_*2) // 前后只出现一次x，就是执行方法里，可以用_代替
```

例子：

把数组中的 ` var arr1 = Array("Flink" , "zihan")`变成小写

执行 `arr1.map(_.toLowerCase)`就ok了

补充数据类型 ：tuple元组 ： 定义方式 ： ` private val tuple: (Int, Int, Int) = (1, 2, 3)`

元素下标从1开始取用 `名称._num`取值

### foreach

map最好不要进行打印，因为map会制造一个结果集，括号里面速度Unit的

### filter

有返回值。返回值是一个Any的集合，过滤，括号内放布尔类型的值

```
val arr1 = List(1,2,3,4,5,6,7,78)
scala> arr1.filter(_%2!=1).filter(_>3)
res9: List[Int] = List(4, 6, 78)
```

### flatMap

和map的区别：首先 FlatMap会打破原来的数据结构 ，map不会

对比结果如下

```
scala> val arr3 = Array(Array(1,2),Array(3,4),Array(5,6))
arr3: Array[Array[Int]] = Array(Array(1, 2), Array(3, 4), Array(5, 6))

scala> arr3.map(x => x.map(_*2))
res20: Array[Array[Int]] = Array(Array(2, 4), Array(6, 8), Array(10, 12))

scala> arr3.flatMap(x=>x.map(_*2))
res21: Array[Int] = Array(2, 4, 6, 8, 10, 12)

scala> 
```

### flatten

把数组打平就是拆散，使用方法 `arr.flatten`

### reduce

规约的：把指定的业务逻辑作用两两的数据上

先对元素一和元素二进行操作，再把结果和元素三进行操作，以此类推

例子如下

```
scala> val arrr = Array(1,2,3,4,5,6,7,8,89,99)
arrr: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 89, 99)

scala> arrr.reduce((x,y)=>x+y)
res24: Int = 224

scala> arrr.reduce((x,y)=>{
   println(x,y)
   x+y
 })
     |      |      | (1,2)
(3,3)
(6,4)
(10,5)
(15,6)
(21,7)
(28,8)
(36,89)
(125,99)
res25: Int = 224

scala> 
```

reduce算子默认底层走的是reduceleft ，但是相应的也会有从右面的

如下

```
scala> arrr.reduceRight((x,y)=>{
   println(x,y)
   x+y
 })
     |      |      | (89,99)
(8,188)
(7,196)
(6,203)
(5,209)
(4,214)
(3,218)
(2,221)
(1,223)
res26: Int = 224

scala> 
```

### groupBy

用于分组：自定义分组 ，和sql里的group by 有点类似 ，

```
scala> val arr6 = Array(("a",100),("b",20),("c",15),("d",100))
arr6: Array[(String, Int)] = Array((a,100), (b,20), (c,15), (d,100))

scala> arr6.groupBy(_._1)
res27: scala.collection.immutable.Map[String,Array[(String, Int)]] = Map(a -> Array((a,100)), b -> Array((b,20)), c -> Array((c,15)), d -> Array((d,100)))
```

### MapValues

也是一一映射 ： 但是map的作用是作用在values上的，首先数据必须是kv的，map键值对/tuple2

补充map(k->v):一对一对的 `val a = Map("a" -> 24,"b"->33)`

就是单独取出其中的values，如下

```
    val arr6 = Array(("a",100),("b",20),("c",15),("d",100))
    arr6.groupBy(_._1).mapValues(_.map(_._2).sum)
```

### sortby

```
    val arr7 = Array(1,2,3,4,5,5,3,2,1,6)
    arr7.sortBy(x => x)
    arr7.sortBy(x => -x)
```

自动排序，升序不加负号，加了就是降序

### 实现wordcount

```
object Test{
  def main( args:Array[String]): Unit ={
    var lines = Array("wo men shi hao hai zi","wo jiao liu shen","what's your name")
    var words = Array("Hello world","Hello scala","Hello bigdata");

    /*1.为什么这里使用空格就可以将数组lines分开？
    2.这里的map(_.split(" "))可以这么理解，_.split(" ")中的_可以理解成"wo men shi hao hai zi","wo jiao liu shen","what's your name"中每个
    冒号的内容，然后将每个冒号的内容用空格分割。
     */
    var result1 = words.map(_.split(" "))

    /*
    1.将这个result1压平，压平的意思就是将多个Array数组压成一个Array数组
     */
    var result2 = result1.flatten

    /*
    1.将result2中的每个元素拿出来和1形成map元组
     */
    var result3 = result2.map((_,1))

    /*
    1.通过每个元组的第一个值来分组
    2.这里的分组方法因Scala/Spark等编程语言的不同而不同
    3.在scala中是groupBy，但是在spark中就是reduceByKey
    4.这里面的result4中的每个元素  都是一个元组
     */
    var result4 = result3.groupBy((_._1))

    /*
    1.这里的t._1中的t指的是元组中的一个元素，t._1指的是元组中第一个元素的第一部分
     */
    var result5 = result4.map(t =>(t._1,t._2.length))//唯一不明白的地方

    /*
    1.将得到的map转换成list，然后将list按照元组的第二部分来降序排序
     */
    var result6 = result5.toList.sortBy(_._2).reverse

    println(result6);
    /**
     * 1.flatMap()是通过切分开再压平  切分是通过.split(" ")方法
     * 2.map()方法是切分  map((_,1))是形成map序列 每个序列的value都是1
     * 3.groupBy()方法分组 groupBy((_._1))是通过每个元组的第一个值来分组
     * 4.toList()方法是转化成List序列  因为map是不支持排序的，所以使用List
     * 5.sortBy()方法是排序方法  sortBy(_._2)是通过元组的第二个元素来排序
     * 6.reverse()方法是倒转   将排序的结果降序排列
     * */
  }
}

----------------------------------------上面是网上的-------------------------------------------
----------------------------------------下面是我们自己写的-------------------------------------
worcountSource.map(_.split(",")).flatten.map((_,1)).groupBy(_._1).map((x=>(x._1,x._2.length))).toArray.sortBy(_._2) // 第一版
然后进行优化 ， 上述把字符串炸开的时候，.splite和.flatten =》替换成flatMap
mapValues =》可以替换后面进行数据统计的情况
worcountSource.flatMap(_.split(",")).map((_,1)).groupBy(_._1).mapValues(_.map(_._2).sum).toArray.sortBy(x=> -x._2) // 第二版
```

### 字符串插值：

shell ,python , scala 都有

```
scala> val hello:String = "hello"
 val str:String = hello + "scala"
hello: String = hello

scala> str: String = helloscala

scala> print(s"xxx_$str")
xxx_helloscala
scala> 
```

### 多行字符串

`val mes = """ sdhaskdj"""`

就是三次"",其中多行的字符串每行之间加上，就可以

## 集合

### List ：和Array类似

* 长度不可变 list
* 长度可变 listBuffer

Nil 是不可变的size为0的List

添加元素 ：`::追加元素 `这样是新生成一个数组，并不是再原来的数组上添加的

* `val a = 1::Nil`
* `li ++ List(1,2,3,4)`

取值 ：根据下标来取

api ：

* head：取出List的第一个元素
* tail：取出List的非第一个的所有元素

需求 ：使用scala求和的方法

```
    def sum(nums:Int*):Int={
      if (nums.length==0){
        0
      }else {
        nums.head+sum(nums.tail:_*)
      }
  
```

创建 可变的buffer：

```
val a = ListBuffer[Int]()
//添加元素
a+=2
a+=(2,3,4,5)
a++=List(1,2,3,4)
```

### set

创建 ：`val a = Set`

无序不可重复的

```
scala> val hh = Set(111,1,1,1,1,1,2,2,3,545)
hh: scala.collection.immutable.Set[Int] = Set(1, 2, 545, 3, 111)
```

### Map

创建 ：`val a = Map ("zs"->123,"lisi"->22)`

* 可变 ：可以重新进行赋值
* 不可变 ：不可以重新赋值 ：默认是不可变 创建的时候用可变map `val a =  scala.collection.mutable.Map()`

取值 ：

* a(zs) :通过key来取值
* a.get("zs"):api取值方法，查看这个map里的key，有则取出，无则是null
* a.getOrElse（"zs","默认值"）：取到就是map里的，取不到就是默认

更改 ：针对可变map

* a("zs")=18
* a.get("zs")=18
* 等等

添加元素 ：和上面List和Array是一样的 `a += (("zss" , 11))`或者 `a += ("fff"->111)`或者其他的方式，不止这些

```
scala> val t1 =  scala.collection.mutable.Map[String,String]()
t1: scala.collection.mutable.Map[String,String] = Map()

scala> t1 += ("ss" -> "sdlaks")
res54: t1.type = Map(ss -> sdlaks)

scala> t1
res55: scala.collection.mutable.Map[String,String] = Map(ss -> sdlaks)

scala> t1("ss")
res56: String = sdlaks

scala> t1.get("ss")
res57: Option[String] = Some(sdlaks)

scala> t1("ss")="1111"

scala> t1
res59: scala.collection.mutable.Map[String,String] = Map(ss -> 1111)

scala> t1.getOrElse("ss","nihao")
res60: String = 1111

scala> t1.getOrElse("ss1","nihao")
res61: String = nihao

```

## case class

和普通的class的区别

以后用样例类偏多 ， case class 不用new

case class 默认实现了序列化 ：重要

case class 底层重写了，toString ，equals , hashcode

```
case class Dog(name:String){
  def fo1(name:String): Unit ={
    print(name)
  }
}


-----------------------------------------主方法----------------
    val dog = Dog("旺财")
    dog.fo1("daksjhakl")



----------------------------------------------------------------------
scala> case class Dog(name:String){
   def fo1(name:String): Unit ={
     print(name)
   }
 }
     |      |      |      | defined class Dog

scala> import example.test.Dog
 
 val dog = Dog("旺财")
 
 val dog = Dog("旺财")
<console>:11: error: object Dog is not a member of package example.test
       import example.test.Dog
              ^

scala> 
scala> dog: Dog = Dog(����)

scala> 
scala> dog: Dog = Dog(����)

scala> val dog1 = Dog("旺财")
dog1: Dog = Dog(����)

scala> dog == dog1
res87: Boolean = true

scala> print(dog)
Dog(����)
scala> 

```

## 模式匹配

类似java中的switch case

匹配的内容

* 匹配内容
  * `xxx.match{case xxx => xxxx case yyy => yyy case_ => xxxx}`等
* 匹配类型
  * `xxx.match{case x:Int => xxxx case y:String =>yyy case_ => zzzz}`
* 匹配集合
  * `xxx.match{case x::y::Nil => println("集合中只有两个元素" case "zihang"::Nil => println(集合中只有一个元素就是子航)) case_ => println("other")}`
* 匹配样例类
  * 源码中用的比较多 ： 如下

```
case class Submak(){
}
case class hearetbeat(int: Int){
}
case class hhh(string: String){
}
-------main
    val rrr = Array(Submak , hearetbeat(111) , hhh("sdajkd"))

    rrr match {
      case Submak() => print("Submak")
      case  hearetbeat(int: Int) => print("sdahjd")
      case  hhh(string: String) => print("hh")
      case _ => print("没有")
    }
```

简单例子

```
    worcountSource.flatten.map(_.toString).map((_, 1)).groupBy(_._1).mapValues(_.map(_._2).sum).toArray.sortBy(_._2).map(_ match { case ("n" , int: Int) => print("找到") case _ => print("bus")})

```

代表可以和wordcount联用

### 偏函数

用法 ：定义一个方法，且他的返回值是偏函数

方法体里是一堆的case表达式

A是输入参数的类型，B是输出参数的类型

```
    def teacher:PartialFunction[String（A）,String（B）]={
      case "spark" => "dsadljaksld"
      case "hive"=> "asdad"
      case _ => "其他"
    }


------------------------------------调用
teacher（"xxx"）
```

一般用的很少

柯力化 =》 必然发生的结果 ，没有任何意义

例如 ：`def sum(x:Int,y:Int) => def sum(x:Int)(y:Int)`

上述就是柯力化，可以进行隐式转换来使用 -》 调用的时候也可以用柯力化的写法

### io =》 读写文件 url

如下：

```
scala> import scala.io.Source
 
 val source = Source.fromFile("F:\\bigdatajava\\src\\main\\resources\\wc.data")
import scala.io.Source

scala> 
scala> source: scala.io.BufferedSource = <iterator>

scala> val strings = source.getLines()
strings: Iterator[String] = <iterator>

scala> strings.foreach(println(_))
spark,linux
hadoop
linux,hive
flume

scala> 
```

上述这么读数据的话，数据只能使用一次，不管进行什么操作，甚至是比较，数据都会消失

需求 ：读取文件内容，统计文件每个单词出现的次数

如下：

```
    val source = Source.fromFile("F:\\bigdatajava\\src\\main\\resources\\wc.data")
    val strings = source.getLines()
    strings.toArray.flatMap(_.split(",")).map((_,1)).groupBy(_._1).map(x => (x._1 , x._2.length)).toArray.sortBy(s => -s._2).foreach(println(_))
```

### 隐式转换

类似于java力的动态代理 =》 为了增强

例子 ：A的一个类 -》 B类 B对A已经有的东西进行增强 -》 通过转换之后 B可以使用A已有的功能

场景 ：

* 隐式参数
* 隐式类 ： 高危
* 隐式类转换 ：

如下

```
package example.test

object te2 {

  def main(args: Array[String]): Unit = {

    implicit def mantoSuper(man: Man):SuperMan={
      new SuperMan(man.Name)
    }
    val zk = new Man("子涵 ")
    zk.fly()
  }
}

class Man(val Name:String){}

class SuperMan(Name:String){
  def fly()={
    print(Name+"can fly")
  }
}
```

隐式转换可以作用于基本类型如下

```
class Cal(X:Int){
  def add(a:Int): Unit ={
    print(a+X)
  }
}
---------------------------main
 implicit def INttoadd(x:Int):Cal={
      new Cal(x)
    }
    4.add(7)
```

通过隐式的方法往javaio中添加read方法

```
class RichFile(file:File){

  def read()={
    Source.fromFile(file.getPath).getLines().mkString("\n")
  }
}
---------------------------------------------------main
 implicit def ADDREAD(file:File):RichFile={
      new RichFile(file)
    }
    var q = new File("F:\\bigdatajava\\src\\main\\resources\\wc.data")
    println(q.read())

```

🐂的

## 泛型

方法中的泛型：

```
abstract class MsG[T](content:T)

class Wechat(conte:String) extends MsG(conte)
class QQChat[Int](cont:Int) extends MsG(cont)
class ZFBchat(con:BigInt) extends MsG[BigInt](con)
```

例子 ：

```
class boy[A,B,C](val hashband:A,val heigtt:B,val chuanzhuio:C){
  override def toString: String = hashband +"\t"+ heigtt+"\t"+chuanzhuio
}
----------------------------------枚举
  object Facevalue extends Enumeration{
    type Face = Value
    val A,B,C,D = Value
  }
---------------------------main
new boy[example.test.te2.Facevalue,Int,Double](Facevalue.A,181,9)
```

上下界 ：

* 上界：`<T extends Test>`:T是Test的子类 / `<? extends Test>`
* 下界：`<T extends Test>`:T可以说Test的父类 / `<? extends Test>`
* 逆变 vs 协变 =》 + -

### 排序 ：

scala

* Ordering -> comparator
* Ordered -> comparable

重点 ：

* 高级api
* 基本类型使用
* 模式匹配
* 隐式转换
* 类的定义

续讲scala

# Actor

scala里的actor并发效率要比java更高级。学习为了后续的akka基本铺垫

对于java中的并发要设置线程任务，通过监视器维持线程的稳定性，启动线程，加锁等方式。但是这样会有共享内存变量。也就是可能产生死锁，资源争夺等问题。

而actor并发编程是一种不共享内存的，依靠消息进行传递的。避免一些死锁等问题。当一个actor需要一些资源的时候，其他actor会给他传递一些消息作为需要的信息。

```
注意：scala在2.11.x版本中加入了akka并发编程框架，后续已经废弃了actor
actor的编程模型和akka非常像。
```

## 创建actor对象

定义class/object继承actor类。

重写actor方法

调用actor里的start方法

```
注意每个actor是并行的互不影响
```

3238496

3238495

3238495

3134875

3039034

3132903
