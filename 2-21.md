---
title: mysqlbinlog
date: 2-21 8.40
categories: 日志
comments: "true"
tag: mysql
---
# bionlog

mysql的binlog：它记录了所有的DDL和DML语句（除了数据查询语句select）,以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。

mysqlbinlog常见的选项有一下几个：

* --start-datetime：从二进制日志中读取指定等于时间戳或者晚于本地计算机的时间
* --stop-datetime：从二进制日志中读取指定小于时间戳或者等于本地计算机的时间 取值和上述一样
* --start-position：从二进制日志中读取指定position 事件位置作为开始。
* --stop-position：从二进制日志中读取指定position 事件位置作为事件截至

binlog日志有两个最重要的使用场景:

* mysql主从复制：mysql replication在master端开启binlog,master把它的二进制日志传递给slaves来达到master-slave数据一致的目的。
* 数据恢复：通过mysqlbinlog工具来恢复数据。

binlog日志包括两类文件

* 二进制日志索引文件(文件名后缀为.index)用于记录所有的二进制文件。
* 二进制日志文件(文件名后缀为.00000*)记录数据库所有的DDL和DML(除了数据查询语句select)语句事件。

# 开启binlog日志

打开mysql的配置文件一般是在 `/etc/my.cof`

然后编辑，在mysqld区块加上 ->

```
binlog_format           = MIXED                 //binlog日志格式
log_bin                     =目录/mysql-bin.log    //binlog日志名
expire_logs_days     = 7                //binlog过期清理时间
max_binlog_size     = 100m                    //binlog每个日志文件大小　　　　log-bin=mysql-bin(也可指定二进制日志生成的路径，如：log-bin=/opt/Data/mysql-bin)
server-id = 1
　　　　server-id=1

　　　　binlog_format=MIXED(加入此参数才能记录到insert语句)
```

这里的binlog的格式有三种

* Statement：每一条会修改数据的sql都会记录在binlog中。

```
优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所产生的日志量会增加多少，以及带来的IO性能问题。)

缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).
```

* Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。

```
优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题

缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。
```

* Mixedlevel:

```
.Mixedlevel: 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。
```

## binlog日志的选择

Mysql默认是使用Statement日志格式，推荐使用MIXED.

由于一些特殊使用，可以考虑使用ROWED，如自己通过binlog日志来同步数据的修改，这样会节省很多相关操作。对于binlog数据处理会变得非常轻松,相对mixed，解析也会很轻松(当然前提是增加的日志量所带来的IO开销在容忍的范围内即可)。

## 续讲mysql

查看binlog日志是不是开启

`mysql> show variables like 'log_%'; `

## 常用的binlog日志操作命令

查看所有binlog日志列表：
`show master logs;`

查看master状态，即最后（最新）一个binlog日志的编号名称，及其最后一个操作事件pos结束点(Position)值。

`show master status;`

flush 刷新log日志，自此刻开始产生一个新编号的binlog日志文件;

`flush logs;`

注意：每当mysqld服务重启时，会自动执行此命令，刷新binlog日志；在mysqlddump备份数据时加-F选项也会刷新binlog日志；

重置（清空）所有binlog日志

`reset master;`

# 查看binlog日志

binlog是二进制文件，普通文件查看器cat、more、vim等都无法打开，必须使用自带的mysqlbinlog命令查看。

binlog日志与数据库文件在同目录中。

在Mysql5.5以下版本使用mysqlbinlog命令时如果报错，就加上"--no-defaults"选项

使用的就是上面的，命令
