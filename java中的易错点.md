---
title: java面试题
date: 2022-10-15 17:44:10
categories: Java中的易错点
comments: "true"
tag: java面试
---
# 重载和重写

## 重载

重载发生在同一个类里，方法名必须相同，参数类型不同，个数不同，顺序不同，方法的返回值和访问修饰符可以不同，发生在编译时

## 重写

发生在父类和子类中，方法名，参数列表相同，返回值范围小于等于父类，
抛出异常小于等于父类，访问修饰符大于等于父类，若父类的方法是private则不能重写

# List和Set的区别

## List

list是有序的，按照插入对象的顺序进行访问的，可重复，，可以有多个null元素，可以用iterator取出所有元素，在逐一遍历还可以用get（index）获取指定元素

## Set

set是无序的，不可重复，，最多有一个null对象取元素的时候只能用iterator接口取出所有元素，再逐一遍历

# 谈谈Concurrent Hash Map的扩容机制

## 1.7jdk

- 1.ConcurrentHashMap是基于Segment来实现的
- 2.每个Segment相当于是一个小型的HashMap
- 3.每个Segment内部都会进行扩容，和HashMap的扩容逻辑相同
- 4.先生成一个新的数组，然后转移元素到新数组中
- 5.扩容的判断也是每个Segment单独进行判断的

## 1.8jdk

- 1.到了1.8 就不基于Segment了
- 2.当某个线程进行put的时，如果发现有扩容的，就会优先跟着一起进行扩容，
- 3.如果发现没有进行扩容的，就会把key-value添加到ConcurrentHashMap中然后判断超过阈值了吗超过了则进行扩容
- 4.ConcurrentHashMap是支持多线程同时扩容的
- 5.扩容之前也先生成一个新数组
- 6.转移元素之前先将元素分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或者多组的元素转移工作

# jdk1.7到1.8HashMap发生了什么变化

## 1.7

其底层是数组加链表
使用的是头插法
哈希算法比较复杂

## 1.8

其底层是数组+链表和红黑树加入红黑树的目的是加快查找效率
其用的是尾插法，要先遍历数组的每个元素，判断数组中的元素个数
哈希算法进行了优化，节省cpu资源

# 接口可以多继承接口

# 深拷贝和浅拷贝

浅拷贝是指只会拷贝基础类型的值
浅拷贝是指拷贝的地址指向同一目标

# CopyOnwriteArrayList底层

- 1.首先其内部也是通过数组实现的，在向其中加元素的时候时，会复制一个新数组 ， 并在新数组上进行进行写操作 ， 读操作在原数组上进行
- 2.并且写操作会加锁，防止出现写入数据丢失的问题
- 3.写操作结束之后会把原数组指向新数组
- 4.CopyOnWriteArrayList允许在写数据的同时进行读数据，大大提高了效率因此适合读多写少的场景，但其比较占内存，因此读到的数据并不是最新的，因此适用与实时性不强的地方

# 什么是字节码 字节码的好处

编译器Javac会将java源文件编译为.class可以做到一次编译到此处运行，例如，windows上编译好的.class可以在linux上运行。

## 采用字节码的好处

一方面实现了跨平台，另外一方面提高了代码的执行效率，让编译器可以在编译时进行优化

# 在java的异常处理机制中，什么时候要抛出异常，什么时候捕获异常

异常相当于一种提示 ， 若我们抛出异常，就相当于告诉上层方法，我抛出了一个异常，我处理不了这个异常给你来处理，如果上层也处理不了，就继续往上抛，或者捕获

# java中异常体系是怎么样的

java中所有异常都来自于顶级父类 Throwable
Throwable下有两个子类Exceptio 和 erro
error属于重大错误：包括但不限于 虚拟机，磁盘，操作系统层面的问题
Exception属于普通编译器报错，其还分为运行时异常和编译时异常

# 包装类型传参数的时候按照基本类型算，只传值，不传地址

# java中的类加载机制

jdk中自带了三个类加载器：

## BootStrap ClassLoader

BootStrap是Ext的父类加载器默认负责加载%JAVA_HOME%lib下面的lib和class

## Ext ClassLoader

Ext ClassLoader是AppClassLoader的父类，默认加载%JAVA_HOME%/lib/ext文件夹下的jar包和class

## AppClassLoader

AppClassLoader是自定义器的加载器的父类，负责加载classpath下的

# 双亲委派机制

简单来说就是当问题从最下面的类加载器进入的时候会先让最上面的类加载器加载，然后逐级往下，最后才是自己定义的类加载器

# 排查JVM问题

## 对于还可以正常运行的系统

- 可以使用jmap来查看各个区域的情况
- 可以通过jstack来查看线程的运行情况，比如xxx线程阻塞；是不是死锁等
- 可以通过jstat命令查看垃圾回收的情况 ， 特别是fullgc若fullgc比较多就要考虑调优了
- 通过各个命令的结果，或者jvisualvm等工具进行分析
- 猜测fullgc多的原因：如果无内存溢出，那么表示fullgc是回收了很多对象，所以这些对象最好能在younggc过程中直接回收，避免进入老年代，对于这些情况就要考虑存活区间是不是比较小，导致年轻代放不下，直接到了老年代，尝试加大年轻代的区间若改完fullgc变小，则猜想正确

## 对于已发生了OOM的系统

- 一般生产中都会设置系统发生了OOM时，生成当时的dump文件（-xx:+HeapDumpOnOutOfMemoryError -xx:HHEapDump Path = /user/local/base)
- 我们可以用jsvisualvm等工具进行分析dump
- 根据dump找到异常实例和线程（占用cpu高），定位到具体代码。
- 之后再做细致的分析

# 一个对象从加载到jvm到被Gc清楚都经历了什么

- 先把字节码文件内容加载到方法区
- 然后再根据类信息在堆区域创建对象
- 对象首先会分配在堆中年轻代的Eden区经过一次Minorc之后会进入Survivor区，在后续的每次MinorGC中若一直存活，则会在Suvivor区来回拷贝，每拷贝一次每移动一次年龄加1
- 当年龄过15，若对象仍存活，会进入老年态
- 若经过fullgc，被标记为垃圾对象，那么会被gc线程清楚

# jvm有哪些垃圾回收算法

## 标记清除法

- 标记阶段：把垃圾内存标记出来
- 清除阶段：直接把垃圾内存回收
- 问题：会产生大量的内存碎片

## 复制算法

- 为了解决标记清除的内存碎片的问题
- 将内存分为两份，每次只使用其中一半，垃圾回收时将当前这一块的存活对象完全拷贝到另外一半，而后当前这一半可直接清除，这种无内存碎片，但是浪费空间，且放弃和存活对象的个数相关

## 标记压缩算法

- 为了解决复制算法的缺陷，就提出了标记压缩算法，这种算法在标记阶段跟标记清除算法是一样的，但是在完成之后不是直接清理，而是将存活的对象往一端移动，而后面将边界以外的所有内存清除

# 什么是STW

Stw-stop-the-world,是在垃圾回收算法执行过程中要将JVM内存冻结的一种状态，在STW状态下，java的所有线程都是停止执行的——GC除外，native方法可执行；但是不能与jvm交互GC各种算法的优化的重点便是减少STW,是jvm调优的重点

# jvm参数

- 标注指令：开头这个是所有Hotspot都支持的参数，可以用java-help
- 非标注指令:-x开头；与特定的hotspot对立的用java-x打印
- 不稳定参数：-xx开头，与上面一样

# 对守护线程的理解

线程分为 守护线程和用户线程

## 守护线程

是jvm的后台线程，比如垃圾回收器，守护线程会在其他线程都停止之后自动关闭，我们可以通过设置thread.setDemon（true）来把一个线程设置成守护线程

## 普通线程

普通用户的线程

# ThreadLocal的底层原理

其是java中所提供的线程本地存储机制，可利用该机制将数据存储到一个线程内部，该线程可在任意时刻，任意的方法，获取其存储的数据

- 其底层是通过ThreadLocalMap来实现的，Map的key为ThreadLocal对象，Map的value为需要缓存的值
- 如果在线程池中使用ThreadLocal会造成内存泄露，因为当ThreadLoccal对象用完之后应该把设置的key value 也就是Entry的对象进行回收，但是线程池的线程不会进行回收，而线程对象是通过强引用指向ThreadLocalMap而ThreadLocalMap也是通过强引用的方法指向Entry的对象，线程也就不会被回收，从而出现内存泄露。

## 解决方法

- 在使用了ThreadLocal对象之后，手动调Thread Local的remove方法，手动清除Entry，其经典应用是用在连接管理上

# 并发,并行,穿行的区别

- 串行：一个任务执行完才可以执行下一个
- 并发：两个任务看起来是一起执行的，在底层，两个任务被拆成了很多份，从而后一个执行，但是在更高处看，两个任务是一起执行的
- 并行：两个可以一起执行

# java死锁如何避免

- 一个资源每次只被一个线程调用
- 一个线程在阻塞资源的时候不释放已经占有的资源
- 一个线程已经获得的资源在使用之前不可被强行剥夺
- 若干个线程形成头尾相接的循环等待状

# 说一下HashMap的put方法

## 大体流程

- 1.根据key通过哈希算法与与运算得出数组的下标
- 2.如果数组下标的元素为空 ， 则将key和value封装为entry对象（1.7中是Entry ， 1.8里是node对象）并放入该位置

## 如果数组下标不为空，分情况讨论

### 1.7jdk

- 要先判断是不是要扩容，如果不扩容就生成Entry对象，并且用头插法添加到当前位置的链表中

### 1.8jdk

- 会先判断当前位置上node的类型，看是红黑树node还是链表node
- 如果是红黑树node，则会将key和value封装为一个红黑树节点并添加到红黑树中去，这个过程中会判断是不是有当前key，如果存在则更新value
- 如果此位置是node对象是链表节点，则将key和value封装为一个链表node并通过尾插法插到链表最后去，因为是尾插法所以要遍历整个链表，在遍历链表的过程中会判断是不是存在当前的key如果存在就更新key，当遍历完链表后，将新node插入到链表中，插入链表1后会看到当前链表的节点个数，如果大于等于8就会把这个链表转化为红黑树
- 将key和value封装为node插入到链表或红黑树中再判断是不是需要扩容如果需要就扩容，不需要就结束put方法

# 线程池的底层工作原理

- 线程池内部是通过队列＋线程实现的，当我们用线程池执行任务的时候
- 如果此时线程池中的线程数量小于CorePoolSize，即使线程池中都处于空闲状态，也同样要创建新的线程来处理被添加的任务
- 如果此时线程池中的线程数量等于CorePoolSize, 但是缓存队列workQueue未满，且线程池中的数量小于maximumPoolsize

# 线程池为什么是先添加队列而不是先创建最大线程

当线程池中的核心线程在忙时如果继续往线程池中添加任务，那么任务还会放入队列，队列满了之后，才会开始新的线程，这就相当于，一个公司本来有10个程序员，本来这10个程序员能正常处理各种需求，但是随着公司的发展，需求在慢慢增加，但是一开始这些需求只会增加在待开发列表中，然后这10个程序员加班加点的从待开发列表中获取需求并进行处理，但是某一天待开发列表满了，所以员工处理不过来了，所以就开始招募新员工了。

# ReentrantLock中的公平锁和非公平锁的底层实现

首先不管是公平锁还是非公平锁他们的底层都是通过AQS来实现排队的，他们的区别在于：线程使用lock（）方法加锁的时候，如果是公平锁，会先检查AQS队列中是不是存在线程在排队，如果存在，则当前线程也会进行排队，如果是非公平锁，则不会去检查是不是有线程在排队，而是直接竞争锁，不管是公平锁还是非公平锁，一旦没竞争到锁，就会进行排队，当锁释放的时候都是唤醒最前面的线程，所以非公平锁只是体现在了线程加锁的阶段，而没有体现在线程被唤醒的阶段。

# ReentrantLock中tryLock()和lock（）方法的区别

- tryLock()表示尝试加锁，可能加到，也可能加不到，该方法不会阻止线程，如果加到锁就返回true，没有加到则返回false
- lock（）则表示线程阻塞加锁，线程会阻塞直到加上锁，而且也没有返回值

# CountDownLatch和Semaphore的区别和底层原理

- CountDownLatch表示计数器，可以给CountDownLatch设置一个数字，一个线程调用CountDownLatch的await（）将会被阻塞，其他线程可以调用CountDownlatch的countDown（）方法来对CountDownLacth中的数字减一，当一个数字被减为0之后则会将AQS中排队的线程依次唤醒
- Semaphore表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使用该信号量，通过acquire来获取许可，如果没有许可可用则用线程阻塞，并通过ASQ来排队，可以通过release的方法释放许可当某一个线程释放死锁之后会从ASQ的第一个线程开始依次唤醒，直到没有空闲许可

# Sychronized

- 偏向锁： 在锁对象的对象头中记录下当前获取到该锁的线程id，该线程下次如果又来获取该锁就可以直接获取到了
- 轻量级锁：由偏向锁升级而来，当一个线程获取到锁之后，此时这把锁是偏向锁，此时如果由第二个线程来竞争这个锁，偏向锁就会升级为轻量级锁，之所以叫轻量级锁是为了和重量级锁分开，轻量级锁底层是通过自旋来实现的，并不会阻塞线程。
- 如果自旋次数过多扔无法获取锁，则会升级为重量级锁，重量级锁会导致线程阻塞
- 自旋锁：自旋锁就是在线程获取锁的过程中，不回去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是要操作系统中去实现的，比较耗费时间，自旋锁是线程通过CAS获取预期的一个标记，如果没有获取到，则继续循环获取去过获取到，则表式获取到了锁，这个过程线程一直在运行，相对而言没有使用太多的操作系统资源，比较轻量

# Sychronized和ReentrantLock的区别

- 前一个是关键字，后一个是一个类
- 前一个会自动加锁和释放锁，后面一个需要手动加锁和个释放锁
- 前一个底层是jvm层面 ， 后面一个底层是api层面
- 前一个是非公平锁 ， 后面一个是可以选非公平或者公平
- 前一个锁的是对象所信息保存在对象头中，后面一个是通过代码中int型的state标识符状态
- 前一个底层有个锁升级的过程

# 谈谈你对AQS的理解，AQS如何实现可重入锁

- AQS是一个java线程同步的框架，是jdk中很多锁的工具核心框架
- 在AQS中，维护了信号量state和一个线程的双向链表队列，其中这个线程队列，就是用来给线程排队的而state就像是个红绿灯，用来控制排队
- 在不同的场景下，有不同的意义
- 在可重入锁这个场景下state用来保证加锁的次数，0表示标识无锁，每次加锁，states就加1，释放就减少1

# 谈谈你对IOC的理解

- 通常我们任务spring有两大特性IoC和AOP
- IoC进行了对象的反转，就是对象控制权的转移

# 单例和Bean

- 单例表示这个类只能实例化一次
- 而bean并不表示jvm里只存在一个类的Bean

# Spring的事务传播机制

- 多个事务方法互相调用的时候，事务是如何在这些方法之间传播的
- REQUIRED（默认的传播机制）：如果没有事务，就自己创建一个新的事务，如果存在事务，就加入
- SUPPIORTS：当前存在事务，则加入，如果不存在就按照不存在的来
- MANDATORY：当前存在事务则加入，不存在则抛出异常
- REQUIRES_NEW：创建一个新事务，如果存在这个事务，就挂起他
- NOT_SUPPORTED:用非事务的方式执行，如果当前存在事务，则挂起事务
- NEVER：不使用事务如果事务存在，则会抛出异常
- NESTED：如果当前事务存在，则在嵌套事务中执行要不然就和REQUIRED一样

# 线程和协程的区别

- 线程与协程的区别：
- 1：包含关系：一个进程可以有多个协程，一个线程也可以有多个协程
- 2：同步：线程进程是同步，协程是异步
- 3：协程能保留上一次重入的状态，当程序重新调用时，可以直接进入上一次的调用的位置
- 4：资源占用：线程是抢占式，协程是非抢占式，也就是会所在同一时间只能有一个协程运行，相当于单线程
- 5：与线程调用关系：协程并不能代替线程，线程是分割的CPU资源，协程是执行的代码，协程并不会直接调用线程，它会调用线程的执行器

# myysql的索引以及他们的好处和坏处

- 优点： 1.大大加快数据的检索速度
- 2.通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
- 缺点： 1.时间方面：创建索引和维护索引要耗费时间，索引需要动态的维护
- 2.空间方面：需要占物理空间

# 多线程

- 现代操作系统中，进程是分配资源的最小单位，运行一个程序，就创建一个进程，一个进程里可以包括多个线程，线程是系统调度的基本单位， 每个线程里都拥有各自的程序计数器，堆栈，局部变量表等属性，并且共享进程里面的资源，处理器在这些线程之间高速切换，使使用者误以为这些线程是同时执行的。
- 对于最简单的输出hello world程序，就包括四个线程， main，清除reference的线程，和finalize方法有关的线程，处理jvm信号的线程，
- 之所以使用多线程是因为多线程有个好处
- 1.现代计算机是多核处理器，而一个线程同一时刻只能运行在一个处理器上，对于单线程程序，同一时刻只能使用一个处理器，显然这是一种资源浪费， 而对于多线程程序，可以把计算逻辑分配给不同的处理器，极大的提高的程序的执行效率
- 2.可以把复杂的业务逻辑种的对数据一致性要求不强的操作，比如生成订单快照分配给其他的线程去处理（也可以使用消息队列），极大的提高了程序的响应时间
- 3.java提供了一个良好的多线程模型，能是开发者专注于业务的开发

# 怎么保证线程安全

- Java保证线程安全的方式有很多,其中较为常用的有三种,按照资源占用情况由轻到重排列,这三种保证线程安全的方式分别是原子类、volatile、锁。
- JDK从1.5开始提供了java.util.concurrent.atomic包,这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。
- 在atomic包里一共提供了17个类,按功能可以归纳为4种类型的原子更新方式,分别是原子更新基本类型、原子更新引用类型、原子更新属性、原子更新数组。
- 无论原子更新哪种类型,都要遵循“比较和替换”规则,即比较要更新的值是否等于期望值,如果是则更新,如果不是则失败。
- volatile是轻量级的synchronized,它在多处理器开发中保证了共享变量的“可见性”,从而可以保证单个变量读写时的线程安全。
- 可见性问题是由处理器核心的缓存导致的,每个核心均有各自的缓存,而这些缓存均要与内存进行同步。
- volatile具有如下的内存语义：当写一个volatile变量时,该线程本地内存中的共享变量的值会被立刻刷新到主内存；当读一个volatile变量时,该线程本地内存会被置为无效,迫使线程直接从主内存中读取共享变量。
- 原子类和volatile只能保证单个共享变量的线程安全,锁则可以保证临界区内的多个共享变量的线程安全,Java中加锁的方式有两种,分别是synchronized关键字和Lock接口。
- synchronized是比较早期的API,在设计之初没有考虑到超时机制、非阻塞形式,以及多个条件变量。
- 若想通过升级的方式让它支持这些相对复杂的功能,则需要大改它的语法结构,不利于兼容旧代码。
- 因此,JDK的开发团队在1.5新增了Lock接口,并通过Lock支持了上述的功能,即：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）。
- 加分回答 实现线程安全的方式有很多,除了上述三种方式之外,还有如下几种方式：
- 1. 无状态设计 线程安全问题是由多线程并发修改共享变量引起的,如果在并发环境中没有设计共享变量,则自然就不会出现线程安全问题了。这种代码实现可以称作“无状态实现”,所谓状态就是指共享变量。
- 2. 不可变设计 如果在并发环境中不得不设计共享变量,则应该优先考虑共享变量是否为只读的,如果是只读场景就可以将共享变量设计为不可变的,这样自然也不会出现线程安全问题了。具体来说,就是在变量前加final修饰符,使其不可被修改,如果变量是引用类型,则将其设计为不可变类型（参考String类）。
- 3. 并发工具 java.util.concurrent包提供了几个有用的并发工具类,一样可以保证线程安全：
- Semaphore：就是信号量,可以控制同时访问特定资源的线程数量。
- CountDownLatch：允许一个或多个线程等待其他线程完成操作。
- CyclicBarrier：让一组线程到达一个屏障时被阻塞,直到最后一个线程到达屏障时,屏障才会打开,所有被屏障拦截的线程才会继续运行。
- 4. 本地存储 我们也可以考虑使用ThreadLocal存储变量,ThreadLocal可以很方便地为每一个线程单独存一份数据,也就是将需要并发访问的资源复制成多份。这样一来,就可以避免多线程访问共享变量了,它们访问的是自己独占的资源,它从根本上隔离了多个线程之间的数据共享。

# 死锁

- 1. 死锁 两个或两个以上的进程在执行过程中,因争夺共享资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。
- 2. 产生死锁的必要条件 虽然进程在运行过程中,可能发生死锁,但死锁的发生也必须具备一定的条件,死锁的发生必须具备以下四个必要条件：
- - 互斥条件：指进程对所分配到的资源进行排它性使用,即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源,则请求者只能等待,直至占有资源的进程用毕释放；
- - 请求和保持条件：指进程已经保持至少一个资源,但又提出了新的资源请求,而该资源已被其它进程占有,此时请求进程阻塞,但又对自己已获得的其它资源保持不放；
- - 不剥夺条件：指进程已获得的资源,在未使用完之前,不能被剥夺,只能在使用完时由自己释放；
- - 环路等待条件：指在发生死锁时,必然存在一个进程——资源的环形链,即进程集合 {P0,P1,P2,···,Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源,……,Pn 正在等待已被 P0 占用的资源。

# 进程间的通信方式

- 进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket：
- 1. 管道 管道也叫无名（匿名）管道,它是是 UNIX 系统 IPC（进程间通信）的最古老形式,所有的 UNIX 系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区,Linux 系统中通过 pipe() 函数创建管道,会生成两个文件描述符,分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。
- 2. 命名管道 匿名管道,由于没有名字,只能用于亲缘关系的进程间通信。为了克服这个缺点,提出了有名管道（FIFO）,也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联,以 FIFO 的文件形式存在于文件系统中,并且其打开方式与打开一个普通文件是一样的,这样即使与 FIFO 的创建进程不存在亲缘关系的进程,只要可以访问该路径,就能够彼此通过 FIFO 相互通信,因此,通过 FIFO 不相关的进程也能交换数据。
- 3. 信号 信号是 Linux 进程间通信的最古老的方式之一,是事件发生时对进程的通知机制,有时也称之为软件中断,它是在软件层次上对中断机制的一种模拟,是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断,转而处理某一个突发事件。
- 4. 消息队列 消息队列就是一个消息的链表,可以把消息看作一个记录,具有特定的格式以及特定的优先级,对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息,对消息队列有读权限的进程则可以从消息队列中读走消息,消息队列是随内核持续的。
- 5. 共享内存 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分,因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中,并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比,这种 IPC 技术的速度更快。
- 6. 内存映射 内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存,用户通过修改内存就能修改磁盘文件。
- 7. 信号量 信号量主要用来解决进程和线程间并发执行时的同步问题,进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为 P 操作和 V 操作,P 操作是将信号量的值减 1,V 操作是将信号量的值加 1。当信号量的值小于等于 0 之后,再进行 P 操作时,当前进程或线程会被阻塞,直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时。
- 8. Socket 套接字（Socket）,就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端,提供了应用层进程利用网络协议交换数据的机制。Socket 一般用于网络中不同主机上的进程之间的通信。

# MVC模式

- MVC是一种设计模式,在这种模式下软件被分为三层,即Model（模型）、View（视图）、Controller（控制器）。
- Model代表的是数据,View代表的是用户界面,Controller代表的是数据的处理逻辑,它是Model和View这两层的桥梁。
- 将软件分层的好处是,可以将对象之间的耦合度降低,便于代码的维护。
- Model：指从现实世界中抽象出来的对象模型,是应用逻辑的反应；它封装了数据和对数据的操作,是实际进行数据处理的地方（模型层与数据库才有交互）。
- 在MVC的三个部件中,模型拥有最多的处理任务。被模型返回的数据是中立的,模型与数据格式无关,这样一个模型能为多个视图提供数据,由于应用于模型的代码只需写一次就可以被多个视图重用,所以减少了代码的重复性。
- View：负责进行模型的展示,一般就是我们见到的用户界面。
- Controller：控制器负责视图和模型之间的交互,控制对用户输入的响应、响应方式和流程；它主要负责两方面的动作,一是把用户的请求分发到相应的模型,二是吧模型的改变及时地反映到视图上。
- 加分回答 为了解耦以及提升代码的可维护性,服务端开发一般会对代码进行分层,服务端代码一般会分为三层：表现层、业务层、数据访问层。在浏览器访问服务器时,请求会先到达表现层 最典型的MVC就是jsp+servlet+javabean模式。
- 以JavaBean作为模型,既可以作为数据模型来封装业务数据,又可以作为业务逻辑模型来包含应用的业务操作。 JSP作为视图层,负责提供页面为用户展示数据,提供相应的表单（Form）来用于用户的请求,并在适当的时候（点击按钮）向控制器发出请求来请求模型进行更新。
- Serlvet作为控制器,用来接收用户提交的请求,然后获取请求中的数据,将之转换为业务模型需要的数据模型,然后调用业务模型相应的业务方法进行更新,同时根据业务执行结果来选择要返回的视图。 当然,这种方式现在已经不那么流行了,
- Spring MVC框架已经成为了MVC模式的最主流实现。
- Spring MVC框架是基于Java的实现了MVC框架模式的请求驱动类型的轻量级框架。前端控制器是DispatcherServlet接口实现类,映射处理器是HandlerMapping接口实现类,视图解析器是ViewResolver接口实现类,页面控制器是Controller接口实现类

# redis的数据类型

- Redis主要提供了5种数据结构：字符串(string)、哈希(hash)、列表(list)、集合(set)、有序集合(zset)。Redis还提供了Bitmap、HyperLogLog、Geo类型,但这些类型都是基于上述核心数据类型实现的。
- 5.0版本中,Redis新增加了Streams数据类型,它是一个功能强大的、支持多播的、可持久化的消息队列。
- string可以存储字符串、数字和二进制数据,除了值可以是String以外,所有的键也可以是string,string最大可以存储大小为2M的数据。
- list保证数据线性有序且元素可重复,它支持lpush、blpush、rpop、brpop等操作,可以当作简单的消息队列使用,一个list最多可以存储2^32-1个元素 hash的值本身也是一个键值对结构,最多能存储2^32-1个元素
- set是无序不可重复的,它支持多个set求交集、并集、差集,适合实现共同关注之类的需求,一个set最多可以存储2^32-1个元素 zset是有序不可重复的,它通过给每个元素设置一个分数来作为排序的依据,一个zset最多可以存储2^32-1个元素。
- 加分回答 每种类型支持多个编码,每一种编码采取一个特殊的结构来实现 各类数据结构内部的编码及结构：
- string：编码分为int、raw、embstr；
- int底层实现为long,当数据为整数型并且可以用long类型表示时可以用long存储；
- embstr底层实现为占一块内存的SDS结构,当数据为长度不超过32字节的字符串时,选择以此结构连续存储元数据和值；
- raw底层实现为占两块内存的SDS,用于存储长度超过32字节的字符串数据,此时会在两块内存中分别存储元数据和值。
- list：编码分为ziplist、linkedlist和quicklist（3.2以前版本没有quicklist）。
- ziplist底层实现为压缩列表,当元素数量小于2且所有元素长度都小于64字节时,使用这种结构来存储；
- linkedlist底层实现为双端链表,当数据不符合ziplist条件时,使用这种结构存储；
- 3.2版本之后list一般采用quicklist的快速列表结构来代替前两种。
- hash：编码分为ziplist、hashtable两种,
- 其中ziplist底层实现为压缩列表,当键值对数量小于2,并且所有的键值长度都小于64字节时使用这种结构进行存储；
- hashtable底层实现为字典,当不符合压缩列表存储条件时,使用字典进行存储。
- set：编码分为inset和hashtable,intset底层实现为整数集合,当所有元素都是整数值且数量不超过2个时使用该结构存储,否则使用字典结构存储。
- zset：编码分为ziplist和skiplist,当元素数量小于128,并且每个元素长度都小于64字节时,使用ziplist压缩列表结构存储,否则使用skiplist的字典+跳表的结构存储。

# 乐观锁和悲观锁

- 乐观锁：乐观锁总是假设最好的情况,每次去拿数据的时候都认为别人不会修改,所以不会上锁,但是在更新的时候会判断一下在此期间别人有没有去更新这个数据,可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型,这样可以提高吞吐量**,像数据库提供的类似于write_condition机制,其实都是提供的乐观锁。
- 悲观锁：悲观锁总是假设最坏的情况,每次去拿数据的时候都认为别人会修改,所以每次在拿数据的时候都会上锁,这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用,其它线程阻塞,用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制,比如行锁,表锁等,读锁,写锁等,都是在做操作之前先上锁。 加分回答 两种锁的使用场景 乐观锁： GIT,SVN,CVS等代码版本控制管理器,就是一个乐观锁使用很好的场景,
- 例如：A、B程序员,同时从SVN服务器上下载了code.html文件,当A完成提交后,此时B再提交,那么会报版本冲突,此时需要B进行版本处理合并后,再提交到服务器。这其实就是乐观锁的实现全过程。如果此时使用的是悲观锁,那么意味者所有程序员都必须一个一个等待操作提交完,才能访问文件,这是难以接受的。 悲观锁： 悲观锁的好处在于可以减少并发,但是当并发量非常大的时候,由于锁消耗资源、锁定时间过长等原因,很容易导致系统性能下降,资源消耗严重。因此一般我们可以在并发量不是很大,并且出现并发情况导致的异常用户和系统都很难以接受的情况下,会选择悲观锁进行。

# 设计模式

- 创建型包括：单例模式、工厂方法模式、抽象工厂模式、建造者模式和原型模式；
- 结构型包括：代理模式、装饰模式、适配器模式、组合模式、桥梁模式、外观模式和享元模式；
- 行为型包括：模板方法模式、命令模式、责任链模式、策略模式、迭代器模式、中介者模式、观察者模式、备忘录模式、访问者模式、状态模式和解释器模式。 面试中不要求23种设计模式全部了解,但至少应掌握单例模式和工厂模式。 加分回答 可以说出知道的框架所用到的设计模式或底层设计模式,例如Spring中的单例模式、工厂模式,AQS的模板模式等等。
