---
title: 第一天
date: 10/27/2022 10:11:21 AM 
categories: 牛客刷题
comments: "true"
---
# 实现二叉树的前序遍历 #

```


		import java.util.*;
		
		/*
		 * public class TreeNode { // 树形结构
		 *   int val = 0;
		 *   TreeNode left = null;
		 *   TreeNode right = null;
		 *   public TreeNode(int val) {
		 *     this.val = val;
		 *   }
		 * }
		 */
		
		public class Solution {
		    /**
		     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
		     *
		     * 
		     * @param root TreeNode类 
		     * @return int整型一维数组
		     */
		
		    public List<Integer> list = new ArrayList<>();
		    public int[] preorderTraversal (TreeNode root) {
		        // write code here
		
		        list =  pre(root); // 先设置一个函数，让他把二叉树的节点存入list中方便输出 ， 简单来说就是把二叉树转化为list形式的
		        int[] res = new int[list.size()]; // 设定一个输出数组 ，我们要遍历的其实是这个数组

		        for(int i = 0; i < list.size(); i++){
		           res[i] = list.get(i);
		        }
		        return res;
		
		    }
		    List<Integer>  pre(TreeNode node){
		
		        if(node == null){
		                return list;
		        }
		        list.add(node.val);
		        pre(node.left);
		        pre(node.right);
		        return list;
		    }
		}

```
- 其时间复杂度和空间复杂度都是O（N）
- 用堆栈实现
```
		
		/*
		 * public class TreeNode {
		 *   int val = 0;
		 *   TreeNode left = null;
		 *   TreeNode right = null;
		 *   public TreeNode(int val) {
		 *     this.val = val;
		 *   }
		 * }
		 */
		
		public class Solution {
		    /**
		     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
		     *
		     * 
		     * @param root TreeNode类 
		     * @return int整型一维数组
		     */
		    private List<Integer> list=new ArrayList<>();
		    public int[] preorderTraversal (TreeNode root) {
		        // write code here
		        if(root==null) return new int[0];
		        Stack<TreeNode> stack=new Stack<>();
		        stack.push(root);
		        while(!stack.isEmpty()){
		            TreeNode node=stack.pop();
		            list.add(node.val);
		            
		            if(node.right!=null) stack.push(node.right);
		            if(node.left!=null) stack.push(node.left);
		        }
		        int[] res= new int[list.size()];
		        for(int i=0;i<list.size();i++){
		            res[i]=list.get(i);
		        }
		        return res;
		    }
		    
		}
		
```
- 堆栈更简单可是更难理解，可以直接背
# 中序遍历 #
```


		import java.util.*;
		
		/*
		 * public class TreeNode {
		 *   int val = 0;
		 *   TreeNode left = null;
		 *   TreeNode right = null;
		 *   public TreeNode(int val) {
		 *     this.val = val;
		 *   }
		 * }
		 */
		
		public class Solution {
		    /**
		     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
		     *
		     * 
		     * @param root TreeNode类 
		     * @return int整型一维数组
		     */
		
		    List<Integer> list =new ArrayList<>();
		    public int[] inorderTraversal (TreeNode root) {
		        // write code here
		        pre(root);
		        int[] res = new int[list.size()];
		        for(int i = 0; i < list.size(); i++){
		            res[i] = list.get(i);
		        }
		        return res;
		    }
		
		    List<Integer> pre(TreeNode node){
		        if(node == null){
		            return list;
		        }
		        pre(node.left);
		        list.add(node.val);
		        pre(node.right);
		        return list;
		    }
		}

```
- 用堆栈实现
- 
```
		
		/*
		 * public class TreeNode {
		 *   int val = 0;
		 *   TreeNode left = null;
		 *   TreeNode right = null;
		 *   public TreeNode(int val) {
		 *     this.val = val;
		 *   }
		 * }
		 */
		
		public class Solution {
		    /**
		     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
		     *
		     * 
		     * @param root TreeNode类 
		     * @return int整型一维数组
		     */
		    private List<Integer> list=new ArrayList<>();
		    public int[] preorderTraversal (TreeNode root) {
		        // write code here
		        if(root==null) return new int[0];
		        Stack<TreeNode> stack=new Stack<>();
				
		        stack.push(root);
		        while(!stack.isEmpty()){
		            TreeNode node=stack.pop();
					if(node.right!=null) stack.push(node.right);
		            list.add(node.val);
		            if(node.left!=null) stack.push(node.left);
		        }
		        int[] res= new int[list.size()];
		        for(int i=0;i<list.size();i++){
		            res[i]=list.get(i);
		        }
		        return res;
		    }
		    
		}
		

```
# 二叉树的后序遍历 #
```

import java.util.*;
		
		/*
		 * public class TreeNode {
		 *   int val = 0;
		 *   TreeNode left = null;
		 *   TreeNode right = null;
		 *   public TreeNode(int val) {
		 *     this.val = val;
		 *   }
		 * }
		 */
		
		public class Solution {
		    /**
		     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
		     *
		     * 
		     * @param root TreeNode类 
		     * @return int整型一维数组
		     */
		
		    List<Integer> list =new ArrayList<>();
		    public int[] inorderTraversal (TreeNode root) {
		        // write code here
		        pre(root);
		        int[] res = new int[list.size()];
		        for(int i = 0; i < list.size(); i++){
		            res[i] = list.get(i);
		        }
		        return res;
		    }
		
		    List<Integer> pre(TreeNode node){
		        if(node == null){
		            return list;
		        }
		        pre(node.right);
		        list.add(node.val);
		        pre(node.left);
		        return list;
		    }
		}

```
- 用堆栈实现
```


		/*
		 * public class TreeNode {
		 *   int val = 0;
		 *   TreeNode left = null;
		 *   TreeNode right = null;
		 *   public TreeNode(int val) {
		 *     this.val = val;
		 *   }
		 * }
		 */
		
		public class Solution {
		    /**
		     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
		     *
		     * 
		     * @param root TreeNode类 
		     * @return int整型一维数组
		     */
		    private List<Integer> list=new ArrayList<>();
		    public int[] preorderTraversal (TreeNode root) {
		        // write code here
		        if(root==null) return new int[0];
		        Stack<TreeNode> stack=new Stack<>();
				
		        stack.push(root);
		        while(!stack.isEmpty()){
		            TreeNode node=stack.pop();
 					if(node.left!=null) stack.push(node.left);
		            list.add(node.val);
					if(node.right!=null) stack.push(node.right);
		           
		        }
		        int[] res= new int[list.size()];
		        for(int i=0;i<list.size();i++){
		            res[i]=list.get(i);
		        }
		        return res;
		    }
		    
		}
		
```
# 二叉树的层序遍历 #
- bfs
- 
```

    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        //边界条件判断
        if (root == null)
            return new ArrayList<>();
        //队列
        Queue<TreeNode> queue = new LinkedList<>();
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        //根节点入队
        queue.add(root);
        //如果队列不为空就继续循环
        while (!queue.isEmpty()) {
            //BFS打印，levelNum表示的是每层的结点数
            int levelNum = queue.size();
            //subList存储的是每层的结点值
            ArrayList<Integer> subList = new ArrayList<>();
            for (int i = 0; i < levelNum; i++) {
                //出队
                TreeNode node = queue.poll();
                subList.add(node.val);
                //左右子节点如果不为空就加入到队列中
                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);
            }
            //把每层的结点值存储在res中，
            res.add(subList);
        }
        return res;
    }
```
- dfs
- 
```

    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        levelHelper(res, root, 0);
        return res;
    }

    public void levelHelper(ArrayList<ArrayList<Integer>> list, TreeNode root, int level) {
        //边界条件判断
        if (root == null)
            return;
        //level表示的是层数，如果level >= list.size()，说明到下一层了，所以
        //要先把下一层的list初始化，防止下面add的时候出现空指针异常
        if (level >= list.size()) {
            list.add(new ArrayList<>());
        }
        //level表示的是第几层，这里访问到第几层，我们就把数据加入到第几层
        list.get(level).add(root.val);
        //当前节点访问完之后，再使用递归的方式分别访问当前节点的左右子节点
        levelHelper(list, root.left, level + 1);
        levelHelper(list, root.right, level + 1);
    }

```
# 按照之字型打印二叉树 #
```


		import java.util.LinkedList;
		public class Solution {
		    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
		        LinkedList<TreeNode> q = new LinkedList<>();
		        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
		        boolean rev = true;
		        q.add(pRoot);
		        while(!q.isEmpty()){
		            int size = q.size();
		            ArrayList<Integer> list = new ArrayList<>();
		            for(int i=0; i<size; i++){
		                TreeNode node = q.poll();
		                if(node == null){continue;}
		                if(rev){
		                    list.add(node.val);
		                }else{
		                    list.add(0, node.val);
		                }
		                q.offer(node.left);
		                q.offer(node.right);
		            }
		            if(list.size()!=0){res.add(list);}
		            rev=!rev;
		        }
		        return res;
		    }
		}
```
# 二叉树的最大深度 #
```
		
		import java.util.*;
		public class Solution {
		    public int maxDepth (TreeNode root) {
		        //空节点没有深度
		        if(root == null) 
		            return 0;
		        //队列维护层次后续节点
		        Queue<TreeNode> q = new LinkedList<TreeNode>(); 
		        //根入队
		        q.offer(root); 
		        //记录深度
		        int res = 0; 
		        //层次遍历
		        while(!q.isEmpty()){ 
		            //记录当前层有多少节点
		            int n = q.size(); 
		            //遍历完这一层，再进入下一层
		            for(int i = 0; i < n; i++){ 
		                TreeNode node = q.poll();
		                //添加下一层的左右节点
		                if(node.left != null) 
		                    q.offer(node.left);
		                if(node.right != null)
		                    q.offer(node.right);
		            }
		            //深度加1
		            res++; 
		        }
		        return res; 
		    }
		}
```
- 用堆栈因该也可以，尝试想想
# 二叉树中和为某一个值的路径 #

```


		import java.util.*;
		
		/*
		 * public class TreeNode {
		 *   int val = 0;
		 *   TreeNode left = null;
		 *   TreeNode right = null;
		 * }
		 */
		
		public class Solution {
		    /**
		     * 
		     * @param root TreeNode类 
		     * @param sum int整型 
		     * @return bool布尔型
		     */
		    public boolean hasPathSum (TreeNode root, int sum) {
		        return helper(root,sum,0);
		    }
		    
		    public boolean helper(TreeNode node,int sum,int preSum){
		        if(node == null){
		            return false;
		        }
		        if(node.left == null && node.right == null){
		            return node.val + preSum == sum;
		        }
		        preSum += node.val;
		        return helper(node.left,sum,preSum) || helper(node.right,sum ,preSum);
		    }
		}

```
# 二叉搜索树和双向链表 #

```


		public class Solution {
		
		    TreeNode pre= null;
		    TreeNode root=null;
		    public TreeNode Convert(TreeNode pRootOfTree) {
		        if(pRootOfTree ==null) return null;
		        Convert(pRootOfTree.left);
		        if(root == null){
		            root=pRootOfTree;
		        }
		        if(pre!=null){
		            pRootOfTree.left=pre;
		            pre.right=pRootOfTree;
		        }
		        pre=pRootOfTree;
		        Convert(pRootOfTree.right);
		        return root;
		    }
		}
```